From 046dda54f79edbbec0454b959f5fe12e23136bef Mon Sep 17 00:00:00 2001
From: airidosas252 <airidaslideikis@gmail.com>
Date: Tue, 28 Jan 2025 20:03:39 +0200
Subject: [PATCH] Add Esync to hangover

Credits to Pablo (KreitinnSoftware) for these patches.

https://github.com/KreitinnSoftware/wine
---
 tur/hangover-wine/0005-esync-micewine.patch | 9854 +++++++++++++++++++
 tur/hangover-wine/0006-android-shm.patch    |  159 +
 2 files changed, 10013 insertions(+)
 create mode 100644 tur/hangover-wine/0005-esync-micewine.patch
 create mode 100644 tur/hangover-wine/0006-android-shm.patch

diff --git a/tur/hangover-wine/0005-esync-micewine.patch b/tur/hangover-wine/0005-esync-micewine.patch
new file mode 100644
index 000000000..a72b86972
--- /dev/null
+++ b/tur/hangover-wine/0005-esync-micewine.patch
@@ -0,0 +1,9854 @@
+From 478b08ca4547dbbc16a9c1f02cf557c20a1e0a05 Mon Sep 17 00:00:00 2001
+From: PabloLabs36 <pablolabs36@gmail.com>
+Date: Tue, 31 Dec 2024 12:40:36 -0300
+Subject: [PATCH] Apply 'eventfd_synchronization' patch from wine-staging
+
+---
+ README.esync                           |  196 ++++
+ configure                              |   98 ++
+ configure.ac                           |   10 +
+ dlls/dinput/gamepad.c                  |  790 ++++++++++++++
+ dlls/dinput/tests/driver_bus.spec      |    1 +
+ dlls/dinput/tests/driver_hid.spec      |    1 +
+ dlls/dinput/tests/driver_hid_poll.spec |    1 +
+ dlls/kernel32/path.c                   |   12 +-
+ dlls/kernel32/tests/path.c             |   94 ++
+ dlls/kernel32/tests/sync.c             |  462 ++++++++-
+ dlls/kernelbase/file.c                 |  136 ++-
+ dlls/mountmgr.sys/device.c             |   35 +-
+ dlls/mountmgr.sys/unixlib.c            |  119 +++
+ dlls/mountmgr.sys/unixlib.h            |    9 +
+ dlls/msvcp120/tests/msvcp120.c         |   75 +-
+ dlls/msvcp140/tests/msvcp140.c         |   63 +-
+ dlls/ntdll/Makefile.in                 |    3 +-
+ dlls/ntdll/tests/file.c                |  562 +++++++++-
+ dlls/ntdll/unix/esync.c                | 1325 ++++++++++++++++++++++++
+ dlls/ntdll/unix/esync.h                |   61 ++
+ dlls/ntdll/unix/file.c                 | 1064 ++++++++++++++++++-
+ dlls/ntdll/unix/loader.c               |    2 +
+ dlls/ntdll/unix/server.c               |    8 +-
+ dlls/ntdll/unix/sync.c                 |   59 ++
+ dlls/ntdll/unix/unix_private.h         |    1 +
+ dlls/ntdll/unix/virtual.c              |    1 +
+ dlls/rpcrt4/rpc_server.c               |    8 +-
+ dlls/user32/tests/msg.c                |   32 +-
+ include/config.h.in                    |   15 +
+ include/ddk/ntifs.h                    |    5 +
+ include/wine/server_protocol.h         |  100 +-
+ include/winnt.h                        |    1 +
+ programs/cmd/builtins.c                |   48 +-
+ programs/cmd/directory.c               |   61 ++
+ server/Makefile.in                     |    2 +
+ server/async.c                         |    2 +
+ server/atom.c                          |    1 +
+ server/change.c                        |    1 +
+ server/clipboard.c                     |    1 +
+ server/completion.c                    |    2 +
+ server/console.c                       |   42 +-
+ server/debugger.c                      |    2 +
+ server/device.c                        |   26 +
+ server/directory.c                     |    2 +
+ server/esync.c                         |  588 +++++++++++
+ server/esync.h                         |   35 +
+ server/event.c                         |   44 +-
+ server/fd.c                            |  182 +++-
+ server/file.c                          |    2 +
+ server/file.h                          |    1 +
+ server/handle.c                        |    1 +
+ server/hook.c                          |    1 +
+ server/mailslot.c                      |    4 +
+ server/main.c                          |    5 +
+ server/mapping.c                       |    3 +
+ server/mutex.c                         |    1 +
+ server/named_pipe.c                    |    6 +
+ server/object.c                        |    2 +
+ server/object.h                        |    2 +
+ server/process.c                       |   17 +
+ server/process.h                       |    1 +
+ server/protocol.def                    |   53 +-
+ server/queue.c                         |  104 +-
+ server/registry.c                      |    1 +
+ server/request.c                       |    1 +
+ server/request_handlers.h              |   36 +
+ server/request_trace.h                 |   67 ++
+ server/scheduler.c                     |  166 +++
+ server/semaphore.c                     |    1 +
+ server/serial.c                        |    1 +
+ server/signal.c                        |    1 +
+ server/sock.c                          |    3 +
+ server/symlink.c                       |    1 +
+ server/thread.c                        |   72 +-
+ server/thread.h                        |    8 +
+ server/timer.c                         |   19 +
+ server/token.c                         |    1 +
+ server/window.c                        |    1 +
+ server/winstation.c                    |    2 +
+ 79 files changed, 6788 insertions(+), 184 deletions(-)
+ create mode 100644 README.esync
+ create mode 100755 dlls/dinput/gamepad.c
+ create mode 100755 dlls/dinput/tests/driver_bus.spec
+ create mode 100755 dlls/dinput/tests/driver_hid.spec
+ create mode 100755 dlls/dinput/tests/driver_hid_poll.spec
+ create mode 100644 dlls/ntdll/unix/esync.c
+ create mode 100644 dlls/ntdll/unix/esync.h
+ create mode 100644 server/esync.c
+ create mode 100644 server/esync.h
+ create mode 100644 server/scheduler.c
+
+diff --git a/README.esync b/README.esync
+new file mode 100644
+index 000000000000..11d86563a105
+--- /dev/null
++++ b/README.esync
+@@ -0,0 +1,196 @@
++This is eventfd-based synchronization, or 'esync' for short. Turn it on with
++WINEESYNC=1; debug it with +esync.
++
++== BUGS AND LIMITATIONS ==
++
++Please let me know if you find any bugs. If you can, also attach a log with
+++seh,+pid,+esync,+server,+timestamp.
++
++If you get something like "eventfd: Too many open files" and then things start
++crashing, you've probably run out of file descriptors. esync creates one
++eventfd descriptor for each synchronization object, and some games may use a
++large number of these.  Linux by default limits a process to 4096 file
++descriptors, which probably was reasonable back in the nineties but isn't
++really anymore. (Fortunately Debian and derivatives [Ubuntu, Mint] already
++have a reasonable limit.) To raise the limit you'll want to edit
++/etc/security/limits.conf and add a line like
++
++* hard nofile 1048576
++
++then restart your session.
++
++On distributions using systemd, the settings in `/etc/security/limits.conf`
++will be overridden by systemd's own settings. If you run `ulimit -Hn` and it
++returns a lower number than the one you've previously set, then you can set
++
++DefaultLimitNOFILE=1048576
++
++in both `/etc/systemd/system.conf` and `/etc/systemd/user.conf`. You can then
++execute `sudo systemctl daemon-reexec` and restart your session. Check again
++with `ulimit -Hn` that the limit is correct.
++
++Also note that if the wineserver has esync active, all clients also must, and
++vice versa. Otherwise things will probably crash quite badly.
++
++== EXPLANATION ==
++
++The aim is to execute all synchronization operations in "user-space", that is,
++without going through wineserver. We do this using Linux's eventfd
++facility. The main impetus to using eventfd is so that we can poll multiple
++objects at once; in particular we can't do this with futexes, or pthread
++semaphores, or the like. The only way I know of to wait on any of multiple
++objects is to use select/poll/epoll to wait on multiple fds, and eventfd gives
++us those fds in a quite usable way.
++
++Whenever a semaphore, event, or mutex is created, we have the server, instead
++of creating a traditional server-side event/semaphore/mutex, instead create an
++'esync' primitive. These live in esync.c and are very slim objects; in fact,
++they don't even know what type of primitive they are. The server is involved
++at all because we still need a way of creating named objects, passing handles
++to another process, etc.
++
++The server creates an eventfd file descriptor with the requested parameters
++and passes it back to ntdll. ntdll creates an object of the appropriate type,
++then caches it in a table. This table is copied almost wholesale from the fd
++cache code in server.c.
++
++Specific operations follow quite straightforwardly from eventfd:
++
++* To release an object, or set an event, we simply write() to it.
++* An object is signalled if read() succeeds on it. Notably, we create all
++  eventfd descriptors with O_NONBLOCK, so that we can atomically check if an
++  object is signalled and grab it if it is. This also lets us reset events.
++* For objects whose state should not be reset upon waiting—e.g. manual-reset
++  events—we simply check for the POLLIN flag instead of reading.
++* Semaphores are handled by the EFD_SEMAPHORE flag. This matches up quite well
++  (although with some difficulties; see below).
++* Mutexes store their owner thread locally. This isn't reliable information if
++  a different process's thread owns the mutex, but this doesn't matter—a
++  thread should only care whether it owns the mutex, so it knows whether to
++  try waiting on it or simply to increase the recursion count.
++
++The interesting part about esync is that (almost) all waits happen in ntdll,
++including those on server-bound objects. The idea here is that on the server
++side, for any waitable object, we create an eventfd file descriptor (not an
++esync primitive), and then pass it to ntdll if the program tries to wait on
++it. These are cached too, so only the first wait will require a round trip to
++the server. Then the server signals the file descriptor as appropriate, and
++thereby wakes up the client. So far this is implemented for processes,
++threads, message queues (difficult; see below), and device managers (necessary
++for drivers to work). All of these are necessarily server-bound, so we
++wouldn't really gain anything by signalling on the client side instead. Of
++course, except possibly for message queues, it's not likely that any program
++(cutting-edge D3D game or not) is going to be causing a great wineserver load
++by waiting on any of these objects; the motivation was rather to provide a way
++to wait on ntdll-bound and server-bound objects at the same time.
++
++Some cases are still passed to the server, and there's probably no reason not
++to keep them that way. Those that I noticed while testing include: async
++objects, which are internal to the file APIs and never exposed to userspace,
++startup_info objects, which are internal to the loader and signalled when a
++process starts, and keyed events, which are exposed through an ntdll API
++(although not through kernel32) but can't be mixed with other objects (you
++have to use NtWaitForKeyedEvent()). Other cases include: named pipes, debug
++events, sockets, and timers. It's unlikely we'll want to optimize debug events
++or sockets (or any of the other, rather rare, objects), but it is possible
++we'll want to optimize named pipes or timers.
++
++There were two sort of complications when working out the above. The first one
++was events. The trouble is that (1) the server actually creates some events by
++itself and (2) the server sometimes manipulates events passed by the
++client. Resolving the first case was easy enough, and merely entailed creating
++eventfd descriptors for the events the same way as for processes and threads
++(note that we don't really lose anything this way; the events include
++"LowMemoryCondition" and the event that signals system processes to shut
++down). For the second case I basically had to hook the server-side event
++functions to redirect to esync versions if the event was actually an esync
++primitive.
++
++The second complication was message queues. The difficulty here is that X11
++signals events by writing into a pipe (at least I think it's a pipe?), and so
++as a result wineserver has to poll on that descriptor. In theory we could just
++let wineserver do so and then signal us as appropriate, except that wineserver
++only polls on the pipe when the thread is waiting for events (otherwise we'd
++get e.g. keyboard input while the thread is doing something else, and spin
++forever trying to wake up a thread that doesn't care). The obvious solution is
++just to poll on that fd ourselves, and that's what I did—it's just that
++getting the fd from wineserver was kind of ugly, and the code for waiting was
++also kind of ugly basically because we have to wait on both X11's fd and the
++"normal" process/thread-style wineserver fd that we use to signal sent
++messages. The upshot about the whole thing was that races are basically
++impossible, since a thread can only wait on its own queue.
++
++System APCs already work, since the server will forcibly suspend a thread if
++it's not already waiting, and so we just need to check for EINTR from
++poll(). User APCs and alertable waits are implemented in a similar style to
++message queues (well, sort of): whenever someone executes an alertable wait,
++we add an additional eventfd to the list, which the server signals when an APC
++arrives. If that eventfd gets signaled, we hand it off to the server to take
++care of, and return STATUS_USER_APC.
++
++Originally I kept the volatile state of semaphores and mutexes inside a
++variable local to the handle, with the knowledge that this would break if
++someone tried to open the handle elsewhere or duplicate it. It did, and so now
++this state is stored inside shared memory. This is of the POSIX variety, is
++allocated by the server (but never mapped there) and lives under the path
++"/wine-esync".
++
++There are a couple things that this infrastructure can't handle, although
++surprisingly there aren't that many. In particular:
++* Implementing wait-all, i.e. WaitForMultipleObjects(..., TRUE, ...), is not
++  exactly possible the way we'd like it to be possible. In theory that
++  function should wait until it knows all objects are available, then grab
++  them all at once atomically. The server (like the kernel) can do this
++  because the server is single-threaded and can't race with itself. We can't
++  do this in ntdll, though. The approach I've taken I've laid out in great
++  detail in the relevant patch, but for a quick summary we poll on each object
++  until it's signaled (but don't grab it), check them all again, and if
++  they're all signaled we try to grab them all at once in a tight loop, and if
++  we fail on any of them we reset the count on whatever we shouldn't have
++  consumed. Such a blip would necessarily be very quick.
++* The whole patchset only works on Linux, where eventfd is available. However,
++  it should be possible to make it work on a Mac, since eventfd is just a
++  quicker, easier way to use pipes (i.e. instead of writing 1 to the fd you'd
++  write 1 byte; instead of reading a 64-bit value from the fd you'd read as
++  many bytes as you can carry, which is admittedly less than 2**64 but
++  can probably be something reasonable.) It's also possible, although I
++  haven't yet looked, to use some different kind of synchronization
++  primitives, but pipes would be easiest to tack onto this framework.
++* PulseEvent() can't work the way it's supposed to work. Fortunately it's rare
++  and deprecated. It's also explicitly mentioned on MSDN that a thread can
++  miss the notification for a kernel APC, so in a sense we're not necessarily
++  doing anything wrong.
++
++There are some things that are perfectly implementable but that I just haven't
++done yet:
++* Other synchronizable server primitives. It's unlikely we'll need any of
++  these, except perhaps named pipes (which would honestly be rather difficult)
++  and (maybe) timers.
++* Access masks. We'd need to store these inside ntdll, and validate them when
++  someone tries to execute esync operations.
++
++This patchset was inspired by Daniel Santos' "hybrid synchronization"
++patchset. My idea was to create a framework whereby even contended waits could
++be executed in userspace, eliminating a lot of the complexity that his
++synchronization primitives used. I do however owe some significant gratitude
++toward him for setting me on the right path.
++
++I've tried to maximize code separation, both to make any potential rebases
++easier and to ensure that esync is only active when configured. All code in
++existing source files is guarded with "if (do_esync())", and generally that
++condition is followed by "return esync_version_of_this_method(...);", where
++the latter lives in esync.c and is declared in esync.h. I've also tried to
++make the patchset very clear and readable—to write it as if I were going to
++submit it upstream. (Some intermediate patches do break things, which Wine is
++generally against, but I think it's for the better in this case.) I have cut
++some corners, though; there is some error checking missing, or implicit
++assumptions that the program is behaving correctly.
++
++I've tried to be careful about races. There are a lot of comments whose
++purpose are basically to assure me that races are impossible. In most cases we
++don't have to worry about races since all of the low-level synchronization is
++done by the kernel.
++
++Anyway, yeah, this is esync. Use it if you like.
++
++--Zebediah Figura
+diff --git a/configure b/configure
+index a64ddab4b038..76ad0b8bfad2 100755
+--- a/configure
++++ b/configure
+@@ -7902,6 +7902,12 @@ if test "x$ac_cv_header_sys_event_h" = xyes
+ then :
+   printf "%s\n" "#define HAVE_SYS_EVENT_H 1" >>confdefs.h
+ 
++fi
++ac_fn_c_check_header_compile "$LINENO" "sys/eventfd.h" "ac_cv_header_sys_eventfd_h" "$ac_includes_default"
++if test "x$ac_cv_header_sys_eventfd_h" = xyes
++then :
++  printf "%s\n" "#define HAVE_SYS_EVENTFD_H 1" >>confdefs.h
++
+ fi
+ ac_fn_c_check_header_compile "$LINENO" "sys/extattr.h" "ac_cv_header_sys_extattr_h" "$ac_includes_default"
+ if test "x$ac_cv_header_sys_extattr_h" = xyes
+@@ -20956,6 +20962,12 @@ if test "x$ac_cv_func_posix_fallocate" = xyes
+ then :
+   printf "%s\n" "#define HAVE_POSIX_FALLOCATE 1" >>confdefs.h
+ 
++fi
++ac_fn_c_check_func "$LINENO" "ppoll" "ac_cv_func_ppoll"
++if test "x$ac_cv_func_ppoll" = xyes
++then :
++  printf "%s\n" "#define HAVE_PPOLL 1" >>confdefs.h
++
+ fi
+ ac_fn_c_check_func "$LINENO" "prctl" "ac_cv_func_prctl"
+ if test "x$ac_cv_func_prctl" = xyes
+@@ -20974,6 +20986,18 @@ if test "x$ac_cv_func_sched_yield" = xyes
+ then :
+   printf "%s\n" "#define HAVE_SCHED_YIELD 1" >>confdefs.h
+ 
++fi
++ac_fn_c_check_func "$LINENO" "renameat" "ac_cv_func_renameat"
++if test "x$ac_cv_func_renameat" = xyes
++then :
++  printf "%s\n" "#define HAVE_RENAMEAT 1" >>confdefs.h
++
++fi
++ac_fn_c_check_func "$LINENO" "renameat2" "ac_cv_func_renameat2"
++if test "x$ac_cv_func_renameat2" = xyes
++then :
++  printf "%s\n" "#define HAVE_RENAMEAT2 1" >>confdefs.h
++
+ fi
+ ac_fn_c_check_func "$LINENO" "setproctitle" "ac_cv_func_setproctitle"
+ if test "x$ac_cv_func_setproctitle" = xyes
+@@ -21088,6 +21112,80 @@ fi
+ 
+ LIBS=$ac_save_LIBS
+ 
++ac_save_LIBS=$LIBS
++{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for library containing shm_open" >&5
++printf %s "checking for library containing shm_open... " >&6; }
++if test ${ac_cv_search_shm_open+y}
++then :
++  printf %s "(cached) " >&6
++else case e in #(
++  e) ac_func_search_save_LIBS=$LIBS
++cat confdefs.h - <<_ACEOF >conftest.$ac_ext
++/* end confdefs.h.  */
++
++/* Override any GCC internal prototype to avoid an error.
++   Use char because int might match the return type of a GCC
++   builtin and then its argument prototype would still apply.
++   The 'extern "C"' is for builds by C++ compilers;
++   although this is not generally supported in C code supporting it here
++   has little cost and some practical benefit (sr 110532).  */
++#ifdef __cplusplus
++extern "C"
++#endif
++char shm_open (void);
++int
++main (void)
++{
++return shm_open ();
++  ;
++  return 0;
++}
++_ACEOF
++for ac_lib in '' rt
++do
++  if test -z "$ac_lib"; then
++    ac_res="none required"
++  else
++    ac_res=-l$ac_lib
++    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
++  fi
++  if ac_fn_c_try_link "$LINENO"
++then :
++  ac_cv_search_shm_open=$ac_res
++fi
++rm -f core conftest.err conftest.$ac_objext conftest.beam \
++    conftest$ac_exeext
++  if test ${ac_cv_search_shm_open+y}
++then :
++  break
++fi
++done
++if test ${ac_cv_search_shm_open+y}
++then :
++
++else case e in #(
++  e) ac_cv_search_shm_open=no ;;
++esac
++fi
++rm conftest.$ac_ext
++LIBS=$ac_func_search_save_LIBS ;;
++esac
++fi
++{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_search_shm_open" >&5
++printf "%s\n" "$ac_cv_search_shm_open" >&6; }
++ac_res=$ac_cv_search_shm_open
++if test "$ac_res" != no
++then :
++  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
++
++printf "%s\n" "#define HAVE_SHM_OPEN 1" >>confdefs.h
++
++                test "$ac_res" = "none required" || RT_LIBS="$ac_res"
++
++fi
++
++LIBS=$ac_save_LIBS
++
+ { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for sched_setaffinity" >&5
+ printf %s "checking for sched_setaffinity... " >&6; }
+ if test ${wine_cv_have_sched_setaffinity+y}
+diff --git a/configure.ac b/configure.ac
+index c208290766b7..f5661266699f 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -411,6 +411,7 @@ AC_CHECK_HEADERS(\
+ 	sys/cdio.h \
+ 	sys/epoll.h \
+ 	sys/event.h \
++	sys/eventfd.h \
+ 	sys/extattr.h \
+ 	sys/filio.h \
+ 	sys/ipc.h \
+@@ -2067,9 +2068,12 @@ AC_CHECK_FUNCS(\
+ 	port_create \
+ 	posix_fadvise \
+ 	posix_fallocate \
++	ppoll \
+ 	prctl \
+ 	sched_getcpu \
+ 	sched_yield \
++	renameat \
++	renameat2 \
+ 	setproctitle \
+ 	setprogname \
+ 	sigprocmask \
+@@ -2086,6 +2090,12 @@ AC_SEARCH_LIBS(clock_gettime, rt,
+                 test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
+ LIBS=$ac_save_LIBS
+ 
++ac_save_LIBS=$LIBS
++AC_SEARCH_LIBS(shm_open, rt,
++               [AC_DEFINE(HAVE_SHM_OPEN, 1, [Define to 1 if you have the `shm_open' function.])
++                test "$ac_res" = "none required" || AC_SUBST(RT_LIBS,"$ac_res")])
++LIBS=$ac_save_LIBS
++
+ AC_CACHE_CHECK([for sched_setaffinity],wine_cv_have_sched_setaffinity,
+                 AC_LINK_IFELSE([AC_LANG_PROGRAM(
+ [[#include <sched.h>]], [[sched_setaffinity(0, 0, 0);]])],[wine_cv_have_sched_setaffinity=yes],[wine_cv_have_sched_setaffinity=no]))
+diff --git a/dlls/dinput/gamepad.c b/dlls/dinput/gamepad.c
+new file mode 100755
+index 000000000000..7688e0295e9d
+--- /dev/null
++++ b/dlls/dinput/gamepad.c
+@@ -0,0 +1,790 @@
++/*  DirectInput Gamepad device
++ *
++ * Copyright 2024 BrunoSX
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#include <stdarg.h>
++#include <string.h>
++#include <math.h>
++
++#include "windef.h"
++#include "winbase.h"
++#include "wingdi.h"
++#include "winternl.h"
++#include "winuser.h"
++#include "winerror.h"
++#include "winreg.h"
++#include "dinput.h"
++#include "winsock2.h"
++#include "devguid.h"
++#include "hidusage.h"
++
++#include "dinput_private.h"
++#include "device_private.h"
++#include "wine/debug.h"
++
++WINE_DEFAULT_DEBUG_CHANNEL(dinput);
++
++#define SERVER_PORT 7979
++#define CLIENT_PORT 7980
++#define BUFFER_SIZE 64
++
++#define REQUEST_CODE_GET_GAMEPAD 8
++#define REQUEST_CODE_GET_GAMEPAD_STATE 9
++#define REQUEST_CODE_RELEASE_GAMEPAD 10
++
++#define MAPPER_TYPE_STANDARD 0
++#define MAPPER_TYPE_XINPUT 1
++
++#define IDX_BUTTON_A 0
++#define IDX_BUTTON_B 1
++#define IDX_BUTTON_X 2
++#define IDX_BUTTON_Y 3
++#define IDX_BUTTON_L1 4
++#define IDX_BUTTON_R1 5
++#define IDX_BUTTON_L2 10
++#define IDX_BUTTON_R2 11
++#define IDX_BUTTON_SELECT 6
++#define IDX_BUTTON_START 7
++#define IDX_BUTTON_L3 8
++#define IDX_BUTTON_R3 9
++
++struct gamepad_state 
++{
++    short buttons;
++    char dpad;
++    short thumb_lx;
++    short thumb_ly;
++    short thumb_rx;
++    short thumb_ry;    
++};
++
++struct gamepad
++{
++    struct dinput_device base;
++    struct gamepad_state state;
++};
++
++static const struct dinput_device_vtbl gamepad_vtbl;
++static SOCKET server_sock = INVALID_SOCKET;
++static BOOL winsock_loaded = FALSE;
++static int connected_gamepad_id = 0;
++static char mapper_type = MAPPER_TYPE_XINPUT;
++
++static inline struct gamepad *impl_from_IDirectInputDevice8W( IDirectInputDevice8W *iface )
++{
++    return CONTAINING_RECORD( CONTAINING_RECORD( iface, struct dinput_device, IDirectInputDevice8W_iface ), struct gamepad, base );
++}
++
++static void close_server_socket( void ) 
++{
++    if (server_sock != INVALID_SOCKET) 
++    {
++        closesocket( server_sock );
++        server_sock = INVALID_SOCKET;
++    }
++    
++    if (winsock_loaded) 
++    {
++        WSACleanup();
++        winsock_loaded = FALSE;
++    }    
++}
++
++static BOOL create_server_socket(void)
++{    
++    WSADATA wsa_data;
++    struct sockaddr_in server_addr;
++    int res;
++
++    close_server_socket();
++    
++    winsock_loaded = WSAStartup(MAKEWORD(2,2), &wsa_data) == NO_ERROR;
++    if (!winsock_loaded) return FALSE;
++    
++    server_addr.sin_family = AF_INET;
++
++    char* custom_ip = getenv("WINE_VJOY_IP");
++
++    if (custom_ip) {
++        server_addr.sin_addr.s_addr = inet_addr(custom_ip);
++    } else {
++        server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
++    }
++    
++    server_addr.sin_port = htons(SERVER_PORT);
++    
++    server_sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
++    if (server_sock == INVALID_SOCKET) return FALSE;
++
++    res = bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
++    if (res == SOCKET_ERROR) return FALSE;
++    
++    return TRUE;
++}
++
++static BOOL get_gamepad_request( DIDEVICEINSTANCEW *instance, DWORD version ) 
++{
++    int res, client_addr_len, gamepad_id, name_len;
++    char buffer[BUFFER_SIZE];
++    struct sockaddr_in client_addr;
++    DWORD size;
++    
++    client_addr.sin_family = AF_INET;
++    
++    char* custom_ip = getenv("WINE_VJOY_IP");
++
++    if (custom_ip) {
++        client_addr.sin_addr.s_addr = inet_addr(custom_ip);
++    } else {
++        client_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
++    }
++
++    client_addr.sin_port = htons( CLIENT_PORT );
++    client_addr_len = sizeof(client_addr);
++    
++    buffer[0] = REQUEST_CODE_GET_GAMEPAD;
++    buffer[1] = 0;
++    res = sendto( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, client_addr_len );
++    if (res == SOCKET_ERROR) return FALSE;
++    
++    res = recvfrom( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, &client_addr_len );
++    if (res == SOCKET_ERROR || buffer[0] != REQUEST_CODE_GET_GAMEPAD) return FALSE;
++    
++    memcpy( &gamepad_id, buffer + 1, 4 );
++    if (gamepad_id == 0) 
++    {
++        connected_gamepad_id = 0;
++        return FALSE;
++    }
++    connected_gamepad_id = gamepad_id;
++    mapper_type = buffer[5];
++    
++    char gamepad_name[] = "MiceWine Virtual Controller";
++    
++    size = instance->dwSize;
++    memset( instance, 0, size );
++    instance->dwSize = size;
++    instance->guidInstance = GUID_Joystick;
++    instance->guidProduct = GUID_Joystick;
++    instance->guidProduct.Data1 = MAKELONG( 0x045e, 0x028e );
++    if (version >= 0x0800) instance->dwDevType = DIDEVTYPE_HID | DI8DEVTYPE_GAMEPAD | (DI8DEVTYPEGAMEPAD_STANDARD << 8);
++    else instance->dwDevType = DIDEVTYPE_HID | DIDEVTYPE_JOYSTICK | (DIDEVTYPEJOYSTICK_GAMEPAD << 8);
++    instance->wUsagePage = HID_USAGE_PAGE_GENERIC;
++    instance->wUsage = HID_USAGE_GENERIC_GAMEPAD;
++    MultiByteToWideChar( CP_ACP, 0, gamepad_name, -1, instance->tszInstanceName, MAX_PATH );
++    MultiByteToWideChar( CP_ACP, 0, gamepad_name, -1, instance->tszProductName, MAX_PATH );
++    
++    return TRUE;
++}
++
++static LONG scale_value( LONG value, struct object_properties *properties )
++{
++    LONG log_min, log_max, phy_min, phy_max;
++    log_min = properties->logical_min;
++    log_max = properties->logical_max;
++    phy_min = properties->range_min;
++    phy_max = properties->range_max;
++
++    return phy_min + MulDiv( value - log_min, phy_max - phy_min, log_max - log_min );
++}
++
++static LONG scale_axis_value( LONG value, struct object_properties *properties )
++{
++    LONG log_ctr, log_min, log_max, phy_ctr, phy_min, phy_max;
++    log_min = properties->logical_min;
++    log_max = properties->logical_max;
++    phy_min = properties->range_min;
++    phy_max = properties->range_max;
++
++    if (phy_min == 0) phy_ctr = phy_max >> 1;
++    else phy_ctr = round( (phy_min + phy_max) / 2.0 );
++    if (log_min == 0) log_ctr = log_max >> 1;
++    else log_ctr = round( (log_min + log_max) / 2.0 );
++
++    value -= log_ctr;
++    if (value <= 0)
++    {
++        log_max = MulDiv( log_min - log_ctr, properties->deadzone, 10000 );
++        log_min = MulDiv( log_min - log_ctr, properties->saturation, 10000 );
++        phy_max = phy_ctr;
++    }
++    else
++    {
++        log_min = MulDiv( log_max - log_ctr, properties->deadzone, 10000 );
++        log_max = MulDiv( log_max - log_ctr, properties->saturation, 10000 );
++        phy_min = phy_ctr;
++    }
++
++    if (value <= log_min) return phy_min;
++    if (value >= log_max) return phy_max;
++    return phy_min + MulDiv( value - log_min, phy_max - phy_min, log_max - log_min );
++}
++
++static void handle_gamepad_input( IDirectInputDevice8W *iface, short thumb_lx, short thumb_ly, short thumb_rx, short thumb_ry, short buttons, char dpad ) 
++{
++    int i, j;
++    DWORD time, seq;
++    BOOL notify = FALSE;
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++    DIJOYSTATE *state = (DIJOYSTATE *)impl->base.device_state;
++    
++    time = GetCurrentTime();
++    seq = impl->base.dinput->evsequence++;    
++    
++    if (mapper_type == MAPPER_TYPE_STANDARD) 
++    {
++        if (thumb_lx != impl->state.thumb_lx)
++        {
++            impl->state.thumb_lx = thumb_lx;
++            state->lX = scale_axis_value(thumb_lx, &impl->base.object_properties[0]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 ), state->lX, time, seq );
++            notify = TRUE;
++        }
++        
++        if (thumb_ly != impl->state.thumb_ly) 
++        {
++            impl->state.thumb_ly = thumb_ly;
++            state->lY = scale_axis_value(thumb_ly, &impl->base.object_properties[1]);        
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 ), state->lY, time, seq );
++            notify = TRUE;
++        }
++        
++        if (thumb_rx != impl->state.thumb_rx) 
++        {
++            impl->state.thumb_rx = thumb_rx;
++            state->lZ = scale_axis_value(thumb_rx, &impl->base.object_properties[2]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 ), state->lZ, time, seq );
++            notify = TRUE;
++        }
++        
++        if (thumb_ry != impl->state.thumb_ry) 
++        {
++            impl->state.thumb_ry = thumb_ry;
++            state->lRz = scale_axis_value(thumb_ry, &impl->base.object_properties[5]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 ), state->lRz, time, seq );
++            notify = TRUE;
++        }
++        
++        if (buttons != impl->state.buttons) 
++        {
++            impl->state.buttons = buttons;
++            for (i = 0, j = 0; i < 12; i++)
++            {
++                switch (i)
++                {
++                case IDX_BUTTON_A: j = 1; break;
++                case IDX_BUTTON_B: j = 2; break;
++                case IDX_BUTTON_X: j = 0; break;
++                case IDX_BUTTON_Y: j = 3; break;
++                case IDX_BUTTON_L1: j = 4; break;
++                case IDX_BUTTON_R1: j = 5; break;
++                case IDX_BUTTON_L2: j = 6; break;
++                case IDX_BUTTON_R2: j = 7; break;
++                case IDX_BUTTON_SELECT: j = 8; break;
++                case IDX_BUTTON_START: j = 9; break;
++                case IDX_BUTTON_L3: j = 10; break;
++                case IDX_BUTTON_R3: j = 11; break;                
++                }
++                
++                state->rgbButtons[j] = (buttons & (1<<i)) ? 0x80 : 0x00;
++                queue_event( iface, DIDFT_BUTTON | DIDFT_MAKEINSTANCE( j ), state->rgbButtons[j], time, seq );    
++            }
++            notify = TRUE;        
++        }
++        
++        if (dpad != impl->state.dpad) 
++        {
++            impl->state.dpad = dpad;
++            state->rgdwPOV[0] = dpad != -1 ? dpad * 4500 : -1;
++            queue_event( iface, DIDFT_POV | DIDFT_MAKEINSTANCE( 0 ), state->rgdwPOV[0], time, seq );
++            notify = TRUE;
++        }        
++    }
++    else if (mapper_type == MAPPER_TYPE_XINPUT) 
++    {
++        if (thumb_lx != impl->state.thumb_lx) 
++        {
++            impl->state.thumb_lx = thumb_lx;
++            state->lX = scale_axis_value(thumb_lx, &impl->base.object_properties[0]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 ), state->lX, time, seq );
++            notify = TRUE;
++        }
++        
++        if (thumb_ly != impl->state.thumb_ly) 
++        {
++            impl->state.thumb_ly = thumb_ly;
++            state->lY = scale_axis_value(thumb_ly, &impl->base.object_properties[1]);        
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 ), state->lY, time, seq );
++            notify = TRUE;
++        }
++        
++        if (thumb_rx != impl->state.thumb_rx) 
++        {
++            impl->state.thumb_rx = thumb_rx;
++            state->lRx = scale_axis_value(thumb_rx, &impl->base.object_properties[3]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 ), state->lRx, time, seq );
++            notify = TRUE;
++        }
++        
++        if (thumb_ry != impl->state.thumb_ry) 
++        {
++            impl->state.thumb_ry = thumb_ry;
++            state->lRy = scale_axis_value(thumb_ry, &impl->base.object_properties[4]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 4 ), state->lRy, time, seq );
++            notify = TRUE;
++        }
++        
++        if (buttons != impl->state.buttons) 
++        {
++            impl->state.buttons = buttons;
++            for (i = 0; i < 10; i++)
++            {
++                state->rgbButtons[i] = (buttons & (1<<i)) ? 0x80 : 0x00;
++                queue_event( iface, DIDFT_BUTTON | DIDFT_MAKEINSTANCE( i ), state->rgbButtons[i], time, seq );    
++            }
++            
++            state->lZ = scale_value((buttons & (1<<10)) ? 32767 : ((buttons & (1<<11)) ? -32768 : 0), &impl->base.object_properties[2]);
++            queue_event( iface, DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 ), state->lZ, time, seq );
++            notify = TRUE;        
++        }
++        
++        if (dpad != impl->state.dpad) 
++        {
++            impl->state.dpad = dpad;
++            state->rgdwPOV[0] = dpad != -1 ? dpad * 4500 : -1;
++            queue_event( iface, DIDFT_POV | DIDFT_MAKEINSTANCE( 0 ), state->rgdwPOV[0], time, seq );
++            notify = TRUE;
++        }        
++    }
++    
++    if (notify && impl->base.hEvent) SetEvent( impl->base.hEvent );
++}
++
++static BOOL get_gamepad_state_request( IDirectInputDevice8W *iface )
++{
++    char buffer[BUFFER_SIZE];
++    int res, client_addr_len, gamepad_id, input;
++    char dpad;
++    short buttons, thumb_lx, thumb_ly, thumb_rx, thumb_ry;
++    struct sockaddr_in client_addr;
++    int i, j;
++    DWORD time, seq;
++    BOOL notify = FALSE;
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++    DIJOYSTATE *state = (DIJOYSTATE *)impl->base.device_state;
++    
++    time = GetCurrentTime();
++    seq = impl->base.dinput->evsequence++; 
++    
++    client_addr.sin_family = AF_INET;
++
++    char* custom_ip = getenv("WINE_VJOY_IP");
++
++    if (custom_ip) {
++        client_addr.sin_addr.s_addr = inet_addr(custom_ip);
++    } else {
++        client_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
++    }
++
++    client_addr.sin_port = htons( CLIENT_PORT );
++    client_addr_len = sizeof(client_addr);
++
++    buffer[0] = REQUEST_CODE_GET_GAMEPAD_STATE;
++    memcpy( buffer + 1, &connected_gamepad_id, 4 );
++    
++    res = sendto( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, client_addr_len );
++    if (res == SOCKET_ERROR) return FALSE;
++    
++    res = recvfrom( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, &client_addr_len );
++    if (res == SOCKET_ERROR || buffer[0] != REQUEST_CODE_GET_GAMEPAD_STATE || buffer[1] != 1) return FALSE;
++    
++    memcpy( &gamepad_id, buffer + 2, 4 );
++    if (gamepad_id != connected_gamepad_id) return FALSE;
++    
++    if (buffer[1] == 1) {
++        input = 1;
++    }
++
++    queue_event( iface, DIDFT_BUTTON | DIDFT_MAKEINSTANCE( input ), state->rgbButtons[input], time, seq );    
++    
++    handle_gamepad_input( iface, thumb_lx, thumb_ly, thumb_rx, thumb_ry, buttons, dpad );
++    return TRUE;
++}
++
++static void release_gamepad_request( void ) 
++{
++    char buffer[BUFFER_SIZE];
++    struct sockaddr_in client_addr;
++    int client_addr_len;
++    
++    client_addr.sin_family = AF_INET;
++
++    char* custom_ip = getenv("WINE_VJOY_IP");
++
++    if (custom_ip) {
++        client_addr.sin_addr.s_addr = inet_addr(custom_ip);
++    } else {
++        client_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
++    }
++
++    client_addr.sin_port = htons( CLIENT_PORT );
++    client_addr_len = sizeof(client_addr);
++    
++    buffer[0] = REQUEST_CODE_RELEASE_GAMEPAD;
++    sendto( server_sock, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&client_addr, client_addr_len );
++}
++
++HRESULT gamepad_enum_device( DWORD type, DWORD flags, DIDEVICEINSTANCEW *instance, DWORD version )
++{    
++    TRACE( "type %#lx, flags %#lx, instance %p, version %#lx.\n", type, flags, instance, version );
++    
++    if (!create_server_socket()) {
++        ERR("Determination\n");
++        //return DIERR_INPUTLOST;
++    }
++    return get_gamepad_request( instance, version ) ? DI_OK : DIERR_INPUTLOST;
++}
++
++static BOOL init_object_properties( struct dinput_device *device, UINT index, struct hid_value_caps *caps,
++                                    const DIDEVICEOBJECTINSTANCEW *instance, void *data )
++{
++    struct object_properties *properties;
++    
++    if (index == -1) return DIENUM_STOP;
++    properties = device->object_properties + index;
++
++    properties->logical_min = -32768;
++    properties->logical_max = 32767;
++    properties->range_min = 0;
++    properties->range_max = 65535;
++    properties->saturation = 10000;
++    properties->granularity = 1;
++
++    return DIENUM_CONTINUE;
++}
++
++static void gamepad_release( IDirectInputDevice8W *iface )
++{
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++    CloseHandle( impl->base.read_event );
++}
++
++static HRESULT gamepad_read( IDirectInputDevice8W *iface )
++{    
++    get_gamepad_state_request( iface );
++    Sleep( 16 );
++    return DI_OK;
++}
++
++static HRESULT gamepad_acquire( IDirectInputDevice8W *iface )
++{
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++    SetEvent( impl->base.read_event );
++    return DI_OK;
++}
++
++static HRESULT gamepad_unacquire( IDirectInputDevice8W *iface )
++{
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++    WaitForSingleObject( impl->base.read_event, INFINITE );
++    
++    connected_gamepad_id = 0;
++    release_gamepad_request();
++    close_server_socket();
++    return DI_OK;
++}
++
++static BOOL try_enum_object( struct dinput_device *impl, const DIPROPHEADER *filter, DWORD flags, enum_object_callback callback,
++                             UINT index, DIDEVICEOBJECTINSTANCEW *instance, void *data )
++{
++    if (flags != DIDFT_ALL && !(flags & DIDFT_GETTYPE( instance->dwType ))) return DIENUM_CONTINUE;
++
++    switch (filter->dwHow)
++    {
++    case DIPH_DEVICE:
++        return callback( impl, index, NULL, instance, data );
++    case DIPH_BYOFFSET:
++        if (filter->dwObj != instance->dwOfs) return DIENUM_CONTINUE;
++        return callback( impl, index, NULL, instance, data );
++    case DIPH_BYID:
++        if ((filter->dwObj & 0x00ffffff) != (instance->dwType & 0x00ffffff)) return DIENUM_CONTINUE;
++        return callback( impl, index, NULL, instance, data );
++    }
++
++    return DIENUM_CONTINUE;
++}
++
++static void get_device_objects( int *instance_count, DIDEVICEOBJECTINSTANCEW **out ) 
++{
++    int i, index = 0;
++    
++    *instance_count = 0;
++    *out = NULL;
++
++    if (mapper_type == MAPPER_TYPE_STANDARD) 
++    {
++        *instance_count = 17;
++        DIDEVICEOBJECTINSTANCEW instances[*instance_count];
++        
++        instances[index].guidType = GUID_XAxis;
++        instances[index].dwOfs = DIJOFS_X;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"X Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_X;
++        index++;
++        
++        instances[index].guidType = GUID_YAxis;
++        instances[index].dwOfs = DIJOFS_Y;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Y Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_Y;    
++        index++;
++        
++        instances[index].guidType = GUID_ZAxis;
++        instances[index].dwOfs = DIJOFS_Z;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Z Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_Z;    
++        index++;    
++
++        instances[index].guidType = GUID_RzAxis;
++        instances[index].dwOfs = DIJOFS_RZ;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Rz Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_RZ;    
++        index++;
++        
++        for (i = 0; i < 12; i++) 
++        {
++            instances[index].guidType = GUID_Button,
++            instances[index].dwOfs = DIJOFS_BUTTON( i ),
++            instances[index].dwType = DIDFT_BUTTON | DIDFT_MAKEINSTANCE( i ),
++            swprintf( instances[index].tszName, MAX_PATH, L"Button %d", i );
++            instances[index].wUsagePage = HID_USAGE_PAGE_BUTTON;
++            instances[index].wUsage = i + 1;
++            index++;
++        }
++        
++        instances[index].guidType = GUID_POV;
++        instances[index].dwOfs = DIJOFS_POV( 0 );
++        instances[index].dwType = DIDFT_POV | DIDFT_MAKEINSTANCE( 0 );
++        swprintf( instances[index].tszName, MAX_PATH, L"POV" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_HATSWITCH;
++        
++        *out = instances;
++    }
++    else if (mapper_type == MAPPER_TYPE_XINPUT) 
++    {
++        *instance_count = 16;
++        DIDEVICEOBJECTINSTANCEW instances[*instance_count];
++        
++        instances[index].guidType = GUID_XAxis;
++        instances[index].dwOfs = DIJOFS_X;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 0 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"X Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_X;
++        index++;
++        
++        instances[index].guidType = GUID_YAxis;
++        instances[index].dwOfs = DIJOFS_Y;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 1 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Y Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_Y;
++        index++;
++        
++        instances[index].guidType = GUID_ZAxis;
++        instances[index].dwOfs = DIJOFS_Z;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 2 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Z Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_Z;
++        index++;    
++
++        instances[index].guidType = GUID_RxAxis;
++        instances[index].dwOfs = DIJOFS_RX;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 3 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Rx Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_RX;
++        index++;
++
++        instances[index].guidType = GUID_RyAxis;
++        instances[index].dwOfs = DIJOFS_RY;
++        instances[index].dwType = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE( 4 );
++        instances[index].dwFlags = DIDOI_ASPECTPOSITION;
++        swprintf( instances[index].tszName, MAX_PATH, L"Ry Axis" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_RY;    
++        index++;
++        
++        for (i = 0; i < 10; i++) 
++        {
++            instances[index].guidType = GUID_Button,
++            instances[index].dwOfs = DIJOFS_BUTTON( i ),
++            instances[index].dwType = DIDFT_BUTTON | DIDFT_MAKEINSTANCE( i ),
++            swprintf( instances[index].tszName, MAX_PATH, L"Button %d", i );
++            instances[index].wUsagePage = HID_USAGE_PAGE_BUTTON;
++            instances[index].wUsage = i + 1;
++            index++;
++        }
++        
++        instances[index].guidType = GUID_POV;
++        instances[index].dwOfs = DIJOFS_POV( 0 );
++        instances[index].dwType = DIDFT_POV | DIDFT_MAKEINSTANCE( 0 );
++        swprintf( instances[index].tszName, MAX_PATH, L"POV" );
++        instances[index].wUsagePage = HID_USAGE_PAGE_GENERIC;
++        instances[index].wUsage = HID_USAGE_GENERIC_HATSWITCH;
++        
++        *out = instances;
++    }
++}
++
++static HRESULT gamepad_enum_objects( IDirectInputDevice8W *iface, const DIPROPHEADER *filter,
++                                     DWORD flags, enum_object_callback callback, void *context )
++{    
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++    int instance_count;
++    DIDEVICEOBJECTINSTANCEW* instances;
++    BOOL ret;
++    DWORD i;
++    
++    get_device_objects( &instance_count, &instances );
++
++    for (i = 0; i < instance_count; i++)
++    {
++        instances[i].dwSize = sizeof(DIDEVICEOBJECTINSTANCEW);
++        instances[i].wReportId = 1;
++        
++        ret = try_enum_object( &impl->base, filter, flags, callback, i, instances + i, context );
++        if (ret != DIENUM_CONTINUE) return DIENUM_STOP;
++    }
++
++    return DIENUM_CONTINUE;
++}
++
++static HRESULT gamepad_get_property(IDirectInputDevice8W *iface, DWORD property,
++                                    DIPROPHEADER *header, const DIDEVICEOBJECTINSTANCEW *instance)
++{
++    struct gamepad *impl = impl_from_IDirectInputDevice8W( iface );
++
++    switch (property)
++    {
++    case (DWORD_PTR)DIPROP_PRODUCTNAME:
++    {
++        DIPROPSTRING *value = (DIPROPSTRING *)header;
++        lstrcpynW( value->wsz, impl->base.instance.tszProductName, MAX_PATH );
++        return DI_OK;
++    }
++    case (DWORD_PTR)DIPROP_INSTANCENAME:
++    {
++        DIPROPSTRING *value = (DIPROPSTRING *)header;
++        lstrcpynW( value->wsz, impl->base.instance.tszInstanceName, MAX_PATH );
++        return DI_OK;
++    }
++    case (DWORD_PTR)DIPROP_VIDPID:
++    {
++        DIPROPDWORD *value = (DIPROPDWORD *)header;
++        value->dwData = MAKELONG( 0x045e, 0x028e );
++        return DI_OK;
++    }
++    case (DWORD_PTR)DIPROP_JOYSTICKID:
++    {
++        DIPROPDWORD *value = (DIPROPDWORD *)header;
++        value->dwData = connected_gamepad_id;
++        return DI_OK;
++    }
++    case (DWORD_PTR)DIPROP_GUIDANDPATH:
++    {
++        DIPROPGUIDANDPATH *value = (DIPROPGUIDANDPATH *)header;
++        value->guidClass = GUID_DEVCLASS_HIDCLASS;
++        lstrcpynW( value->wszPath, L"virtual#vid_045e&pid_028e&ig_00", MAX_PATH );
++        return DI_OK;
++    }
++    }
++
++    return DIERR_UNSUPPORTED;
++}
++
++HRESULT gamepad_create_device( struct dinput *dinput, const GUID *guid, IDirectInputDevice8W **out )
++{
++    static const DIPROPHEADER filter =
++    {
++        .dwSize = sizeof(filter),
++        .dwHeaderSize = sizeof(filter),
++        .dwHow = DIPH_DEVICE,
++    };    
++    struct gamepad *impl;
++    HRESULT hr;
++    
++    TRACE( "dinput %p, guid %s, out %p.\n", dinput, debugstr_guid( guid ), out );
++
++    *out = NULL;
++    if (!IsEqualGUID( &GUID_Joystick, guid )) return DIERR_DEVICENOTREG;
++
++    if (!(impl = calloc( 1, sizeof(*impl) ))) return E_OUTOFMEMORY;
++    dinput_device_init( &impl->base, &gamepad_vtbl, guid, dinput );
++    impl->base.crit.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": struct gamepad*->base.crit");
++    impl->base.read_event = CreateEventW( NULL, TRUE, FALSE, NULL );
++
++    gamepad_enum_device( 0, 0, &impl->base.instance, dinput->dwVersion );
++    impl->base.caps.dwDevType = impl->base.instance.dwDevType;
++    impl->base.caps.dwFirmwareRevision = 100;
++    impl->base.caps.dwHardwareRevision = 100;
++    impl->base.dwCoopLevel = DISCL_NONEXCLUSIVE | DISCL_BACKGROUND;
++    
++    if (FAILED(hr = dinput_device_init_device_format( &impl->base.IDirectInputDevice8W_iface ))) goto failed;
++    gamepad_enum_objects( &impl->base.IDirectInputDevice8W_iface, &filter, DIDFT_ABSAXIS, init_object_properties, NULL );
++
++    *out = &impl->base.IDirectInputDevice8W_iface;
++    return DI_OK;
++    
++failed:
++    IDirectInputDevice_Release( &impl->base.IDirectInputDevice8W_iface );
++    return hr;    
++}
++
++static const struct dinput_device_vtbl gamepad_vtbl =
++{
++    gamepad_release,
++    NULL,
++    gamepad_read,
++    gamepad_acquire,
++    gamepad_unacquire,
++    gamepad_enum_objects,
++    gamepad_get_property,
++    NULL,
++    NULL,
++    NULL,
++    NULL,
++    NULL,
++};
+\ No newline at end of file
+diff --git a/dlls/dinput/tests/driver_bus.spec b/dlls/dinput/tests/driver_bus.spec
+new file mode 100755
+index 000000000000..ad33444716a3
+--- /dev/null
++++ b/dlls/dinput/tests/driver_bus.spec
+@@ -0,0 +1 @@
++# nothing here yet
+diff --git a/dlls/dinput/tests/driver_hid.spec b/dlls/dinput/tests/driver_hid.spec
+new file mode 100755
+index 000000000000..ad33444716a3
+--- /dev/null
++++ b/dlls/dinput/tests/driver_hid.spec
+@@ -0,0 +1 @@
++# nothing here yet
+diff --git a/dlls/dinput/tests/driver_hid_poll.spec b/dlls/dinput/tests/driver_hid_poll.spec
+new file mode 100755
+index 000000000000..ad33444716a3
+--- /dev/null
++++ b/dlls/dinput/tests/driver_hid_poll.spec
+@@ -0,0 +1 @@
++# nothing here yet
+diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
+index f4bdc08b87e0..49c4c6437a84 100644
+--- a/dlls/kernel32/path.c
++++ b/dlls/kernel32/path.c
+@@ -463,8 +463,16 @@ WCHAR * CDECL wine_get_dos_file_name( LPCSTR str )
+  */
+ BOOLEAN WINAPI CreateSymbolicLinkA(LPCSTR link, LPCSTR target, DWORD flags)
+ {
+-    FIXME("(%s %s %ld): stub\n", debugstr_a(link), debugstr_a(target), flags);
+-    return TRUE;
++    WCHAR *linkW, *targetW;
++    BOOL ret;
++
++    if (!(linkW = FILE_name_AtoW( link, FALSE ))) return FALSE;
++    if (!(targetW = FILE_name_AtoW( target, TRUE ))) return FALSE;
++
++    ret = CreateSymbolicLinkW( linkW, targetW, flags );
++
++    HeapFree( GetProcessHeap(), 0, targetW );
++    return ret;
+ }
+ 
+ /*************************************************************************
+diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
+index 46eef74bce35..3a7fa3446160 100644
+--- a/dlls/kernel32/tests/path.c
++++ b/dlls/kernel32/tests/path.c
+@@ -83,6 +83,9 @@ static NTSTATUS (WINAPI *pLdrGetDllPath)(LPCWSTR,ULONG,LPWSTR*,LPWSTR*);
+ static BOOL (WINAPI *pCheckNameLegalDOS8Dot3W)(const WCHAR *, char *, DWORD, BOOL *, BOOL *);
+ static BOOL (WINAPI *pCheckNameLegalDOS8Dot3A)(const char *, char *, DWORD, BOOL *, BOOL *);
+ 
++/* Present in Vista+ */
++static BOOL (WINAPI *pCreateSymbolicLinkW)(LPCWSTR, LPCWSTR, DWORD);
++
+ /* a structure to deal with wine todos somewhat cleanly */
+ typedef struct {
+   DWORD shortlen;
+@@ -2106,6 +2109,7 @@ static void init_pointers(void)
+     MAKEFUNC(SetDefaultDllDirectories);
+     MAKEFUNC(CheckNameLegalDOS8Dot3W);
+     MAKEFUNC(CheckNameLegalDOS8Dot3A);
++    MAKEFUNC(CreateSymbolicLinkW);
+     mod = GetModuleHandleA("ntdll.dll");
+     MAKEFUNC(LdrGetDllPath);
+     MAKEFUNC(RtlGetExePath);
+@@ -2691,6 +2695,95 @@ static void test_LdrGetDllPath(void)
+     SetEnvironmentVariableW( pathW, old_path );
+ }
+ 
++static void test_CreateSymbolicLink(void)
++{
++    static const WCHAR target_fileW[] = {'t','a','r','g','e','t','_','f','i','l','e',0};
++    static const WCHAR target_dirW[] = {'t','a','r','g','e','t','_','d','i','r',0};
++    static const WCHAR linkW[] = {'l','i','n','k',0};
++    static const WCHAR fooW[] = {'f','o','o',0};
++    static WCHAR volW[] = {'c',':','\\',0};
++    static const WCHAR dotW[] = {'.',0};
++    WCHAR path[MAX_PATH], old_path[MAX_PATH], tmp[MAX_PATH];
++    DWORD dwLen, dwFlags;
++    TOKEN_PRIVILEGES tp;
++    HANDLE token;
++    LUID luid;
++    BOOL bret;
++    HANDLE h;
++
++    if (!pCreateSymbolicLinkW)
++    {
++        win_skip( "CreateSymbolicLink isn't available\n" );
++        return;
++    }
++
++    /* Create a temporary folder for the symlink tests */
++    GetTempFileNameW( dotW, fooW, 0, path );
++    DeleteFileW( path );
++    if (!CreateDirectoryW( path, NULL ))
++    {
++        win_skip("Unable to create a temporary reparse point directory.\n");
++        return;
++    }
++    GetCurrentDirectoryW( sizeof(old_path)/sizeof(WCHAR), old_path );
++    SetCurrentDirectoryW( path );
++
++    /* Check that the volume this folder is located on supports reparse points */
++    GetFullPathNameW( path, sizeof(tmp)/sizeof(WCHAR), tmp, NULL );
++    volW[0] = tmp[0];
++    GetVolumeInformationW( volW, 0, 0, 0, &dwLen, &dwFlags, 0, 0 );
++    if (!(dwFlags & FILE_SUPPORTS_REPARSE_POINTS))
++    {
++        skip("File system does not support reparse points.\n");
++        goto cleanup;
++    }
++
++    /* Establish permissions for symlink creation */
++    bret = OpenProcessToken( GetCurrentProcess(), TOKEN_ALL_ACCESS, &token );
++    ok(bret, "OpenProcessToken failed: %ld\n", GetLastError());
++    bret = LookupPrivilegeValueA( NULL, "SeCreateSymbolicLinkPrivilege", &luid );
++    todo_wine ok(bret || broken(!bret && GetLastError() == ERROR_NO_SUCH_PRIVILEGE) /* winxp */,
++                 "LookupPrivilegeValue failed: %lu\n", GetLastError());
++    if (bret)
++    {
++        tp.PrivilegeCount = 1;
++        tp.Privileges[0].Luid = luid;
++        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
++        bret = AdjustTokenPrivileges( token, FALSE, &tp, 0, NULL, NULL );
++        ok(bret, "AdjustTokenPrivileges failed: %ld\n", GetLastError());
++    }
++    if ((!bret && GetLastError() != ERROR_NO_SUCH_PRIVILEGE) || GetLastError() == ERROR_NOT_ALL_ASSIGNED)
++    {
++        win_skip("Insufficient permissions to perform symlink tests.\n");
++        goto cleanup;
++    }
++
++    /* Create a destination folder and file for symlinks to target */
++    bret = CreateDirectoryW( target_dirW, NULL );
++    ok(bret, "Failed to create symlink target directory.\n");
++    h = CreateFileW( target_fileW, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL );
++    ok(h != INVALID_HANDLE_VALUE, "Failed to create symlink target file.\n");
++    CloseHandle( h );
++
++    /* Create a directory symbolic link */
++    bret = CreateSymbolicLinkW( linkW, target_dirW, SYMBOLIC_LINK_FLAG_DIRECTORY );
++    ok(bret, "Failed to create directory symbolic link! (0x%lx)\n", GetLastError());
++    bret = RemoveDirectoryW( linkW );
++    ok(bret, "Failed to remove directory symbolic link! (0x%lx)\n", GetLastError());
++
++    /* Create a file symbolic link */
++    bret = CreateSymbolicLinkW( linkW, target_fileW, 0x0 );
++    ok(bret, "Failed to create file symbolic link! (0x%lx)\n", GetLastError());
++    bret = DeleteFileW( linkW );
++    ok(bret, "Failed to remove file symbolic link! (0x%lx)\n", GetLastError());
++
++cleanup:
++    DeleteFileW( target_fileW );
++    RemoveDirectoryW( target_dirW );
++    SetCurrentDirectoryW( old_path );
++    RemoveDirectoryW( path );
++}
++
+ START_TEST(path)
+ {
+     CHAR origdir[MAX_PATH],curdir[MAX_PATH], curDrive, otherDrive;
+@@ -2720,4 +2813,5 @@ START_TEST(path)
+     test_RtlGetSearchPath();
+     test_RtlGetExePath();
+     test_LdrGetDllPath();
++    test_CreateSymbolicLink();
+ }
+diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
+index 49420e4519f6..f2e1e13b33ab 100644
+--- a/dlls/kernel32/tests/sync.c
++++ b/dlls/kernel32/tests/sync.c
+@@ -58,6 +58,7 @@ static BOOLEAN (WINAPI *pTryAcquireSRWLockShared)(PSRWLOCK);
+ 
+ static NTSTATUS (WINAPI *pNtAllocateVirtualMemory)(HANDLE, PVOID *, ULONG_PTR, SIZE_T *, ULONG, ULONG);
+ static NTSTATUS (WINAPI *pNtFreeVirtualMemory)(HANDLE, PVOID *, SIZE_T *, ULONG);
++static NTSTATUS (WINAPI *pNtQuerySystemTime)(LARGE_INTEGER *);
+ static NTSTATUS (WINAPI *pNtWaitForSingleObject)(HANDLE, BOOLEAN, const LARGE_INTEGER *);
+ static NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,BOOLEAN,const LARGE_INTEGER*);
+ static PSLIST_ENTRY (__fastcall *pRtlInterlockedPushListSList)(PSLIST_HEADER list, PSLIST_ENTRY first,
+@@ -228,8 +229,23 @@ static void test_temporary_objects(void)
+     ok(GetLastError() == ERROR_FILE_NOT_FOUND, "wrong error %lu\n", GetLastError());
+ }
+ 
++static HANDLE mutex, mutex2, mutices[2];
++
++static DWORD WINAPI mutex_thread( void *param )
++{
++    DWORD expect = (DWORD)(DWORD_PTR)param;
++    DWORD ret;
++
++    ret = WaitForSingleObject( mutex, 0 );
++    ok(ret == expect, "expected %lu, got %lu\n", expect, ret);
++
++    if (!ret) ReleaseMutex( mutex );
++    return 0;
++}
++
+ static void test_mutex(void)
+ {
++    HANDLE thread;
+     DWORD wait_ret;
+     BOOL ret;
+     HANDLE hCreated;
+@@ -269,7 +285,8 @@ static void test_mutex(void)
+     SetLastError(0xdeadbeef);
+     hOpened = OpenMutexA(GENERIC_READ | GENERIC_WRITE, FALSE, "WineTestMutex");
+     ok(hOpened != NULL, "OpenMutex failed with error %ld\n", GetLastError());
+-    wait_ret = WaitForSingleObject(hOpened, INFINITE);
++    wait_ret = WaitForSingleObject(hOpened, 0);
++todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: validation is not implemented */
+     ok(wait_ret == WAIT_FAILED, "WaitForSingleObject succeeded\n");
+     CloseHandle(hOpened);
+ 
+@@ -300,6 +317,7 @@ static void test_mutex(void)
+ 
+     SetLastError(0xdeadbeef);
+     ret = ReleaseMutex(hCreated);
++todo_wine_if(getenv("WINEESYNC"))   /* XFAIL: due to the above */
+     ok(!ret && (GetLastError() == ERROR_NOT_OWNER),
+         "ReleaseMutex should have failed with ERROR_NOT_OWNER instead of %ld\n", GetLastError());
+ 
+@@ -338,6 +356,85 @@ static void test_mutex(void)
+     CloseHandle(hOpened);
+ 
+     CloseHandle(hCreated);
++
++    mutex = CreateMutexA( NULL, FALSE, NULL );
++    ok(!!mutex, "got error %lu\n", GetLastError());
++
++    ret = ReleaseMutex( mutex );
++    ok(!ret, "got %d\n", ret);
++    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
++
++    for (i = 0; i < 100; i++)
++    {
++        ret = WaitForSingleObject( mutex, 0 );
++        ok(ret == 0, "got %u\n", ret);
++    }
++
++    for (i = 0; i < 100; i++)
++    {
++        ret = ReleaseMutex( mutex );
++        ok(ret, "got error %lu\n", GetLastError());
++    }
++
++    ret = ReleaseMutex( mutex );
++    ok(!ret, "got %d\n", ret);
++    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
++
++    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
++    ret = WaitForSingleObject( thread, 2000 );
++    ok(ret == 0, "wait failed: %u\n", ret);
++
++    WaitForSingleObject( mutex, 0 );
++
++    thread = CreateThread( NULL, 0, mutex_thread, (void *)WAIT_TIMEOUT, 0, NULL );
++    ret = WaitForSingleObject( thread, 2000 );
++    ok(ret == 0, "wait failed: %u\n", ret);
++
++    ret = ReleaseMutex( mutex );
++        ok(ret, "got error %lu\n", GetLastError());
++
++    thread = CreateThread( NULL, 0, mutex_thread, (void *)0, 0, NULL );
++    ret = WaitForSingleObject( thread, 2000 );
++    ok(ret == 0, "wait failed: %u\n", ret);
++
++    mutex2 = CreateMutexA( NULL, TRUE, NULL );
++    ok(!!mutex2, "got error %lu\n", GetLastError());
++
++    ret = ReleaseMutex( mutex2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = ReleaseMutex( mutex2 );
++    ok(!ret, "got %d\n", ret);
++    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
++
++    mutices[0] = mutex;
++    mutices[1] = mutex2;
++
++    ret = WaitForMultipleObjects( 2, mutices, FALSE, 0 );
++    ok(ret == 0, "got %u\n", ret);
++
++    ret = ReleaseMutex( mutex );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = ReleaseMutex( mutex2 );
++    ok(!ret, "got %d\n", ret);
++    ok(GetLastError() == ERROR_NOT_OWNER, "got error %lu\n", GetLastError());
++
++    ret = WaitForMultipleObjects( 2, mutices, TRUE, 0 );
++    ok(ret == 0, "got %u\n", ret);
++
++    ret = ReleaseMutex( mutex );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = ReleaseMutex( mutex2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = CloseHandle( mutex );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = CloseHandle( mutex2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
+ }
+ 
+ static void test_slist(void)
+@@ -513,12 +610,13 @@ static void test_slist(void)
+ 
+ static void test_event(void)
+ {
+-    HANDLE handle, handle2;
++    HANDLE handle, handle2, handles[2];
+     SECURITY_ATTRIBUTES sa;
+     SECURITY_DESCRIPTOR sd;
+     ACL acl;
+     DWORD ret;
+     BOOL val;
++    int i;
+ 
+     /* no sd */
+     handle = CreateEventA(NULL, FALSE, FALSE, __FILE__ ": Test Event");
+@@ -622,11 +720,130 @@ static void test_event(void)
+     ok( ret, "QueryMemoryResourceNotification failed err %lu\n", GetLastError() );
+     ok( val == FALSE || val == TRUE, "wrong value %u\n", val );
+     CloseHandle( handle );
++
++    handle = CreateEventA( NULL, TRUE, FALSE, NULL );
++    ok(!!handle, "got error %lu\n", GetLastError());
++
++    ret = WaitForSingleObject( handle, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ret = SetEvent( handle );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = SetEvent( handle );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    for (i = 0; i < 100; i++)
++    {
++        ret = WaitForSingleObject( handle, 0 );
++        ok(ret == 0, "got %lu\n", ret);
++    }
++
++    ret = ResetEvent( handle );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = ResetEvent( handle );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = WaitForSingleObject( handle, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    handle2 = CreateEventA( NULL, FALSE, TRUE, NULL );
++    ok(!!handle2, "got error %lu\n", GetLastError());
++
++    ret = WaitForSingleObject( handle2, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForSingleObject( handle2, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ret = SetEvent( handle2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = SetEvent( handle2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = ResetEvent( handle2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = ResetEvent( handle2 );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = WaitForSingleObject( handle2, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    handles[0] = handle;
++    handles[1] = handle2;
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    SetEvent( handle );
++    SetEvent( handle2 );
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForSingleObject( handle2, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ResetEvent( handle );
++    SetEvent( handle2 );
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 1, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    SetEvent( handle );
++    SetEvent( handle2 );
++
++    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    SetEvent( handle2 );
++    ResetEvent( handle );
++
++    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ret = WaitForSingleObject( handle2, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    handles[0] = handle2;
++    handles[1] = handle;
++    SetEvent( handle );
++    SetEvent( handle2 );
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 1, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 1, "got %lu\n", ret);
++
++    ret = CloseHandle( handle );
++    ok(ret, "got error %lu\n", GetLastError());
++
++    ret = CloseHandle( handle2 );
++    ok(ret, "got error %lu\n", GetLastError());
+ }
+ 
+ static void test_semaphore(void)
+ {
+-    HANDLE handle, handle2;
++    HANDLE handle, handle2, handles[2];
++    DWORD ret;
++    LONG prev;
++    int i;
+ 
+     /* test case sensitivity */
+ 
+@@ -668,6 +885,99 @@ static void test_semaphore(void)
+     ok( GetLastError() == ERROR_INVALID_PARAMETER, "wrong error %lu\n", GetLastError());
+ 
+     CloseHandle( handle );
++
++    handle = CreateSemaphoreA( NULL, 0, 5, NULL );
++    ok(!!handle, "CreateSemaphore failed: %lu\n", GetLastError());
++
++    ret = WaitForSingleObject( handle, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ret = ReleaseSemaphore( handle, 1, &prev );
++    ok(ret, "got error %lu\n", GetLastError());
++    ok(prev == 0, "got prev %ld\n", prev);
++
++    ret = ReleaseSemaphore( handle, 1, &prev );
++    ok(ret, "got error %lu\n", GetLastError());
++    ok(prev == 1, "got prev %ld\n", prev);
++
++    ret = ReleaseSemaphore( handle, 5, &prev );
++    ok(!ret, "got %ld\n", ret);
++    ok(GetLastError() == ERROR_TOO_MANY_POSTS, "got error %lu\n", GetLastError());
++    ok(prev == 1, "got prev %ld\n", prev);
++
++    ret = ReleaseSemaphore( handle, 2, &prev );
++    ok(ret, "got error %lu\n", GetLastError());
++    ok(prev == 2, "got prev %ld\n", prev);
++
++    ret = ReleaseSemaphore( handle, 1, &prev );
++    ok(ret, "got error %lu\n", GetLastError());
++    ok(prev == 4, "got prev %ld\n", prev);
++
++    for (i = 0; i < 5; i++)
++    {
++        ret = WaitForSingleObject( handle, 0 );
++        ok(ret == 0, "got %lu\n", ret);
++    }
++
++    ret = WaitForSingleObject( handle, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    handle2 = CreateSemaphoreA( NULL, 3, 5, NULL );
++    ok(!!handle2, "CreateSemaphore failed: %lu\n", GetLastError());
++
++    ret = ReleaseSemaphore( handle2, 1, &prev );
++    ok(ret, "got error %lu\n", GetLastError());
++    ok(prev == 3, "got prev %ld\n", prev);
++
++    for (i = 0; i < 4; i++)
++    {
++        ret = WaitForSingleObject( handle2, 0 );
++        ok(ret == 0, "got %lu\n", ret);
++    }
++
++    ret = WaitForSingleObject( handle2, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    handles[0] = handle;
++    handles[1] = handle2;
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ReleaseSemaphore( handle, 1, NULL );
++    ReleaseSemaphore( handle2, 1, NULL );
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == 1, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ReleaseSemaphore( handle, 1, NULL );
++    ReleaseSemaphore( handle2, 1, NULL );
++
++    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForMultipleObjects( 2, handles, FALSE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ReleaseSemaphore( handle, 1, NULL );
++
++    ret = WaitForMultipleObjects( 2, handles, TRUE, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    ret = WaitForSingleObject( handle, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = CloseHandle( handle );
++    ok(ret, "got error %lu\n", ret);
++
++    ret = CloseHandle( handle2 );
++    ok(ret, "got error %lu\n", ret);
+ }
+ 
+ static void test_waitable_timer(void)
+@@ -1222,11 +1532,15 @@ static HANDLE modify_handle(HANDLE handle, DWORD modify)
+     return ULongToHandle(tmp);
+ }
+ 
++#define TIMEOUT_INFINITE (((LONGLONG)0x7fffffff) << 32 | 0xffffffff)
++
+ static void test_WaitForSingleObject(void)
+ {
+     HANDLE signaled, nonsignaled, invalid;
++    LARGE_INTEGER ntnow, ntthen;
+     LARGE_INTEGER timeout;
+     NTSTATUS status;
++    DWORD now, then;
+     DWORD ret;
+ 
+     signaled = CreateEventW(NULL, TRUE, TRUE, NULL);
+@@ -1311,6 +1625,68 @@ static void test_WaitForSingleObject(void)
+     status = pNtWaitForSingleObject(GetCurrentThread(), FALSE, &timeout);
+     ok(status == STATUS_TIMEOUT, "expected STATUS_TIMEOUT, got %08lx\n", status);
+ 
++    ret = WaitForSingleObject( signaled, 0 );
++    ok(ret == 0, "got %lu\n", ret);
++
++    ret = WaitForSingleObject( nonsignaled, 0 );
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++
++    /* test that a timed wait actually does wait */
++    now = GetTickCount();
++    ret = WaitForSingleObject( nonsignaled, 100 );
++    then = GetTickCount();
++    ok(ret == WAIT_TIMEOUT, "got %lu\n", ret);
++    ok(abs((then - now) - 100) < 5, "got %lu ms\n", then - now);
++
++    now = GetTickCount();
++    ret = WaitForSingleObject( signaled, 100 );
++    then = GetTickCount();
++    ok(ret == 0, "got %lu\n", ret);
++    ok(abs(then - now) < 5, "got %lu ms\n", then - now);
++
++    ret = WaitForSingleObject( signaled, INFINITE );
++    ok(ret == 0, "got %lu\n", ret);
++
++    /* test NT timeouts */
++    pNtQuerySystemTime( &ntnow );
++    timeout.QuadPart = ntnow.QuadPart + 100 * 10000;
++    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
++    pNtQuerySystemTime( &ntthen );
++    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
++    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
++        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
++
++    pNtQuerySystemTime( &ntnow );
++    timeout.QuadPart = -100 * 10000;
++    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
++    pNtQuerySystemTime( &ntthen );
++    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
++    ok(abs(((ntthen.QuadPart - ntnow.QuadPart) / 10000) - 100) < 5, "got %s ns\n",
++        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
++
++    status = pNtWaitForSingleObject( signaled, FALSE, NULL );
++    ok(status == 0, "got %#lx\n", status);
++
++    timeout.QuadPart = TIMEOUT_INFINITE;
++    status = pNtWaitForSingleObject( signaled, FALSE, &timeout );
++    ok(status == 0, "got %#lx\n", status);
++
++    pNtQuerySystemTime( &ntnow );
++    timeout.QuadPart = ntnow.QuadPart;
++    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
++    pNtQuerySystemTime( &ntthen );
++    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
++    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
++        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
++
++    pNtQuerySystemTime( &ntnow );
++    timeout.QuadPart = ntnow.QuadPart - 100 * 10000;
++    status = pNtWaitForSingleObject( nonsignaled, FALSE, &timeout );
++    pNtQuerySystemTime( &ntthen );
++    ok(status == STATUS_TIMEOUT, "got %#lx\n", status);
++    ok(abs((ntthen.QuadPart - ntnow.QuadPart) / 10000) < 5, "got %s ns\n",
++        wine_dbgstr_longlong((ntthen.QuadPart - ntnow.QuadPart) * 100));
++
+     CloseHandle(signaled);
+     CloseHandle(nonsignaled);
+ }
+@@ -2904,6 +3280,84 @@ static void test_QueueUserAPC(void)
+     ok(apc_count == 1, "APC count %u\n", apc_count);
+ }
+ 
++static int zigzag_state, zigzag_count[2], zigzag_stop;
++
++static DWORD CALLBACK zigzag_event0(void *arg)
++{
++    HANDLE *events = arg;
++
++    while (!zigzag_stop)
++    {
++        WaitForSingleObject(events[0], INFINITE);
++        ResetEvent(events[0]);
++        ok(zigzag_state == 0, "got wrong state %d\n", zigzag_state);
++        zigzag_state++;
++        SetEvent(events[1]);
++        zigzag_count[0]++;
++    }
++    trace("thread 0 got done\n");
++    return 0;
++}
++
++static DWORD CALLBACK zigzag_event1(void *arg)
++{
++    HANDLE *events = arg;
++
++    while (!zigzag_stop)
++    {
++        WaitForSingleObject(events[1], INFINITE);
++        ResetEvent(events[1]);
++        ok(zigzag_state == 1, "got wrong state %d\n", zigzag_state);
++        zigzag_state--;
++        SetEvent(events[0]);
++        zigzag_count[1]++;
++    }
++    trace("thread 1 got done\n");
++    return 0;
++}
++
++static void test_zigzag_event(void)
++{
++    /* The basic idea is to test SetEvent/Wait back and forth between two
++     * threads. Each thread clears their own event, sets some common data,
++     * signals the other's, then waits on their own. We make sure the common
++     * data is always in the right state. We also print performance data. */
++
++    HANDLE threads[2], events[2];
++    BOOL ret;
++
++    events[0] = CreateEventA(NULL, FALSE, FALSE, NULL);
++    events[1] = CreateEventA(NULL, FALSE, FALSE, NULL);
++
++    threads[0] = CreateThread(NULL, 0, zigzag_event0, events, 0, NULL);
++    threads[1] = CreateThread(NULL, 0, zigzag_event1, events, 0, NULL);
++
++    zigzag_state = 0;
++    zigzag_count[0] = zigzag_count[1] = 0;
++    zigzag_stop = 0;
++
++    trace("starting zigzag test (events)\n");
++    SetEvent(events[0]);
++    Sleep(2000);
++    zigzag_stop = 1;
++    ret = WaitForMultipleObjects(2, threads, FALSE, INFINITE);
++    trace("%d\n", ret);
++    ok(ret == 0 || ret == 1, "wait failed: %u\n", ret);
++
++    ok(zigzag_count[0] == zigzag_count[1] || zigzag_count[0] == zigzag_count[1] + 1,
++        "count did not match: %d != %d\n", zigzag_count[0], zigzag_count[1]);
++
++    /* signal the other thread to finish, if it didn't already
++     * (in theory they both would at the same time, but there's a slight race on teardown if we get
++     * thread 1 SetEvent -> thread 0 ResetEvent -> thread 0 Wait -> thread 1 exits */
++    zigzag_state = 1-ret;
++    SetEvent(events[1-ret]);
++    ret = WaitForSingleObject(threads[1-ret], 1000);
++    ok(!ret, "wait failed: %u\n", ret);
++
++    trace("count: %d\n", zigzag_count[0]);
++}
++
+ START_TEST(sync)
+ {
+     char **argv;
+@@ -2930,6 +3384,7 @@ START_TEST(sync)
+     pTryAcquireSRWLockShared = (void *)GetProcAddress(hdll, "TryAcquireSRWLockShared");
+     pNtAllocateVirtualMemory = (void *)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
+     pNtFreeVirtualMemory = (void *)GetProcAddress(hntdll, "NtFreeVirtualMemory");
++    pNtQuerySystemTime = (void *)GetProcAddress(hntdll, "NtQuerySystemTime");
+     pNtWaitForSingleObject = (void *)GetProcAddress(hntdll, "NtWaitForSingleObject");
+     pNtWaitForMultipleObjects = (void *)GetProcAddress(hntdll, "NtWaitForMultipleObjects");
+     pRtlInterlockedPushListSList = (void *)GetProcAddress(hntdll, "RtlInterlockedPushListSList");
+@@ -2974,5 +3429,6 @@ START_TEST(sync)
+     test_srwlock_example();
+     test_alertable_wait();
+     test_apc_deadlock();
++    test_zigzag_event();
+     test_crit_section();
+ }
+diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
+index f0dedfe3b14f..016af26f649b 100644
+--- a/dlls/kernelbase/file.c
++++ b/dlls/kernelbase/file.c
+@@ -37,6 +37,7 @@
+ #include "ddk/ntddk.h"
+ #include "ddk/ntddser.h"
+ #include "ioringapi.h"
++#include "ddk/ntifs.h"
+ 
+ #include "kernelbase.h"
+ #include "wine/exception.h"
+@@ -769,6 +770,8 @@ static UINT get_nt_file_options( DWORD attributes )
+         options |= FILE_SEQUENTIAL_ONLY;
+     if (attributes & FILE_FLAG_WRITE_THROUGH)
+         options |= FILE_WRITE_THROUGH;
++    if (attributes & FILE_FLAG_OPEN_REPARSE_POINT)
++        options |= FILE_OPEN_REPARSE_POINT;
+     return options;
+ }
+ 
+@@ -980,8 +983,106 @@ BOOL WINAPI CreateHardLinkW( LPCWSTR dest, LPCWSTR source, SECURITY_ATTRIBUTES *
+  */
+ BOOLEAN WINAPI /* DECLSPEC_HOTPATCH */ CreateSymbolicLinkW( LPCWSTR link, LPCWSTR target, DWORD flags )
+ {
+-    FIXME( "(%s %s %ld): stub\n", debugstr_w(link), debugstr_w(target), flags );
+-    return TRUE;
++    static INT struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
++    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
++    INT buffer_size, data_size, string_len, prefix_len;
++    WCHAR *subst_dest, *print_dest, *string;
++    REPARSE_DATA_BUFFER *buffer;
++    LPWSTR target_path = NULL;
++    BOOL is_relative, is_dir;
++    int target_path_len = 0;
++    UNICODE_STRING nt_name;
++    BOOLEAN bret = FALSE;
++    NTSTATUS status;
++    HANDLE hlink;
++    DWORD dwret;
++
++    TRACE( "(%s %s %ld): stub\n", debugstr_w(link), debugstr_w(target), flags );
++
++    is_relative = (RtlDetermineDosPathNameType_U( target ) == RELATIVE_PATH);
++    is_dir = (flags & SYMBOLIC_LINK_FLAG_DIRECTORY);
++    if (is_dir && !CreateDirectoryW( link, NULL ))
++        return FALSE;
++    hlink = CreateFileW( link, GENERIC_READ | GENERIC_WRITE, 0, 0,
++                         is_dir ? OPEN_EXISTING : CREATE_NEW,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0 );
++    if (hlink == INVALID_HANDLE_VALUE)
++        goto cleanup;
++    if (is_relative)
++    {
++        UNICODE_STRING nt_path;
++        int len;
++
++        status = RtlDosPathNameToNtPathName_U_WithStatus( link, &nt_path, NULL, NULL );
++        if (status != STATUS_SUCCESS)
++        {
++            SetLastError( RtlNtStatusToDosError(status) );
++            goto cleanup;
++        }
++        /* obtain the path of the link */
++        for (; nt_path.Length > 0; nt_path.Length -= sizeof(WCHAR))
++        {
++            WCHAR c = nt_path.Buffer[nt_path.Length/sizeof(WCHAR)];
++            if (c == '/' || c == '\\')
++            {
++                nt_path.Length += sizeof(WCHAR);
++                break;
++            }
++        }
++        /* append the target to the link path */
++        target_path_len = nt_path.Length / sizeof(WCHAR);
++        len = target_path_len + (lstrlenW( target ) + 1);
++        target_path = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, len*sizeof(WCHAR) );
++        lstrcpynW( target_path, nt_path.Buffer, target_path_len+1 );
++        target_path[target_path_len+1] = 0;
++        lstrcatW( target_path, target );
++        RtlFreeUnicodeString( &nt_path );
++    }
++    else
++        target_path = (LPWSTR)target;
++    status = RtlDosPathNameToNtPathName_U_WithStatus( target_path, &nt_name, NULL, NULL );
++    if (status != STATUS_SUCCESS)
++    {
++        SetLastError( RtlNtStatusToDosError(status) );
++        goto cleanup;
++    }
++    if (is_relative && _wcsnicmp( target_path, nt_name.Buffer, target_path_len ) != 0)
++    {
++        SetLastError( RtlNtStatusToDosError(status) );
++        goto cleanup;
++    }
++    prefix_len = is_relative ? 0 : strlen("\\??\\");
++    string = &nt_name.Buffer[target_path_len];
++    string_len = lstrlenW( &string[prefix_len] );
++    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
++    buffer_size = struct_size + data_size;
++    buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size );
++    buffer->ReparseTag = IO_REPARSE_TAG_SYMLINK;
++    buffer->ReparseDataLength = struct_size - header_size + data_size;
++    buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
++    buffer->SymbolicLinkReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
++    buffer->SymbolicLinkReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
++    buffer->SymbolicLinkReparseBuffer.Flags = is_relative ? SYMLINK_FLAG_RELATIVE : 0;
++    subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
++    print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
++    lstrcpyW( subst_dest, string );
++    lstrcpyW( print_dest, &string[prefix_len] );
++    RtlFreeUnicodeString( &nt_name );
++    bret = DeviceIoControl( hlink, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_size, NULL, 0,
++                            &dwret, 0 );
++    HeapFree( GetProcessHeap(), 0, buffer );
++
++cleanup:
++    CloseHandle( hlink );
++    if (!bret)
++    {
++        if (is_dir)
++            RemoveDirectoryW( link );
++        else
++            DeleteFileW( link );
++    }
++    if (is_relative) HeapFree( GetProcessHeap(), 0, target_path );
++    return bret;
+ }
+ 
+ 
+@@ -1025,7 +1126,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH DeleteFileW( LPCWSTR path )
+ 
+     status = NtCreateFile(&hFile, SYNCHRONIZE | DELETE, &attr, &io, NULL, 0,
+ 			  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+-			  FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE, NULL, 0);
++			  FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE | FILE_OPEN_REPARSE_POINT,
++			  NULL, 0);
+     if (status == STATUS_SUCCESS) status = NtClose(hFile);
+ 
+     RtlFreeUnicodeString( &nameW );
+@@ -1488,6 +1590,30 @@ BOOL WINAPI DECLSPEC_HOTPATCH FindNextFileW( HANDLE handle, WIN32_FIND_DATAW *da
+         memcpy( data->cFileName, dir_info->FileName, dir_info->FileNameLength );
+         data->cFileName[dir_info->FileNameLength/sizeof(WCHAR)] = 0;
+ 
++        /* get reparse tag */
++        if (dir_info->FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
++        {
++            INT path_len = info->path.Length + dir_info->FileNameLength + sizeof(WCHAR);
++            WCHAR *path = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, path_len );
++            FILE_ATTRIBUTE_TAG_INFORMATION taginfo;
++            IO_STATUS_BLOCK iosb;
++            NTSTATUS status;
++            HANDLE hlink;
++
++            if (!path) break;
++
++            lstrcpynW( path, info->path.Buffer, info->path.Length/sizeof(WCHAR) + 1 );
++            lstrcatW( path, data->cFileName );
++
++            hlink = CreateFileW( path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                                 FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0 );
++            HeapFree( GetProcessHeap(), 0, path );
++            status = NtQueryInformationFile( hlink, &iosb, &taginfo, sizeof(taginfo),
++                                             FileAttributeTagInformation );
++            if (status == STATUS_SUCCESS) data->dwReserved0 = taginfo.ReparseTag;
++            CloseHandle( hlink );
++        }
++
+         if (info->level != FindExInfoBasic)
+         {
+             memcpy( data->cAlternateFileName, dir_info->ShortName, dir_info->ShortNameLength );
+@@ -2572,7 +2698,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH MoveFileWithProgressW( const WCHAR *source, const
+ 
+     status = NtOpenFile( &source_handle, DELETE | SYNCHRONIZE, &attr, &io,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+-                         FILE_SYNCHRONOUS_IO_NONALERT );
++                         FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_REPARSE_POINT );
+     RtlFreeUnicodeString( &nt_name );
+     if (!set_ntstatus( status )) goto error;
+ 
+@@ -3632,7 +3758,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH RemoveDirectoryW( LPCWSTR path )
+     InitializeObjectAttributes( &attr, &nt_name, OBJ_CASE_INSENSITIVE, 0, NULL );
+     status = NtOpenFile( &handle, DELETE | SYNCHRONIZE, &attr, &io,
+                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+-                         FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
++                         FILE_OPEN_REPARSE_POINT | FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
+     RtlFreeUnicodeString( &nt_name );
+ 
+     if (!status)
+diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
+index 271f2c86d77b..044f8275be84 100644
+--- a/dlls/mountmgr.sys/device.c
++++ b/dlls/mountmgr.sys/device.c
+@@ -177,6 +177,36 @@ static void get_filesystem_serial( struct volume *volume )
+     volume->serial = strtoul( buffer, NULL, 16 );
+ }
+ 
++/* get the flags for the volume by looking at the type of underlying filesystem */
++static DWORD get_filesystem_flags( struct volume *volume )
++{
++    char fstypename[256];
++    ULONG size = sizeof(fstypename);
++    struct get_volume_filesystem_params params = { volume->device->unix_mount, fstypename, &size };
++
++    if (!volume->device->unix_mount) return 0;
++    if (MOUNTMGR_CALL( get_volume_filesystem, &params )) return 0;
++
++    if (!strcmp("apfs", fstypename) ||
++        !strcmp("nfs", fstypename) ||
++        !strcmp("cifs", fstypename) ||
++        !strcmp("ncpfs", fstypename) ||
++        !strcmp("tmpfs", fstypename) ||
++        !strcmp("cramfs", fstypename) ||
++        !strcmp("devfs", fstypename) ||
++        !strcmp("procfs", fstypename) ||
++        !strcmp("ext2", fstypename) ||
++        !strcmp("ext3", fstypename) ||
++        !strcmp("ext4", fstypename) ||
++        !strcmp("hfs", fstypename) ||
++        !strcmp("hpfs", fstypename) ||
++        !strcmp("ntfs", fstypename))
++    {
++        return FILE_SUPPORTS_REPARSE_POINTS;
++    }
++    return 0;
++}
++
+ 
+ /******************************************************************
+  *		VOLUME_FindCdRomDataBestVoldesc
+@@ -1734,7 +1764,8 @@ static NTSTATUS WINAPI harddisk_query_volume( DEVICE_OBJECT *device, IRP *irp )
+             break;
+         default:
+             fsname = L"NTFS";
+-            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
++            info->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS
++                                         | get_filesystem_flags( volume );
+             info->MaximumComponentNameLength = 255;
+             break;
+         }
+@@ -1902,7 +1933,7 @@ static BOOL create_port_device( DRIVER_OBJECT *driver, int n, const char *unix_p
+     UNICODE_STRING nt_name, symlink_name, default_name;
+     DEVICE_OBJECT *dev_obj;
+     NTSTATUS status;
+-    struct set_dosdev_symlink_params params = { dosdevices_path, unix_path };
++    struct set_dosdev_symlink_params params = { dosdevices_path, unix_path, driver == serial_driver };
+ 
+     /* create DOS device */
+     if (MOUNTMGR_CALL( set_dosdev_symlink, &params )) return FALSE;
+diff --git a/dlls/mountmgr.sys/unixlib.c b/dlls/mountmgr.sys/unixlib.c
+index 36f9f82dad8e..e92e937a5cb6 100644
+--- a/dlls/mountmgr.sys/unixlib.c
++++ b/dlls/mountmgr.sys/unixlib.c
+@@ -36,7 +36,23 @@
+ #ifdef HAVE_SYS_STATVFS_H
+ # include <sys/statvfs.h>
+ #endif
++#include <termios.h>
+ #include <unistd.h>
++#ifdef HAVE_SYS_STATFS_H
++# include <sys/statfs.h>
++#endif
++#ifdef HAVE_SYS_SYSCALL_H
++# include <sys/syscall.h>
++#endif
++#ifdef HAVE_SYS_VFS_H
++# include <sys/vfs.h>
++#endif
++#ifdef HAVE_SYS_PARAM_H
++#include <sys/param.h>
++#endif
++#ifdef HAVE_SYS_MOUNT_H
++#include <sys/mount.h>
++#endif
+ 
+ #include "unixlib.h"
+ #include "wine/debug.h"
+@@ -298,6 +314,27 @@ static NTSTATUS set_dosdev_symlink( void *args )
+     char *path;
+     NTSTATUS status = STATUS_SUCCESS;
+ 
++#ifdef linux
++    /* Serial port device files almost always exist on Linux even if the corresponding serial
++     * ports don't exist. Do a basic functionality check before advertising a serial port. */
++    if (params->serial)
++    {
++        struct termios tios;
++        int fd;
++
++        if ((fd = open( params->dest, O_RDONLY )) == -1)
++            return FALSE;
++
++        if (tcgetattr( fd, &tios ) == -1)
++        {
++            close( fd );
++            return FALSE;
++        }
++
++        close( fd );
++    }
++#endif
++
+     if (!(path = get_dosdevices_path( params->dev ))) return STATUS_NO_MEMORY;
+ 
+     if (params->dest && params->dest[0])
+@@ -435,6 +472,87 @@ static NTSTATUS read_volume_file( void *args )
+     return STATUS_SUCCESS;
+ }
+ 
++static NTSTATUS get_volume_filesystem( void *args )
++{
++#if defined(__NR_renameat2) || defined(RENAME_SWAP)
++    const struct get_volume_filesystem_params *params = args;
++#if defined(HAVE_FSTATFS)
++    struct statfs stfs;
++#elif defined(HAVE_FSTATVFS)
++    struct statvfs stfs;
++#endif
++    const char *fstypename = "unknown";
++    int fd = -1;
++
++    if (params->volume[0] != '/')
++    {
++        char *path = get_dosdevices_path( params->volume );
++        if (path) fd = open( path, O_RDONLY );
++        free( path );
++    }
++    else fd = open( params->volume, O_RDONLY );
++    if (fd == -1) return STATUS_NO_SUCH_FILE;
++
++#if defined(HAVE_FSTATFS)
++    if (fstatfs(fd, &stfs))
++        return STATUS_NO_SUCH_FILE;
++#elif defined(HAVE_FSTATVFS)
++    if (fstatvfs(fd, &stfs))
++        return STATUS_NO_SUCH_FILE;
++#endif
++    close( fd );
++#if defined(HAVE_FSTATFS) && defined(linux)
++    switch (stfs.f_type)
++    {
++    case 0x6969:      /* nfs */
++        fstypename = "nfs";
++        break;
++    case 0xff534d42:  /* cifs */
++        fstypename = "cifs";
++        break;
++    case 0x564c:      /* ncpfs */
++        fstypename = "ncpfs";
++        break;
++    case 0x01021994:  /* tmpfs */
++        fstypename = "tmpfs";
++        break;
++    case 0x28cd3d45:  /* cramfs */
++        fstypename = "cramfs";
++        break;
++    case 0x1373:      /* devfs */
++        fstypename = "devfs";
++        break;
++    case 0x9fa0:      /* procfs */
++        fstypename = "procfs";
++        break;
++    case 0xef51:      /* old ext2 */
++        fstypename = "ext2";
++        break;
++    case 0xef53:      /* ext2/3/4 */
++        fstypename = "ext2";
++        break;
++    case 0x4244:      /* hfs */
++        fstypename = "hfs";
++        break;
++    case 0xf995e849:  /* hpfs */
++        fstypename = "hpfs";
++        break;
++    case 0x5346544e:  /* ntfs */
++        fstypename = "ntfs";
++        break;
++    default:
++        break;
++    }
++#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__OpenBSD__) || defined(__DragonFly__) || defined(__APPLE__) || defined(__NetBSD__)
++    fstypename = stfs.f_fstypename;
++#endif
++    lstrcpynA( params->fstypename, fstypename, *params->size );
++    return STATUS_SUCCESS;
++#else
++    return STATUS_NOT_IMPLEMENTED;
++#endif
++}
++
+ static NTSTATUS match_unixdev( void *args )
+ {
+     const struct match_unixdev_params *params = args;
+@@ -577,6 +695,7 @@ const unixlib_entry_t __wine_unix_call_funcs[] =
+     write_credential,
+     delete_credential,
+     enumerate_credentials,
++    get_volume_filesystem,
+ };
+ 
+ C_ASSERT( ARRAYSIZE(__wine_unix_call_funcs) == unix_funcs_count );
+diff --git a/dlls/mountmgr.sys/unixlib.h b/dlls/mountmgr.sys/unixlib.h
+index b40b323ac80f..436caf188a88 100644
+--- a/dlls/mountmgr.sys/unixlib.h
++++ b/dlls/mountmgr.sys/unixlib.h
+@@ -91,6 +91,7 @@ struct set_dosdev_symlink_params
+ {
+     const char *dev;
+     const char *dest;
++    BOOL serial;
+ };
+ 
+ struct get_volume_dos_devices_params
+@@ -107,6 +108,13 @@ struct read_volume_file_params
+     ULONG *size;
+ };
+ 
++struct get_volume_filesystem_params
++{
++    const char *volume;
++    void *fstypename;
++    ULONG *size;
++};
++
+ struct match_unixdev_params
+ {
+     const char *device;
+@@ -173,6 +181,7 @@ enum mountmgr_funcs
+     unix_write_credential,
+     unix_delete_credential,
+     unix_enumerate_credentials,
++    unix_get_volume_filesystem,
+     unix_funcs_count
+ };
+ 
+diff --git a/dlls/msvcp120/tests/msvcp120.c b/dlls/msvcp120/tests/msvcp120.c
+index 26bbf5b65357..82e43a38d59d 100644
+--- a/dlls/msvcp120/tests/msvcp120.c
++++ b/dlls/msvcp120/tests/msvcp120.c
+@@ -1646,15 +1646,14 @@ static void test_tr2_sys__Stat(void)
+         char const *path;
+         enum file_type ret;
+         int err_code;
+-        int is_todo;
+     } tests[] = {
+-        { NULL, status_unknown, ERROR_INVALID_PARAMETER, FALSE },
+-        { "tr2_test_dir",    directory_file, ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir\\f1",  regular_file, ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir\\not_exist_file  ", file_not_found, ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir\\??invalid_name>>", file_not_found, ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir\\f1_link" ,   regular_file, ERROR_SUCCESS, TRUE },
+-        { "tr2_test_dir\\dir_link", directory_file, ERROR_SUCCESS, TRUE },
++        { NULL, status_unknown, ERROR_INVALID_PARAMETER },
++        { "tr2_test_dir",    directory_file, ERROR_SUCCESS },
++        { "tr2_test_dir\\f1",  regular_file, ERROR_SUCCESS },
++        { "tr2_test_dir\\not_exist_file  ", file_not_found, ERROR_SUCCESS },
++        { "tr2_test_dir\\??invalid_name>>", file_not_found, ERROR_SUCCESS },
++        { "tr2_test_dir\\f1_link" ,   regular_file, ERROR_SUCCESS },
++        { "tr2_test_dir\\dir_link", directory_file, ERROR_SUCCESS },
+     };
+ 
+     CreateDirectoryA("tr2_test_dir", NULL);
+@@ -1697,16 +1696,14 @@ static void test_tr2_sys__Stat(void)
+     for(i=0; i<ARRAY_SIZE(tests); i++) {
+         err_code = 0xdeadbeef;
+         val = p_tr2_sys__Stat(tests[i].path, &err_code);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(tests[i].ret == val, "tr2_sys__Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
++        ok(tests[i].ret == val, "tr2_sys__Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+         ok(tests[i].err_code == err_code, "tr2_sys__Stat(): test %d err_code expect: %d, got %d\n",
+                 i+1, tests[i].err_code, err_code);
+ 
+         /* test tr2_sys__Lstat */
+         err_code = 0xdeadbeef;
+         val = p_tr2_sys__Lstat(tests[i].path, &err_code);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(tests[i].ret == val, "tr2_sys__Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
++        ok(tests[i].ret == val, "tr2_sys__Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+         ok(tests[i].err_code == err_code, "tr2_sys__Lstat(): test %d err_code expect: %d, got %d\n",
+                 i+1, tests[i].err_code, err_code);
+     }
+@@ -1721,8 +1718,8 @@ static void test_tr2_sys__Stat(void)
+     ok(ERROR_SUCCESS == err_code, "tr2_sys__Lstat_wchar(): err_code expect ERROR_SUCCESS, got %d\n", err_code);
+ 
+     if(ret) {
+-        todo_wine ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
+-        todo_wine ok(RemoveDirectoryA("tr2_test_dir/dir_link"), "expect tr2_test_dir/dir_link to exist\n");
++        ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
++        ok(RemoveDirectoryA("tr2_test_dir/dir_link"), "expect tr2_test_dir/dir_link to exist\n");
+     }
+     ok(DeleteFileA("tr2_test_dir/f1"), "expect tr2_test_dir/f1 to exist\n");
+     ok(RemoveDirectoryA("tr2_test_dir"), "expect tr2_test_dir to exist\n");
+@@ -1951,16 +1948,15 @@ static void test_tr2_sys__Symlink(void)
+         char const *existing_path;
+         char const *new_path;
+         int last_error;
+-        MSVCP_bool is_todo;
+     } tests[] = {
+-        { "f1", "f1_link", ERROR_SUCCESS, FALSE },
+-        { "f1", "tr2_test_dir\\f1_link", ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir\\f1_link", "tr2_test_dir\\f1_link_link", ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir", "dir_link", ERROR_SUCCESS, FALSE },
+-        { NULL, "NULL_link", ERROR_INVALID_PARAMETER, FALSE },
+-        { "f1", NULL, ERROR_INVALID_PARAMETER, FALSE },
+-        { "not_exist",  "not_exist_link", ERROR_SUCCESS, FALSE },
+-        { "f1", "not_exist_dir\\f1_link", ERROR_PATH_NOT_FOUND, TRUE }
++        { "f1", "f1_link", ERROR_SUCCESS },
++        { "f1", "tr2_test_dir\\f1_link", ERROR_SUCCESS },
++        { "tr2_test_dir\\f1_link", "tr2_test_dir\\f1_link_link", ERROR_SUCCESS },
++        { "tr2_test_dir", "dir_link", ERROR_SUCCESS },
++        { NULL, "NULL_link", ERROR_INVALID_PARAMETER },
++        { "f1", NULL, ERROR_INVALID_PARAMETER },
++        { "not_exist",  "not_exist_link", ERROR_SUCCESS },
++        { "f1", "not_exist_dir\\f1_link", ERROR_PATH_NOT_FOUND }
+     };
+ 
+     ret = p_tr2_sys__Make_dir("tr2_test_dir");
+@@ -1985,18 +1981,17 @@ static void test_tr2_sys__Symlink(void)
+         }
+ 
+         ok(errno == 0xdeadbeef, "tr2_sys__Symlink(): test %d errno expect 0xdeadbeef, got %d\n", i+1, errno);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(ret == tests[i].last_error, "tr2_sys__Symlink(): test %d expect: %d, got %d\n", i+1, tests[i].last_error, ret);
++        ok(ret == tests[i].last_error, "tr2_sys__Symlink(): test %d expect: %d, got %d\n", i+1, tests[i].last_error, ret);
+         if(ret == ERROR_SUCCESS)
+             ok(p_tr2_sys__File_size(tests[i].new_path) == 0, "tr2_sys__Symlink(): expect 0, got %s\n", wine_dbgstr_longlong(p_tr2_sys__File_size(tests[i].new_path)));
+     }
+ 
+     ok(DeleteFileA("f1"), "expect f1 to exist\n");
+-    todo_wine ok(DeleteFileA("f1_link"), "expect f1_link to exist\n");
+-    todo_wine ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
+-    todo_wine ok(DeleteFileA("tr2_test_dir/f1_link_link"), "expect tr2_test_dir/f1_link_link to exist\n");
+-    todo_wine ok(DeleteFileA("not_exist_link"), "expect not_exist_link to exist\n");
+-    todo_wine ok(DeleteFileA("dir_link"), "expect dir_link to exist\n");
++    ok(DeleteFileA("f1_link"), "expect f1_link to exist\n");
++    ok(DeleteFileA("tr2_test_dir/f1_link"), "expect tr2_test_dir/f1_link to exist\n");
++    ok(DeleteFileA("tr2_test_dir/f1_link_link"), "expect tr2_test_dir/f1_link_link to exist\n");
++    ok(DeleteFileA("not_exist_link"), "expect not_exist_link to exist\n");
++    ok(DeleteFileA("dir_link"), "expect dir_link to exist\n");
+     ret = p_tr2_sys__Remove_dir("tr2_test_dir");
+     ok(ret == 1, "tr2_sys__Remove_dir(): expect 1 got %d\n", ret);
+ }
+@@ -2010,15 +2005,14 @@ static void test_tr2_sys__Unlink(void)
+     struct {
+         char const *path;
+         int last_error;
+-        MSVCP_bool is_todo;
+     } tests[] = {
+-        { "tr2_test_dir\\f1_symlink", ERROR_SUCCESS, TRUE },
+-        { "tr2_test_dir\\f1_link", ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir\\f1", ERROR_SUCCESS, FALSE },
+-        { "tr2_test_dir", ERROR_ACCESS_DENIED, FALSE },
+-        { "not_exist", ERROR_FILE_NOT_FOUND, FALSE },
+-        { "not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND, FALSE },
+-        { NULL, ERROR_PATH_NOT_FOUND, FALSE }
++        { "tr2_test_dir\\f1_symlink", ERROR_SUCCESS },
++        { "tr2_test_dir\\f1_link", ERROR_SUCCESS },
++        { "tr2_test_dir\\f1", ERROR_SUCCESS },
++        { "tr2_test_dir", ERROR_ACCESS_DENIED },
++        { "not_exist", ERROR_FILE_NOT_FOUND },
++        { "not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND },
++        { NULL, ERROR_PATH_NOT_FOUND }
+     };
+ 
+     GetCurrentDirectoryA(MAX_PATH, current_path);
+@@ -2047,9 +2041,8 @@ static void test_tr2_sys__Unlink(void)
+     for(i=0; i<ARRAY_SIZE(tests); i++) {
+         errno = 0xdeadbeef;
+         ret = p_tr2_sys__Unlink(tests[i].path);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(ret == tests[i].last_error, "tr2_sys__Unlink(): test %d expect: %d, got %d\n",
+-                    i+1, tests[i].last_error, ret);
++        ok(ret == tests[i].last_error, "tr2_sys__Unlink(): test %d expect: %d, got %d\n",
++           i+1, tests[i].last_error, ret);
+         ok(errno == 0xdeadbeef, "tr2_sys__Unlink(): test %d errno expect: 0xdeadbeef, got %d\n", i+1, ret);
+     }
+ 
+diff --git a/dlls/msvcp140/tests/msvcp140.c b/dlls/msvcp140/tests/msvcp140.c
+index d2bcd192f459..88ea61435df2 100644
+--- a/dlls/msvcp140/tests/msvcp140.c
++++ b/dlls/msvcp140/tests/msvcp140.c
+@@ -889,16 +889,15 @@ static void test_Stat(void)
+         WCHAR const *path;
+         enum file_type ret;
+         int perms;
+-        int is_todo;
+     } tests[] = {
+-        { NULL, file_not_found, 0xdeadbeef, FALSE },
+-        { L"wine_test_dir", directory_file, 0777, FALSE },
+-        { L"wine_test_dir/f1", regular_file, 0777, FALSE },
+-        { L"wine_test_dir/f2", regular_file, 0555, FALSE },
+-        { L"wine_test_dir/ne", file_not_found, 0xdeadbeef, FALSE },
+-        { L"wine_test_dir\\??invalid_name>>", file_not_found, 0xdeadbeef, FALSE },
+-        { L"wine_test_dir\\f1_link", regular_file, 0777, TRUE },
+-        { L"wine_test_dir\\dir_link", directory_file, 0777, TRUE },
++        { NULL, file_not_found, 0xdeadbeef },
++        { L"wine_test_dir", directory_file, 0777 },
++        { L"wine_test_dir/f1", regular_file, 0777 },
++        { L"wine_test_dir/f2", regular_file, 0555 },
++        { L"wine_test_dir/ne", file_not_found, 0xdeadbeef },
++        { L"wine_test_dir\\??invalid_name>>", file_not_found, 0xdeadbeef },
++        { L"wine_test_dir\\f1_link", regular_file, 0777 },
++        { L"wine_test_dir\\dir_link", directory_file, 0777 },
+     };
+ 
+     GetCurrentDirectoryW(MAX_PATH, origin_path);
+@@ -956,26 +955,20 @@ static void test_Stat(void)
+     for(i=0; i<ARRAY_SIZE(tests); i++) {
+         perms = 0xdeadbeef;
+         val = p_Stat(tests[i].path, &perms);
+-        todo_wine_if(tests[i].is_todo) {
+-            ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+-            ok(tests[i].perms == perms, "_Stat(): test %d perms expect: 0%o, got 0%o\n",
+-                    i+1, tests[i].perms, perms);
+-        }
++        ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
++        ok(tests[i].perms == perms, "_Stat(): test %d perms expect: 0%o, got 0%o\n",
++                i+1, tests[i].perms, perms);
+         val = p_Stat(tests[i].path, NULL);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
++        ok(tests[i].ret == val, "_Stat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+ 
+         /* test _Lstat */
+         perms = 0xdeadbeef;
+         val = p_Lstat(tests[i].path, &perms);
+-        todo_wine_if(tests[i].is_todo) {
+-            ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+-            ok(tests[i].perms == perms, "_Lstat(): test %d perms expect: 0%o, got 0%o\n",
+-                    i+1, tests[i].perms, perms);
+-        }
++        ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
++        ok(tests[i].perms == perms, "_Lstat(): test %d perms expect: 0%o, got 0%o\n",
++                i+1, tests[i].perms, perms);
+         val = p_Lstat(tests[i].path, NULL);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
++        ok(tests[i].ret == val, "_Lstat(): test %d expect: %d, got %d\n", i+1, tests[i].ret, val);
+     }
+ 
+     GetSystemDirectoryW(sys_path, MAX_PATH);
+@@ -987,9 +980,9 @@ static void test_Stat(void)
+     ok(perms == expected_perms, "_Stat(): perms expect: 0%o, got 0%o\n", expected_perms, perms);
+ 
+     if(ret) {
+-        todo_wine ok(DeleteFileW(L"wine_test_dir\\f1_link"),
++        ok(DeleteFileW(L"wine_test_dir\\f1_link"),
+                 "expect wine_test_dir/f1_link to exist\n");
+-        todo_wine ok(RemoveDirectoryW(L"wine_test_dir\\dir_link"),
++        ok(RemoveDirectoryW(L"wine_test_dir\\dir_link"),
+                 "expect wine_test_dir/dir_link to exist\n");
+     }
+     ok(DeleteFileW(L"wine_test_dir/f1"), "expect wine_test_dir/f1 to exist\n");
+@@ -1108,15 +1101,14 @@ static void test_Unlink(void)
+     struct {
+         WCHAR const *path;
+         int last_error;
+-        MSVCP_bool is_todo;
+     } tests[] = {
+-        { L"wine_test_dir\\f1_symlink", ERROR_SUCCESS, TRUE },
+-        { L"wine_test_dir\\f1_link", ERROR_SUCCESS, FALSE },
+-        { L"wine_test_dir\\f1", ERROR_SUCCESS, FALSE },
+-        { L"wine_test_dir", ERROR_ACCESS_DENIED, FALSE },
+-        { L"not_exist", ERROR_FILE_NOT_FOUND, FALSE },
+-        { L"not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND, FALSE },
+-        { NULL, ERROR_PATH_NOT_FOUND, FALSE }
++        { L"wine_test_dir\\f1_symlink", ERROR_SUCCESS },
++        { L"wine_test_dir\\f1_link", ERROR_SUCCESS },
++        { L"wine_test_dir\\f1", ERROR_SUCCESS },
++        { L"wine_test_dir", ERROR_ACCESS_DENIED },
++        { L"not_exist", ERROR_FILE_NOT_FOUND },
++        { L"not_exist_dir\\not_exist_file", ERROR_PATH_NOT_FOUND },
++        { NULL, ERROR_PATH_NOT_FOUND }
+     };
+ 
+     GetCurrentDirectoryW(MAX_PATH, current_path);
+@@ -1145,9 +1137,8 @@ static void test_Unlink(void)
+     for(i=0; i<ARRAY_SIZE(tests); i++) {
+         errno = 0xdeadbeef;
+         ret = p_Unlink(tests[i].path);
+-        todo_wine_if(tests[i].is_todo)
+-            ok(ret == tests[i].last_error, "_Unlink(): test %d expect: %d, got %d\n",
+-                    i+1, tests[i].last_error, ret);
++        ok(ret == tests[i].last_error, "_Unlink(): test %d expect: %d, got %d\n",
++           i+1, tests[i].last_error, ret);
+         ok(errno == 0xdeadbeef, "_Unlink(): test %d errno expect: 0xdeadbeef, got %d\n", i+1, ret);
+     }
+ 
+diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
+index 37bd6c86e31f..78b3fdf94aa9 100644
+--- a/dlls/ntdll/Makefile.in
++++ b/dlls/ntdll/Makefile.in
+@@ -4,7 +4,7 @@ UNIXLIB   = ntdll.so
+ IMPORTLIB = ntdll
+ IMPORTS   = $(MUSL_PE_LIBS) winecrt0
+ UNIX_CFLAGS  = $(UNWIND_CFLAGS)
+-UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS)
++UNIX_LIBS    = $(IOKIT_LIBS) $(COREFOUNDATION_LIBS) $(CORESERVICES_LIBS) $(RT_LIBS) $(PTHREAD_LIBS) $(UNWIND_LIBS) $(I386_LIBS) $(PROCSTAT_LIBS) -lm
+ 
+ EXTRADLLFLAGS = -nodefaultlibs
+ i386_EXTRADLLFLAGS = -Wl,--image-base,0x7bc00000
+@@ -48,6 +48,7 @@ SOURCES = \
+ 	unix/cdrom.c \
+ 	unix/debug.c \
+ 	unix/env.c \
++	unix/esync.c \
+ 	unix/file.c \
+ 	unix/loader.c \
+ 	unix/loadorder.c \
+diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
+index 02bdf67796db..633f3dec76f8 100644
+--- a/dlls/ntdll/tests/file.c
++++ b/dlls/ntdll/tests/file.c
+@@ -38,6 +38,7 @@
+ #include "winuser.h"
+ #include "winioctl.h"
+ #include "winnls.h"
++#include "ddk/ntifs.h"
+ 
+ #ifndef IO_COMPLETION_ALL_ACCESS
+ #define IO_COMPLETION_ALL_ACCESS 0x001F0003
+@@ -5952,32 +5953,557 @@ static void test_mailslot_name(void)
+     CloseHandle( device );
+ }
+ 
++static INT build_reparse_buffer(const WCHAR *filename, ULONG tag, ULONG flags,
++                                REPARSE_DATA_BUFFER **pbuffer)
++{
++    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
++    INT buffer_size, struct_size, data_size, string_len, prefix_len;
++    WCHAR *subst_dest, *print_dest;
++    REPARSE_DATA_BUFFER *buffer;
++
++    switch(tag)
++    {
++    case IO_REPARSE_TAG_MOUNT_POINT:
++        struct_size = offsetof(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[0]);
++        break;
++    case IO_REPARSE_TAG_SYMLINK:
++        struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
++        break;
++    default:
++        return 0;
++    }
++    prefix_len = (flags == SYMLINK_FLAG_RELATIVE) ? 0 : strlen("\\??\\");
++    string_len = lstrlenW(&filename[prefix_len]);
++    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
++    buffer_size = struct_size + data_size;
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size);
++    buffer->ReparseTag = tag;
++    buffer->ReparseDataLength = struct_size - header_size + data_size;
++    switch(tag)
++    {
++    case IO_REPARSE_TAG_MOUNT_POINT:
++        buffer->MountPointReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
++        buffer->MountPointReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
++        buffer->MountPointReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
++        subst_dest = &buffer->MountPointReparseBuffer.PathBuffer[0];
++        print_dest = &buffer->MountPointReparseBuffer.PathBuffer[prefix_len + string_len + 1];
++        break;
++    case IO_REPARSE_TAG_SYMLINK:
++        buffer->SymbolicLinkReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
++        buffer->SymbolicLinkReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
++        buffer->SymbolicLinkReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
++        buffer->SymbolicLinkReparseBuffer.Flags = flags;
++        subst_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[0];
++        print_dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[prefix_len + string_len + 1];
++        break;
++    default:
++        return 0;
++    }
++    lstrcpyW(subst_dest, filename);
++    lstrcpyW(print_dest, &filename[prefix_len]);
++    *pbuffer = buffer;
++    return buffer_size;
++}
++
+ static void test_reparse_points(void)
+ {
+-    OBJECT_ATTRIBUTES attr;
+-    HANDLE handle;
+-    IO_STATUS_BLOCK io;
+-    NTSTATUS status;
++    WCHAR path[MAX_PATH], reparse_path[MAX_PATH], target_path[MAX_PATH], volnameW[MAX_PATH], new_path[MAX_PATH], thru_path[MAX_PATH];
++    static const WCHAR new_reparseW[] = {'\\','n','e','w','_','r','e','p','a','r','s','e',0};
++    static const WCHAR reparseW[] = {'\\','r','e','p','a','r','s','e',0};
++    static const WCHAR targetW[] = {'\\','t','a','r','g','e','t',0};
++    static const WCHAR parentW[] = {'\\','.','.','\\',0};
++    INT buffer_len, string_len, path_len, total_len;
++    FILE_BASIC_INFORMATION old_attrib, new_attrib;
++    static const WCHAR fooW[] = {'f','o','o',0};
++    static WCHAR volW[] = {'c',':','\\',0};
++    const WCHAR *rel_target = &targetW[1];
++    WCHAR *dest, *long_path, *abs_target;
++    REPARSE_GUID_DATA_BUFFER guid_buffer;
++    static const WCHAR dotW[] = {'.',0};
++    FILE_ATTRIBUTE_TAG_INFORMATION info;
++    REPARSE_DATA_BUFFER *buffer = NULL;
++    DWORD dwret, dwLen, dwFlags, err;
++    WIN32_FILE_ATTRIBUTE_DATA fad;
++    char unix_target[] = "target";
++    UCHAR *unix_dest;
++    WCHAR buf[] = {0,0,0,0};
++    HANDLE handle, token;
++    IO_STATUS_BLOCK iosb;
+     UNICODE_STRING nameW;
+-    unsigned char reparse_data[1];
++    TOKEN_PRIVILEGES tp;
++    NTSTATUS status;
++    LUID luid;
++    BOOL bret;
+ 
+-    pRtlInitUnicodeString( &nameW, L"\\??\\C:\\" );
+-    InitializeObjectAttributes( &attr, &nameW, 0, NULL, NULL );
++    /* Create a temporary folder for the junction point tests */
++    GetTempFileNameW(dotW, fooW, 0, path);
++    DeleteFileW(path);
++    if (!CreateDirectoryW(path, NULL))
++    {
++        win_skip("Unable to create a temporary junction point directory.\n");
++        return;
++    }
+ 
+-    status = pNtOpenFile( &handle, READ_CONTROL, &attr, &io, 0, 0 );
+-    ok( !status, "open %s failed %#lx\n", wine_dbgstr_w(nameW.Buffer), status );
++    /* Check that the volume this folder is located on supports junction points */
++    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
++    volW[0] = nameW.Buffer[4];
++    pRtlFreeUnicodeString( &nameW );
++    if (!GetVolumeNameForVolumeMountPointW(volW, volnameW, MAX_PATH))
++    {
++        win_skip("Failed to obtain volume name for current volume.\n");
++        return;
++    }
++    GetVolumeInformationW(volnameW, 0, 0, 0, &dwLen, &dwFlags, 0, 0);
++    if (!(dwFlags & FILE_SUPPORTS_REPARSE_POINTS))
++    {
++        skip("File system does not support reparse points.\n");
++        RemoveDirectoryW(path);
++        return;
++    }
+ 
+-    status = pNtFsControlFile( handle, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT, NULL, 0, NULL, 0 );
+-    ok( status == STATUS_INVALID_USER_BUFFER, "expected %#lx, got %#lx\n", STATUS_INVALID_USER_BUFFER, status );
++    /* Create the folder to be replaced by a junction point */
++    lstrcpyW(reparse_path, path);
++    lstrcatW(reparse_path, reparseW);
++    bret = CreateDirectoryW(reparse_path, NULL);
++    ok(bret, "Failed to create junction point directory.\n");
+ 
+-    status = pNtFsControlFile( handle, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse_data, 0 );
+-    ok( status == STATUS_INVALID_USER_BUFFER, "expected %#lx, got %#lx\n", STATUS_INVALID_USER_BUFFER, status );
++    /* Create a destination folder for the junction point to target */
++    lstrcpyW(target_path, path);
++    for (int i=0; i<1; i++)
++    {
++        lstrcatW(target_path, parentW);
++        lstrcatW(target_path, path);
++    }
++    lstrcatW(target_path, targetW);
++    bret = CreateDirectoryW(target_path, NULL);
++    ok(bret, "Failed to create junction point target directory.\n");
++    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
+ 
+-    /* a volume cannot be a reparse point by definition */
+-    status = pNtFsControlFile( handle, NULL, NULL, NULL, &io, FSCTL_GET_REPARSE_POINT, NULL, 0, reparse_data, 1 );
+-    ok( status == STATUS_NOT_A_REPARSE_POINT, "expected %#lx, got %#lx\n", STATUS_NOT_A_REPARSE_POINT, status );
++    /* construct a too long pathname (resulting reparse buffer over 16 kiB limit) */
++    long_path = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, 32767);
++    lstrcpyW(long_path, nameW.Buffer);
++    for (int i=0; i<250; i++)
++    {
++        lstrcatW(long_path, parentW);
++        lstrcatW(long_path, path);
++    }
++    lstrcatW(long_path, targetW);
+ 
+-    CloseHandle( handle );
++    /* Create the junction point */
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open junction point directory handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    buffer_len = build_reparse_buffer(long_path, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(!bret && GetLastError()==ERROR_INVALID_REPARSE_DATA, "Unexpected error (0x%lx)\n", GetLastError());
++    HeapFree(GetProcessHeap(), 0, buffer);
++    CloseHandle(handle);
++
++    /* construct a long pathname to demonstrate correct behavior with very large reparse points */
++    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
++    lstrcpyW(long_path, nameW.Buffer);
++    for (int i=0; i<200; i++)
++    {
++        lstrcatW(long_path, parentW);
++        lstrcatW(long_path, path);
++    }
++    lstrcatW(long_path, targetW);
++
++    /* use a sane (not obscenely long) target for the rest of testing */
++    pRtlFreeUnicodeString(&nameW);
++    pRtlDosPathNameToNtPathName_U(target_path, &nameW, NULL, NULL);
++    abs_target = nameW.Buffer;
++
++    /* Create the junction point */
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open junction point directory handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%lx).\n", dwret);
++    buffer_len = build_reparse_buffer(long_path, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create junction point! (0x%lx)\n", GetLastError());
++
++    /* Check the file attributes of the junction point */
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret != (DWORD)~0, "Reparse point doesn't exist (attributes: 0x%lx)!\n", dwret);
++    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a reparse point! (attributes: 0x%lx)\n", dwret);
++
++    /* Read back the junction point */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    buffer_len = sizeof(*buffer) + 2*32767;
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    ok(bret, "Failed to read junction point! (last error=0x%lx)\n", GetLastError());
++    string_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
++    dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
++    ok((memcmp(dest, long_path, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
++                                                   wine_dbgstr_w(dest), wine_dbgstr_w(long_path));
++    path_len = buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR);
++    path_len += buffer->MountPointReparseBuffer.PrintNameLength/sizeof(WCHAR);
++    total_len = FIELD_OFFSET(typeof(*buffer), MountPointReparseBuffer.PathBuffer[path_len+1])
++                - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
++    ok(buffer->ReparseDataLength == total_len, "ReparseDataLength has unexpected value (%d != %d)\n",
++                                               buffer->ReparseDataLength, total_len);
++
++    /* Delete the junction point */
++    memset(&old_attrib, 0x00, sizeof(old_attrib));
++    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
++    dwret = NtSetInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to set junction point folder's attributes (0x%lx).\n", dwret);
++    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
++    guid_buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
++    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
++                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to delete junction point! (0x%lx)\n", GetLastError());
++    memset(&new_attrib, 0x00, sizeof(new_attrib));
++    dwret = NtQueryInformationFile(handle, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%lx).\n", dwret);
++    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
++       "Junction point folder's access time does not match.\n");
++    CloseHandle(handle);
++
++    /* Check deleting a junction point as if it were a directory */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    buffer_len = build_reparse_buffer(abs_target, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create junction point! (0x%lx)\n", GetLastError());
++    CloseHandle(handle);
++    bret = RemoveDirectoryW(reparse_path);
++    ok(bret, "Failed to delete junction point as directory!\n");
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret == (DWORD)~0, "Junction point still exists (attributes: 0x%lx)!\n", dwret);
++
++    /* Check deleting a junction point as if it were a file */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    bret = CreateDirectoryW(reparse_path, NULL);
++    ok(bret, "Failed to create junction point target directory.\n");
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    buffer_len = build_reparse_buffer(abs_target, IO_REPARSE_TAG_MOUNT_POINT, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create junction point! (0x%lx)\n", GetLastError());
++    CloseHandle(handle);
++    bret = DeleteFileW(reparse_path);
++    ok(!bret, "Succeeded in deleting junction point as file!\n");
++    err = GetLastError();
++    ok(err == ERROR_ACCESS_DENIED, "Expected last error 0x%x for DeleteFile on junction point (actually 0x%lx)!\n",
++                                   ERROR_ACCESS_DENIED, err);
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%lx)!\n", dwret);
++    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: 0x%lx)\n", dwret);
++
++    /* Test deleting a junction point's target */
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret == 0x410 || broken(dwret == 0x430) /* win2k */ || broken(dwret == 0xc10) /* vista */,
++       "Unexpected junction point attributes (0x%lx != 0x410)!\n", dwret);
++    bret = RemoveDirectoryW(target_path);
++    ok(bret, "Failed to delete junction point target!\n");
++    bret = CreateDirectoryW(target_path, NULL);
++    ok(bret, "Failed to create junction point target directory.\n");
++
++    /* Establish permissions for symlink creation */
++    bret = OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &token);
++    ok(bret, "OpenProcessToken failed: %lx\n", GetLastError());
++    bret = LookupPrivilegeValueA(NULL, "SeCreateSymbolicLinkPrivilege", &luid);
++    todo_wine ok(bret || broken(!bret && GetLastError() == ERROR_NO_SUCH_PRIVILEGE) /* winxp */,
++                 "LookupPrivilegeValue failed: %lx\n", GetLastError());
++    if (bret)
++    {
++        tp.PrivilegeCount = 1;
++        tp.Privileges[0].Luid = luid;
++        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
++        bret = AdjustTokenPrivileges(token, FALSE, &tp, 0, NULL, NULL);
++        ok(bret, "AdjustTokenPrivileges failed: %lx\n", GetLastError());
++        if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)
++        {
++            win_skip("Insufficient permissions to perform symlink tests.\n");
++            goto cleanup;
++        }
++    }
++
++    /* Delete the junction point directory and create a blank slate for symlink tests */
++    bret = RemoveDirectoryW(reparse_path);
++    ok(bret, "Failed to delete junction point!\n");
++    bret = RemoveDirectoryW(target_path);
++    ok(bret, "Failed to delete junction point target!\n");
++    handle = CreateFileW(target_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW, 0, 0);
++    ok(handle != INVALID_HANDLE_VALUE, "Failed to create symlink target file.\n");
++    bret = WriteFile(handle, fooW, sizeof(fooW), &dwLen, NULL);
++    ok(bret, "Failed to write data to the symlink target file.\n");
++    ok(GetFileSize(handle, NULL) == sizeof(fooW), "target size is incorrect (%ld vs %d)\n",
++       GetFileSize(handle, NULL), (int)sizeof(fooW));
++    CloseHandle(handle);
++
++    /* Create the file symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    ok(handle != INVALID_HANDLE_VALUE, "Failed to create symlink file.\n");
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink file's attributes (0x%lx).\n", dwret);
++    buffer_len = build_reparse_buffer(nameW.Buffer, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
++    CloseHandle(handle);
++
++    /* Check the size of the symlink */
++    bret = GetFileAttributesExW(reparse_path, GetFileExInfoStandard, &fad);
++    ok(bret, "Failed to read file attributes from the symlink target.\n");
++    ok(fad.nFileSizeLow == 0 && fad.nFileSizeHigh == 0, "Size of symlink is not zero.\n");
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    ok(handle != INVALID_HANDLE_VALUE, "Failed to open symlink file.\n");
++    ok(GetFileSize(handle, NULL) == 0, "symlink size is not zero\n");
++    bret = ReadFile(handle, &buf, sizeof(buf), &dwLen, NULL);
++    ok(bret, "Failed to read data from the symlink.\n");
++    ok(dwLen == 0, "Length of symlink data is not zero.\n");
++    memset(&info, 0x0, sizeof(info));
++    status = pNtQueryInformationFile(handle, &iosb, &info, sizeof(info), FileAttributeTagInformation);
++    ok( status == STATUS_SUCCESS, "got %#lx\n", status );
++    ok( info.ReparseTag == IO_REPARSE_TAG_SYMLINK, "got reparse tag %#lx\n", info.ReparseTag );
++    CloseHandle(handle);
++
++    /* Check the size/data of the symlink target */
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open symlink file handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    ok(GetFileSize(handle, NULL) == sizeof(fooW), "symlink target size does not match (%ld != %d)\n",
++       GetFileSize(handle, NULL), (int)sizeof(fooW));
++    bret = ReadFile(handle, &buf, sizeof(buf), &dwLen, NULL);
++    ok(bret, "Failed to read data from the symlink.\n");
++    ok(dwLen == sizeof(fooW), "Length of symlink target data does not match (%ld != %d).\n",
++       dwLen, (int)sizeof(fooW));
++    ok(!memcmp(fooW, &buf, sizeof(fooW)), "Symlink target data does not match (%s != %s).\n",
++       wine_dbgstr_wn(buf, dwLen), wine_dbgstr_w(fooW));
++    CloseHandle(handle);
++
++    /* Check the size/data of the symlink target when opened with FILE_FLAG_OPEN_REPARSE_POINT */
++    handle = CreateFileW(target_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open symlink file handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    ok(GetFileSize(handle, NULL) == sizeof(fooW), "symlink target size does not match (%ld != %d)\n",
++       GetFileSize(handle, NULL), (int)sizeof(fooW));
++    bret = ReadFile(handle, &buf, sizeof(buf), &dwLen, NULL);
++    ok(bret, "Failed to read data from the symlink target.\n");
++    ok(dwLen == sizeof(fooW), "Length of symlink target data does not match (%ld != %d).\n",
++       dwLen, (int)sizeof(fooW));
++    ok(!memcmp(fooW, &buf, sizeof(fooW)), "Symlink target data does not match (%s != %s).\n",
++       wine_dbgstr_wn(buf, dwLen), wine_dbgstr_w(fooW));
++    CloseHandle(handle);
++
++    /* Check deleting a file symlink as if it were a directory */
++    bret = RemoveDirectoryW(reparse_path);
++    ok(!bret, "Succeeded in deleting file symlink as a directory!\n");
++    err = GetLastError();
++    ok(err == ERROR_DIRECTORY,
++                 "Expected last error 0x%x for RemoveDirectory on file symlink (actually 0x%lx)!\n",
++                 ERROR_DIRECTORY, err);
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%lx)!\n", dwret);
++    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: 0x%lx)\n", dwret);
++
++    /* Delete the symlink as a file */
++    bret = DeleteFileW(reparse_path);
++    ok(bret, "Failed to delete symlink as a file!\n");
++
++    /* Create a blank slate for directory symlink tests */
++    bret = CreateDirectoryW(reparse_path, NULL);
++    ok(bret, "Failed to create junction point directory.\n");
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret != (DWORD)~0, "Path doesn't exist (attributes: 0x%lx)!\n", dwret);
++    ok(!(dwret & FILE_ATTRIBUTE_REPARSE_POINT), "File is already a reparse point! (attributes: %lx)\n", dwret);
++    bret = DeleteFileW(target_path);
++    ok(bret, "Failed to delete symlink target!\n");
++    bret = CreateDirectoryW(target_path, NULL);
++    ok(bret, "Failed to create symlink target directory.\n");
++
++    /* Create the directory symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open symlink directory handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
++    buffer_len = build_reparse_buffer(abs_target, IO_REPARSE_TAG_SYMLINK, 0, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
++
++    /* Check the file attributes of the symlink */
++    dwret = GetFileAttributesW(reparse_path);
++    ok(dwret != (DWORD)~0, "Symlink doesn't exist (attributes: 0x%lx)!\n", dwret);
++    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a symlink! (attributes: %lx)\n", dwret);
++
++    /* Read back the symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
++    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
++    ok(bret, "Failed to read symlink!\n");
++    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
++                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
++    path_len = buffer->SymbolicLinkReparseBuffer.PrintNameOffset/sizeof(WCHAR);
++    path_len += buffer->SymbolicLinkReparseBuffer.PrintNameLength/sizeof(WCHAR);
++    total_len = FIELD_OFFSET(typeof(*buffer), SymbolicLinkReparseBuffer.PathBuffer[path_len+1])
++                - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
++    ok(buffer->ReparseDataLength == total_len, "ReparseDataLength has unexpected value (%d != %d)\n",
++                                               buffer->ReparseDataLength, total_len);
++
++    /* Delete the symlink */
++    memset(&old_attrib, 0x00, sizeof(old_attrib));
++    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
++    dwret = NtSetInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to set symlink folder's attributes (0x%lx).\n", dwret);
++    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
++    guid_buffer.ReparseTag = IO_REPARSE_TAG_SYMLINK;
++    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
++                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to delete symlink! (0x%lx)\n", GetLastError());
++    memset(&new_attrib, 0x00, sizeof(new_attrib));
++    dwret = NtQueryInformationFile(handle, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
++    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
++       "Symlink folder's access time does not match.\n");
++    CloseHandle(handle);
++
++    /* Create a Unix/Linux symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    RemoveDirectoryW(reparse_path);
++    bret = CreateDirectoryW(reparse_path, NULL);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open symlink directory handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
++    path_len = strlen(unix_target);
++    buffer_len = offsetof(REPARSE_DATA_BUFFER, LinuxSymbolicLinkReparseBuffer.PathBuffer[path_len]);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    buffer->ReparseTag = IO_REPARSE_TAG_LX_SYMLINK;
++    buffer->ReparseDataLength = sizeof(ULONG) + path_len;
++    memcpy(buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer, unix_target, path_len);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
++
++    /* Read back the Unix/Linux symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    ok(bret, "Failed to read symlink!\n");
++    string_len = buffer->ReparseDataLength - sizeof(ULONG);
++    unix_dest = &buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer[0];
++    ok((memcmp(unix_dest, unix_target, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
++                                                          unix_dest, unix_target);
++    total_len = FIELD_OFFSET(typeof(*buffer), LinuxSymbolicLinkReparseBuffer.PathBuffer[path_len])
++                - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
++    ok(buffer->ReparseDataLength == total_len, "ReparseDataLength has unexpected value (%d != %d)\n",
++                                               buffer->ReparseDataLength, total_len);
++
++    /* Delete the symlink */
++    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
++    guid_buffer.ReparseTag = IO_REPARSE_TAG_LX_SYMLINK;
++    bret = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
++                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to delete symlink! (0x%lx)\n", GetLastError());
++    CloseHandle(handle);
++    RemoveDirectoryW(reparse_path);
++    DeleteFileW(reparse_path);
++    CreateDirectoryW(reparse_path, NULL);
++
++    /* Create a relative directory symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    handle = CreateFileW(reparse_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                         FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (handle == INVALID_HANDLE_VALUE)
++    {
++        win_skip("Failed to open symlink directory handle (0x%lx).\n", GetLastError());
++        goto cleanup;
++    }
++    dwret = NtQueryInformationFile(handle, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
++    ok(dwret == STATUS_SUCCESS, "Failed to get symlink folder's attributes (0x%lx).\n", dwret);
++    buffer_len = build_reparse_buffer(rel_target, IO_REPARSE_TAG_SYMLINK, SYMLINK_FLAG_RELATIVE, &buffer);
++    bret = DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
++    ok(bret, "Failed to create symlink! (0x%lx)\n", GetLastError());
++
++    /* Read back the relative symlink */
++    HeapFree(GetProcessHeap(), 0, buffer);
++    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
++    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++    bret = DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
++    ok(bret, "Failed to read relative symlink!\n");
++    string_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
++    ok(string_len != lstrlenW(rel_target), "Symlink destination length does not match ('%d' != '%d')!\n",
++                                            string_len, lstrlenW(rel_target));
++    dest = &buffer->SymbolicLinkReparseBuffer.PathBuffer[buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
++    ok((memcmp(dest, rel_target, string_len) == 0), "Symlink destination does not match ('%s' != '%s')!\n",
++                                                     wine_dbgstr_w(dest), wine_dbgstr_w(rel_target));
++    CloseHandle(handle);
++
++    /* Check moving a reparse point to another location */
++    lstrcpyW(new_path, path);
++    lstrcatW(new_path, parentW);
++    lstrcatW(new_path, new_reparseW);
++    bret = MoveFileW(reparse_path, new_path);
++    ok(bret, "Failed to move and rename reparse point.\n");
++    bret = MoveFileW(new_path, reparse_path);
++    ok(bret, "Failed to move and rename reparse point.\n");
++
++    /* Check copying a reparse point to another location */
++    lstrcpyW(new_path, path);
++    lstrcatW(new_path, new_reparseW);
++    bret = CopyFileW(reparse_path, new_path, TRUE);
++    ok(!bret, "Reparse points cannot be copied.\n");
++
++    /* Create a file on the other side of a reparse point */
++    lstrcpyW(thru_path, reparse_path);
++    lstrcatW(thru_path, new_reparseW);
++    handle = CreateFileW(thru_path, GENERIC_READ | GENERIC_WRITE, 0, 0, CREATE_NEW, 0, 0);
++    ok( handle != INVALID_HANDLE_VALUE, "Failed to create file on other side of reparse point: %lx.\n", GetLastError() );
++    CloseHandle(handle);
++
++cleanup:
++    /* Cleanup */
++    pRtlFreeUnicodeString(&nameW);
++    HeapFree(GetProcessHeap(), 0, long_path);
++    HeapFree(GetProcessHeap(), 0, buffer);
++    bret = DeleteFileW(thru_path);
++    ok(bret, "Failed to delete file on other side of junction point!\n");
++    bret = RemoveDirectoryW(reparse_path);
++    ok(bret, "Failed to remove temporary reparse point directory!\n");
++    bret = RemoveDirectoryW(target_path);
++    ok(bret, "Failed to remove temporary target directory!\n");
++    RemoveDirectoryW(path);
+ }
+ 
+ static void test_set_io_completion_ex(void)
+@@ -6117,6 +6643,6 @@ START_TEST(file)
+     test_ioctl();
+     test_query_ea();
+     test_flush_buffers_file();
+-    test_mailslot_name();
+     test_reparse_points();
++    test_mailslot_name();
+ }
+diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
+new file mode 100644
+index 000000000000..86809b610c70
+--- /dev/null
++++ b/dlls/ntdll/unix/esync.c
+@@ -0,0 +1,1325 @@
++/*
++ * eventfd-based synchronization objects
++ *
++ * Copyright (C) 2018 Zebediah Figura
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#if 0
++#pragma makedep unix
++#endif
++
++#include "config.h"
++
++#ifndef _GNU_SOURCE
++#define _GNU_SOURCE
++#endif
++
++#include <assert.h>
++#include <errno.h>
++#include <fcntl.h>
++#include <stdarg.h>
++#include <stdint.h>
++#include <stdlib.h>
++#include <sys/mman.h>
++#ifdef HAVE_SYS_STAT_H
++# include <sys/stat.h>
++#endif
++#include <poll.h>
++#include <sys/types.h>
++#include <unistd.h>
++
++#include "ntstatus.h"
++#define WIN32_NO_STATUS
++#include "windef.h"
++#include "winternl.h"
++#include "wine/server.h"
++#include "wine/debug.h"
++
++#include "unix_private.h"
++#include "esync.h"
++
++WINE_DEFAULT_DEBUG_CHANNEL(esync);
++
++int do_esync(void)
++{
++#ifdef HAVE_SYS_EVENTFD_H
++    static int do_esync_cached = -1;
++
++    if (do_esync_cached == -1)
++        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
++
++    return do_esync_cached;
++#else
++    static int once;
++    if (!once++)
++        FIXME("eventfd not supported on this platform.\n");
++    return 0;
++#endif
++}
++
++struct esync
++{
++    LONG type;
++    int fd;
++    void *shm;
++};
++
++struct semaphore
++{
++    LONG max;
++    LONG count;
++};
++C_ASSERT(sizeof(struct semaphore) == 8);
++
++struct mutex
++{
++    LONG tid;
++    LONG count;    /* recursion count */
++};
++C_ASSERT(sizeof(struct mutex) == 8);
++
++struct event
++{
++    LONG signaled;
++    LONG locked;
++};
++C_ASSERT(sizeof(struct event) == 8);
++
++static char shm_name[29];
++static int shm_fd;
++static void **shm_addrs;
++static int shm_addrs_size;  /* length of the allocated shm_addrs array */
++static long pagesize;
++
++static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
++
++static void *get_shm( unsigned int idx )
++{
++    int entry  = (idx * 8) / pagesize;
++    int offset = (idx * 8) % pagesize;
++    void *ret;
++
++    pthread_mutex_lock( &shm_addrs_mutex );
++
++    if (entry >= shm_addrs_size)
++    {
++        int new_size = max(shm_addrs_size * 2, entry + 1);
++
++        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
++            ERR("Failed to grow shm_addrs array to size %d.\n", shm_addrs_size);
++        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
++        shm_addrs_size = new_size;
++    }
++
++    if (!shm_addrs[entry])
++    {
++        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
++        if (addr == (void *)-1)
++            ERR("Failed to map page %d (offset %#lx).\n", entry, entry * pagesize);
++
++        TRACE("Mapping page %d at %p.\n", entry, addr);
++
++        if (InterlockedCompareExchangePointer( &shm_addrs[entry], addr, 0 ))
++            munmap( addr, pagesize ); /* someone beat us to it */
++    }
++
++    ret = (void *)((unsigned long)shm_addrs[entry] + offset);
++
++    pthread_mutex_unlock( &shm_addrs_mutex );
++
++    return ret;
++}
++
++/* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
++ * This is copied and adapted from the fd cache code. */
++
++#define ESYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct esync))
++#define ESYNC_LIST_ENTRIES     256
++
++static struct esync *esync_list[ESYNC_LIST_ENTRIES];
++static struct esync esync_list_initial_block[ESYNC_LIST_BLOCK_SIZE];
++
++static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
++{
++    UINT_PTR idx = (((UINT_PTR)handle) >> 2) - 1;
++    *entry = idx / ESYNC_LIST_BLOCK_SIZE;
++    return idx % ESYNC_LIST_BLOCK_SIZE;
++}
++
++static struct esync *add_to_list( HANDLE handle, enum esync_type type, int fd, void *shm )
++{
++    UINT_PTR entry, idx = handle_to_index( handle, &entry );
++
++    if (entry >= ESYNC_LIST_ENTRIES)
++    {
++        FIXME( "too many allocated handles, not caching %p\n", handle );
++        return FALSE;
++    }
++
++    if (!esync_list[entry])  /* do we need to allocate a new block of entries? */
++    {
++        if (!entry) esync_list[0] = esync_list_initial_block;
++        else
++        {
++            void *ptr = anon_mmap_alloc( ESYNC_LIST_BLOCK_SIZE * sizeof(struct esync),
++                                         PROT_READ | PROT_WRITE );
++            if (ptr == MAP_FAILED) return FALSE;
++            esync_list[entry] = ptr;
++        }
++    }
++
++    if (!InterlockedCompareExchange( &esync_list[entry][idx].type, type, 0 ))
++    {
++        esync_list[entry][idx].fd = fd;
++        esync_list[entry][idx].shm = shm;
++    }
++    return &esync_list[entry][idx];
++}
++
++static struct esync *get_cached_object( HANDLE handle )
++{
++    UINT_PTR entry, idx = handle_to_index( handle, &entry );
++
++    if (entry >= ESYNC_LIST_ENTRIES || !esync_list[entry]) return NULL;
++    if (!esync_list[entry][idx].type) return NULL;
++
++    return &esync_list[entry][idx];
++}
++
++/* Gets an object. This is either a proper esync object (i.e. an event,
++ * semaphore, etc. created using create_esync) or a generic synchronizable
++ * server-side object which the server will signal (e.g. a process, thread,
++ * message queue, etc.) */
++static NTSTATUS get_object( HANDLE handle, struct esync **obj )
++{
++    int ret = STATUS_SUCCESS;
++    enum esync_type type = 0;
++    unsigned int shm_idx = 0;
++    obj_handle_t fd_handle;
++    sigset_t sigset;
++    int fd = -1;
++
++    if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
++
++    if ((INT_PTR)handle < 0)
++    {
++        /* We can deal with pseudo-handles, but it's just easier this way */
++        return STATUS_NOT_IMPLEMENTED;
++    }
++
++    if (!handle)
++    {
++        /* Shadow of the Tomb Raider really likes passing in NULL handles to
++         * various functions. Concerning, but let's avoid a server call. */
++        return STATUS_INVALID_HANDLE;
++    }
++
++    /* We need to try grabbing it from the server. */
++    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
++    if (!(*obj = get_cached_object( handle )))
++    {
++        SERVER_START_REQ( get_esync_fd )
++        {
++            req->handle = wine_server_obj_handle( handle );
++            if (!(ret = wine_server_call( req )))
++            {
++                type = reply->type;
++                shm_idx = reply->shm_idx;
++                fd = receive_fd( &fd_handle );
++                assert( wine_server_ptr_handle(fd_handle) == handle );
++            }
++        }
++        SERVER_END_REQ;
++    }
++    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
++
++    if (*obj)
++    {
++        /* We managed to grab it while in the CS; return it. */
++        return STATUS_SUCCESS;
++    }
++
++    if (ret)
++    {
++        WARN("Failed to retrieve fd for handle %p, status %#x.\n", handle, ret);
++        *obj = NULL;
++        return ret;
++    }
++
++    TRACE("Got fd %d for handle %p.\n", fd, handle);
++
++    *obj = add_to_list( handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
++    return ret;
++}
++
++NTSTATUS esync_close( HANDLE handle )
++{
++    UINT_PTR entry, idx = handle_to_index( handle, &entry );
++
++    TRACE("%p.\n", handle);
++
++    if (entry < ESYNC_LIST_ENTRIES && esync_list[entry])
++    {
++        if (InterlockedExchange(&esync_list[entry][idx].type, 0))
++        {
++            close( esync_list[entry][idx].fd );
++            return STATUS_SUCCESS;
++        }
++    }
++
++    return STATUS_INVALID_HANDLE;
++}
++
++static NTSTATUS create_esync( enum esync_type type, HANDLE *handle, ACCESS_MASK access,
++                              const OBJECT_ATTRIBUTES *attr, int initval, int max )
++{
++    NTSTATUS ret;
++    data_size_t len;
++    struct object_attributes *objattr;
++    obj_handle_t fd_handle;
++    unsigned int shm_idx;
++    sigset_t sigset;
++    int fd;
++
++    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
++
++    /* We have to synchronize on the fd cache CS so that our calls to
++     * receive_fd don't race with theirs. */
++    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
++    SERVER_START_REQ( create_esync )
++    {
++        req->access  = access;
++        req->initval = initval;
++        req->type    = type;
++        req->max     = max;
++        wine_server_add_data( req, objattr, len );
++        ret = wine_server_call( req );
++        if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
++        {
++            *handle = wine_server_ptr_handle( reply->handle );
++            type = reply->type;
++            shm_idx = reply->shm_idx;
++            fd = receive_fd( &fd_handle );
++            assert( wine_server_ptr_handle(fd_handle) == *handle );
++        }
++    }
++    SERVER_END_REQ;
++    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
++
++    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
++    {
++        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
++        TRACE("-> handle %p, fd %d.\n", *handle, fd);
++    }
++
++    free( objattr );
++    return ret;
++}
++
++static NTSTATUS open_esync( enum esync_type type, HANDLE *handle,
++    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
++{
++    NTSTATUS ret;
++    obj_handle_t fd_handle;
++    unsigned int shm_idx;
++    sigset_t sigset;
++    int fd;
++
++    server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
++    SERVER_START_REQ( open_esync )
++    {
++        req->access     = access;
++        req->attributes = attr->Attributes;
++        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
++        req->type       = type;
++        if (attr->ObjectName)
++            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
++        if (!(ret = wine_server_call( req )))
++        {
++            *handle = wine_server_ptr_handle( reply->handle );
++            type = reply->type;
++            shm_idx = reply->shm_idx;
++            fd = receive_fd( &fd_handle );
++            assert( wine_server_ptr_handle(fd_handle) == *handle );
++        }
++    }
++    SERVER_END_REQ;
++    server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
++
++    if (!ret)
++    {
++        add_to_list( *handle, type, fd, shm_idx ? get_shm( shm_idx ) : 0 );
++
++        TRACE("-> handle %p, fd %d.\n", *handle, fd);
++    }
++    return ret;
++}
++
++extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr, int initial, int max)
++{
++    TRACE("name %s, initial %d, max %d.\n",
++        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial, max);
++
++    return create_esync( ESYNC_SEMAPHORE, handle, access, attr, initial, max );
++}
++
++NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr )
++{
++    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
++
++    return open_esync( ESYNC_SEMAPHORE, handle, access, attr );
++}
++
++NTSTATUS esync_release_semaphore( HANDLE handle, unsigned int count, ULONG *prev )
++{
++    struct esync *obj;
++    struct semaphore *semaphore;
++    uint64_t count64 = count;
++    ULONG current;
++    NTSTATUS ret;
++
++    TRACE("%p, %d, %p.\n", handle, count, prev);
++
++    if ((ret = get_object( handle, &obj))) return ret;
++    semaphore = obj->shm;
++
++    do
++    {
++        current = semaphore->count;
++
++        if (count + current > semaphore->max)
++            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
++    } while (InterlockedCompareExchange( &semaphore->count, count + current, current ) != current);
++
++    if (prev) *prev = current;
++
++    /* We don't have to worry about a race between increasing the count and
++     * write(). The fact that we were able to increase the count means that we
++     * have permission to actually write that many releases to the semaphore. */
++
++    if (write( obj->fd, &count64, sizeof(count64) ) == -1)
++        return errno_to_status( errno );
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len )
++{
++    struct esync *obj;
++    struct semaphore *semaphore;
++    SEMAPHORE_BASIC_INFORMATION *out = info;
++    NTSTATUS ret;
++
++    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++    semaphore = obj->shm;
++
++    out->CurrentCount = semaphore->count;
++    out->MaximumCount = semaphore->max;
++    if (ret_len) *ret_len = sizeof(*out);
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
++{
++    enum esync_type type = (event_type == SynchronizationEvent ? ESYNC_AUTO_EVENT : ESYNC_MANUAL_EVENT);
++
++    TRACE("name %s, %s-reset, initial %d.\n",
++        attr ? debugstr_us(attr->ObjectName) : "<no name>",
++        event_type == NotificationEvent ? "manual" : "auto", initial);
++
++    return create_esync( type, handle, access, attr, initial, 0 );
++}
++
++NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr )
++{
++    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
++
++    return open_esync( ESYNC_AUTO_EVENT, handle, access, attr ); /* doesn't matter which */
++}
++
++static inline void small_pause(void)
++{
++#ifdef __i386__
++    __asm__ __volatile__( "rep;nop" : : : "memory" );
++#else
++    __asm__ __volatile__( "" : : : "memory" );
++#endif
++}
++
++/* Manual-reset events are actually racier than other objects in terms of shm
++ * state. With other objects, races don't matter, because we only treat the shm
++ * state as a hint that lets us skip poll()—we still have to read(). But with
++ * manual-reset events we don't, which means that the shm state can be out of
++ * sync with the actual state.
++ *
++ * In general we shouldn't have to worry about races between modifying the
++ * event and waiting on it. If the state changes while we're waiting, it's
++ * equally plausible that we caught it before or after the state changed.
++ * However, we can have races between SetEvent() and ResetEvent(), so that the
++ * event has inconsistent internal state.
++ *
++ * To solve this we have to use the other field to lock the event. Currently
++ * this is implemented as a spinlock, but I'm not sure if a futex might be
++ * better. I'm also not sure if it's possible to obviate locking by arranging
++ * writes and reads in a certain way.
++ *
++ * Note that we don't have to worry about locking in esync_wait_objects().
++ * There's only two general patterns:
++ *
++ * WaitFor()    SetEvent()
++ * -------------------------
++ * read()
++ * signaled = 0
++ *              signaled = 1
++ *              write()
++ * -------------------------
++ * read()
++ *              signaled = 1
++ * signaled = 0
++ *              <no write(), because it was already signaled>
++ * -------------------------
++ *
++ * That is, if SetEvent() tries to signal the event before WaitFor() resets its
++ * signaled state, it won't bother trying to write(), and then the signaled
++ * state will be reset, so the result is a consistent non-signaled event.
++ * There's several variations to this pattern but all of them are protected in
++ * the same way. Note however this is why we have to use interlocked_xchg()
++ * event inside of the lock.
++ */
++
++/* Removing this spinlock is harder than it looks. esync_wait_objects() can
++ * deal with inconsistent state well enough, and a race between SetEvent() and
++ * ResetEvent() gives us license to yield either result as long as we act
++ * consistently, but that's not enough. Notably, esync_wait_objects() should
++ * probably act like a fence, so that the second half of esync_set_event() does
++ * not seep past a subsequent reset. That's one problem, but no guarantee there
++ * aren't others. */
++
++NTSTATUS esync_set_event( HANDLE handle )
++{
++    static const uint64_t value = 1;
++    struct esync *obj;
++    struct event *event;
++    NTSTATUS ret;
++
++    TRACE("%p.\n", handle);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++    event = obj->shm;
++
++    if (obj->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Acquire the spinlock. */
++        while (InterlockedCompareExchange( &event->locked, 1, 0 ))
++            small_pause();
++    }
++
++    /* For manual-reset events, as long as we're in a lock, we can take the
++     * optimization of only calling write() if the event wasn't already
++     * signaled.
++     *
++     * For auto-reset events, esync_wait_objects() must grab the kernel object.
++     * Thus if we got into a race so that the shm state is signaled but the
++     * eventfd is unsignaled (i.e. reset shm, set shm, set fd, reset fd), we
++     * *must* signal the fd now, or any waiting threads will never wake up. */
++
++    if (!InterlockedExchange( &event->signaled, 1 ) || obj->type == ESYNC_AUTO_EVENT)
++    {
++        if (write( obj->fd, &value, sizeof(value) ) == -1)
++            ERR("write: %s\n", strerror(errno));
++    }
++
++    if (obj->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Release the spinlock. */
++        event->locked = 0;
++    }
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_reset_event( HANDLE handle )
++{
++    uint64_t value;
++    struct esync *obj;
++    struct event *event;
++    NTSTATUS ret;
++
++    TRACE("%p.\n", handle);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++    event = obj->shm;
++
++    if (obj->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Acquire the spinlock. */
++        while (InterlockedCompareExchange( &event->locked, 1, 0 ))
++            small_pause();
++    }
++
++    /* For manual-reset events, as long as we're in a lock, we can take the
++     * optimization of only calling read() if the event was already signaled.
++     *
++     * For auto-reset events, we have no guarantee that the previous "signaled"
++     * state is actually correct. We need to leave both states unsignaled after
++     * leaving this function, so we always have to read(). */
++    if (InterlockedExchange( &event->signaled, 0 ) || obj->type == ESYNC_AUTO_EVENT)
++    {
++        if (read( obj->fd, &value, sizeof(value) ) == -1 && errno != EWOULDBLOCK && errno != EAGAIN)
++        {
++            ERR("read: %s\n", strerror(errno));
++        }
++    }
++
++    if (obj->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Release the spinlock. */
++        event->locked = 0;
++    }
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_pulse_event( HANDLE handle )
++{
++    uint64_t value = 1;
++    struct esync *obj;
++    NTSTATUS ret;
++
++    TRACE("%p.\n", handle);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++
++    /* This isn't really correct; an application could miss the write.
++     * Unfortunately we can't really do much better. Fortunately this is rarely
++     * used (and publicly deprecated). */
++    if (write( obj->fd, &value, sizeof(value) ) == -1)
++        return errno_to_status( errno );
++
++    /* Try to give other threads a chance to wake up. Hopefully erring on this
++     * side is the better thing to do... */
++    NtYieldExecution();
++
++    read( obj->fd, &value, sizeof(value) );
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_query_event( HANDLE handle, void *info, ULONG *ret_len )
++{
++    struct esync *obj;
++    EVENT_BASIC_INFORMATION *out = info;
++    struct pollfd fd;
++    NTSTATUS ret;
++
++    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++
++    fd.fd = obj->fd;
++    fd.events = POLLIN;
++    out->EventState = poll( &fd, 1, 0 );
++    out->EventType = (obj->type == ESYNC_AUTO_EVENT ? SynchronizationEvent : NotificationEvent);
++    if (ret_len) *ret_len = sizeof(*out);
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
++{
++    TRACE("name %s, initial %d.\n",
++        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
++
++    return create_esync( ESYNC_MUTEX, handle, access, attr, initial ? 0 : 1, 0 );
++}
++
++NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr )
++{
++    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
++
++    return open_esync( ESYNC_MUTEX, handle, access, attr );
++}
++
++NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev )
++{
++    struct esync *obj;
++    struct mutex *mutex;
++    static const uint64_t value = 1;
++    NTSTATUS ret;
++
++    TRACE("%p, %p.\n", handle, prev);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++    mutex = obj->shm;
++
++    /* This is thread-safe, because the only thread that can change the tid to
++     * or from our tid is ours. */
++    if (mutex->tid != GetCurrentThreadId()) return STATUS_MUTANT_NOT_OWNED;
++
++    if (prev) *prev = mutex->count;
++
++    mutex->count--;
++
++    if (!mutex->count)
++    {
++        /* This is also thread-safe, as long as signaling the file is the last
++         * thing we do. Other threads don't care about the tid if it isn't
++         * theirs. */
++        mutex->tid = 0;
++
++        if (write( obj->fd, &value, sizeof(value) ) == -1)
++            return errno_to_status( errno );
++    }
++
++    return STATUS_SUCCESS;
++}
++
++NTSTATUS esync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
++{
++    struct esync *obj;
++    struct mutex *mutex;
++    MUTANT_BASIC_INFORMATION *out = info;
++    NTSTATUS ret;
++
++    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
++
++    if ((ret = get_object( handle, &obj ))) return ret;
++    mutex = obj->shm;
++
++    out->CurrentCount = 1 - mutex->count;
++    out->OwnedByCaller = (mutex->tid == GetCurrentThreadId());
++    out->AbandonedState = (mutex->tid == ~0);
++    if (ret_len) *ret_len = sizeof(*out);
++
++    return STATUS_SUCCESS;
++}
++
++#define TICKSPERSEC        10000000
++#define TICKSPERMSEC       10000
++
++static LONGLONG update_timeout( ULONGLONG end )
++{
++    LARGE_INTEGER now;
++    LONGLONG timeleft;
++
++    NtQuerySystemTime( &now );
++    timeleft = end - now.QuadPart;
++    if (timeleft < 0) timeleft = 0;
++    return timeleft;
++}
++
++static int do_poll( struct pollfd *fds, nfds_t nfds, ULONGLONG *end )
++{
++    int ret;
++
++    do
++    {
++        if (end)
++        {
++            LONGLONG timeleft = update_timeout( *end );
++
++#ifdef HAVE_PPOLL
++            /* We use ppoll() if available since the time granularity is better. */
++            struct timespec tmo_p;
++            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
++            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
++            ret = ppoll( fds, nfds, &tmo_p, NULL );
++#else
++            ret = poll( fds, nfds, timeleft / TICKSPERMSEC );
++#endif
++        }
++        else
++            ret = poll( fds, nfds, -1 );
++
++    /* If we receive EINTR we were probably suspended (SIGUSR1), possibly for a
++     * system APC. The right thing to do is just try again. */
++    } while (ret < 0 && errno == EINTR);
++
++    return ret;
++}
++
++/* Return TRUE if abandoned. */
++static BOOL update_grabbed_object( struct esync *obj )
++{
++    BOOL ret = FALSE;
++
++    if (obj->type == ESYNC_MUTEX)
++    {
++        struct mutex *mutex = obj->shm;
++        /* We don't have to worry about a race between this and read(); the
++         * fact that we grabbed it means the count is now zero, so nobody else
++         * can (and the only thread that can release it is us). */
++        if (mutex->tid == ~0)
++            ret = TRUE;
++        mutex->tid = GetCurrentThreadId();
++        mutex->count++;
++    }
++    else if (obj->type == ESYNC_SEMAPHORE)
++    {
++        struct semaphore *semaphore = obj->shm;
++        /* We don't have to worry about a race between this and read(); the
++         * fact that we were able to grab it at all means the count is nonzero,
++         * and if someone else grabbed it then the count must have been >= 2,
++         * etc. */
++        InterlockedExchangeAdd( &semaphore->count, -1 );
++    }
++    else if (obj->type == ESYNC_AUTO_EVENT)
++    {
++        struct event *event = obj->shm;
++        /* We don't have to worry about a race between this and read(), since
++         * this is just a hint, and the real state is in the kernel object.
++         * This might already be 0, but that's okay! */
++        event->signaled = 0;
++    }
++
++    return ret;
++}
++
++/* A value of STATUS_NOT_IMPLEMENTED returned from this function means that we
++ * need to delegate to server_select(). */
++static NTSTATUS __esync_wait_objects( unsigned int count, const HANDLE *handles, BOOLEAN wait_any,
++                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
++{
++    static const LARGE_INTEGER zero;
++
++    struct esync *objs[MAXIMUM_WAIT_OBJECTS];
++    struct pollfd fds[MAXIMUM_WAIT_OBJECTS + 1];
++    int has_esync = 0, has_server = 0;
++    BOOL msgwait = FALSE;
++    LONGLONG timeleft;
++    LARGE_INTEGER now;
++    DWORD pollcount;
++    ULONGLONG end;
++    int64_t value;
++    ssize_t size;
++    int i, j, ret;
++
++    /* Grab the APC fd if we don't already have it. */
++    if (alertable && ntdll_get_thread_data()->esync_apc_fd == -1)
++    {
++        obj_handle_t fd_handle;
++        sigset_t sigset;
++        int fd = -1;
++
++        server_enter_uninterrupted_section( &fd_cache_mutex, &sigset );
++        SERVER_START_REQ( get_esync_apc_fd )
++        {
++            if (!(ret = wine_server_call( req )))
++            {
++                fd = receive_fd( &fd_handle );
++                assert( fd_handle == GetCurrentThreadId() );
++            }
++        }
++        SERVER_END_REQ;
++        server_leave_uninterrupted_section( &fd_cache_mutex, &sigset );
++
++        ntdll_get_thread_data()->esync_apc_fd = fd;
++    }
++
++    NtQuerySystemTime( &now );
++    if (timeout)
++    {
++        if (timeout->QuadPart == TIMEOUT_INFINITE)
++            timeout = NULL;
++        else if (timeout->QuadPart >= 0)
++            end = timeout->QuadPart;
++        else
++            end = now.QuadPart - timeout->QuadPart;
++    }
++
++    for (i = 0; i < count; i++)
++    {
++        ret = get_object( handles[i], &objs[i] );
++        if (ret == STATUS_SUCCESS)
++            has_esync = 1;
++        else if (ret == STATUS_NOT_IMPLEMENTED)
++            has_server = 1;
++        else
++            return ret;
++    }
++
++    if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
++        msgwait = TRUE;
++
++    if (has_esync && has_server)
++        FIXME("Can't wait on esync and server objects at the same time!\n");
++    else if (has_server)
++        return STATUS_NOT_IMPLEMENTED;
++
++    if (TRACE_ON(esync))
++    {
++        TRACE("Waiting for %s of %d handles:", wait_any ? "any" : "all", count);
++        for (i = 0; i < count; i++)
++            TRACE(" %p", handles[i]);
++
++        if (msgwait)
++            TRACE(" or driver events");
++        if (alertable)
++            TRACE(", alertable");
++
++        if (!timeout)
++            TRACE(", timeout = INFINITE.\n");
++        else
++        {
++            timeleft = update_timeout( end );
++            TRACE(", timeout = %ld.%07ld sec.\n",
++                (long) timeleft / TICKSPERSEC, (long) timeleft % TICKSPERSEC);
++        }
++    }
++
++    if (wait_any || count == 1)
++    {
++        /* Try to check objects now, so we can obviate poll() at least. */
++        for (i = 0; i < count; i++)
++        {
++            struct esync *obj = objs[i];
++
++            if (obj)
++            {
++                switch (obj->type)
++                {
++                case ESYNC_MUTEX:
++                {
++                    struct mutex *mutex = obj->shm;
++
++                    if (mutex->tid == GetCurrentThreadId())
++                    {
++                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                        mutex->count++;
++                        return i;
++                    }
++                    else if (!mutex->count)
++                    {
++                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
++                        {
++                            if (mutex->tid == ~0)
++                            {
++                                TRACE("Woken up by abandoned mutex %p [%d].\n", handles[i], i);
++                                i += STATUS_ABANDONED_WAIT_0;
++                            }
++                            else
++                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                            mutex->tid = GetCurrentThreadId();
++                            mutex->count++;
++                            return i;
++                        }
++                    }
++                    break;
++                }
++                case ESYNC_SEMAPHORE:
++                {
++                    struct semaphore *semaphore = obj->shm;
++
++                    if (semaphore->count)
++                    {
++                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
++                        {
++                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                            InterlockedDecrement( &semaphore->count );
++                            return i;
++                        }
++                    }
++                    break;
++                }
++                case ESYNC_AUTO_EVENT:
++                {
++                    struct event *event = obj->shm;
++
++                    if (event->signaled)
++                    {
++                        if ((size = read( obj->fd, &value, sizeof(value) )) == sizeof(value))
++                        {
++                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                            event->signaled = 0;
++                            return i;
++                        }
++                    }
++                    break;
++                }
++                case ESYNC_MANUAL_EVENT:
++                {
++                    struct event *event = obj->shm;
++
++                    if (event->signaled)
++                    {
++                        TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                        return i;
++                    }
++                    break;
++                }
++                case ESYNC_AUTO_SERVER:
++                case ESYNC_MANUAL_SERVER:
++                case ESYNC_QUEUE:
++                    /* We can't wait on any of these. Fortunately I don't think
++                     * they'll ever be uncontended anyway (at least, they won't be
++                     * performance-critical). */
++                    break;
++                }
++            }
++
++            fds[i].fd = obj ? obj->fd : -1;
++            fds[i].events = POLLIN;
++        }
++        if (alertable)
++        {
++            fds[i].fd = ntdll_get_thread_data()->esync_apc_fd;
++            fds[i].events = POLLIN;
++            i++;
++        }
++        pollcount = i;
++
++        while (1)
++        {
++            ret = do_poll( fds, pollcount, timeout ? &end : NULL );
++            if (ret > 0)
++            {
++                /* We must check this first! The server may set an event that
++                 * we're waiting on, but we need to return STATUS_USER_APC. */
++                if (alertable)
++                {
++                    if (fds[pollcount - 1].revents & POLLIN)
++                        goto userapc;
++                }
++
++                /* Find out which object triggered the wait. */
++                for (i = 0; i < count; i++)
++                {
++                    struct esync *obj = objs[i];
++
++                    if (fds[i].revents & (POLLERR | POLLHUP | POLLNVAL))
++                    {
++                        ERR("Polling on fd %d returned %#x.\n", fds[i].fd, fds[i].revents);
++                        return STATUS_INVALID_HANDLE;
++                    }
++
++                    if (obj)
++                    {
++                        if (obj->type == ESYNC_MANUAL_EVENT
++                                || obj->type == ESYNC_MANUAL_SERVER
++                                || obj->type == ESYNC_QUEUE)
++                        {
++                            /* Don't grab the object, just check if it's signaled. */
++                            if (fds[i].revents & POLLIN)
++                            {
++                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                                return i;
++                            }
++                        }
++                        else
++                        {
++                            if ((size = read( fds[i].fd, &value, sizeof(value) )) == sizeof(value))
++                            {
++                                /* We found our object. */
++                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
++                                if (update_grabbed_object( obj ))
++                                    return STATUS_ABANDONED_WAIT_0 + i;
++                                return i;
++                            }
++                        }
++                    }
++                }
++
++                /* If we got here, someone else stole (or reset, etc.) whatever
++                 * we were waiting for. So keep waiting. */
++                NtQuerySystemTime( &now );
++            }
++            else
++                goto err;
++        }
++    }
++    else
++    {
++        /* Wait-all is a little trickier to implement correctly. Fortunately,
++         * it's not as common.
++         *
++         * The idea is basically just to wait in sequence on every object in the
++         * set. Then when we're done, try to grab them all in a tight loop. If
++         * that fails, release any resources we've grabbed (and yes, we can
++         * reliably do this—it's just mutexes and semaphores that we have to
++         * put back, and in both cases we just put back 1), and if any of that
++         * fails we start over.
++         *
++         * What makes this inherently bad is that we might temporarily grab a
++         * resource incorrectly. Hopefully it'll be quick (and hey, it won't
++         * block on wineserver) so nobody will notice. Besides, consider: if
++         * object A becomes signaled but someone grabs it before we can grab it
++         * and everything else, then they could just as well have grabbed it
++         * before it became signaled. Similarly if object A was signaled and we
++         * were blocking on object B, then B becomes available and someone grabs
++         * A before we can, then they might have grabbed A before B became
++         * signaled. In either case anyone who tries to wait on A or B will be
++         * waiting for an instant while we put things back. */
++
++        while (1)
++        {
++tryagain:
++            /* First step: try to poll on each object in sequence. */
++            fds[0].events = POLLIN;
++            pollcount = 1;
++            if (alertable)
++            {
++                /* We also need to wait on APCs. */
++                fds[1].fd = ntdll_get_thread_data()->esync_apc_fd;
++                fds[1].events = POLLIN;
++                pollcount++;
++            }
++            for (i = 0; i < count; i++)
++            {
++                struct esync *obj = objs[i];
++
++                fds[0].fd = obj ? obj->fd : -1;
++
++                if (obj && obj->type == ESYNC_MUTEX)
++                {
++                    /* It might be ours. */
++                    struct mutex *mutex = obj->shm;
++
++                    if (mutex->tid == GetCurrentThreadId())
++                        continue;
++                }
++
++                ret = do_poll( fds, pollcount, timeout ? &end : NULL );
++                if (ret <= 0)
++                    goto err;
++                else if (alertable && (fds[1].revents & POLLIN))
++                    goto userapc;
++
++                if (fds[0].revents & (POLLHUP | POLLERR | POLLNVAL))
++                {
++                    ERR("Polling on fd %d returned %#x.\n", fds[0].fd, fds[0].revents);
++                    return STATUS_INVALID_HANDLE;
++                }
++            }
++
++            /* If we got here and we haven't timed out, that means all of the
++             * handles were signaled. Check to make sure they still are. */
++            for (i = 0; i < count; i++)
++            {
++                fds[i].fd = objs[i] ? objs[i]->fd : -1;
++                fds[i].events = POLLIN;
++            }
++            /* There's no reason to check for APCs here. */
++            pollcount = i;
++
++            /* Poll everything to see if they're still signaled. */
++            ret = poll( fds, pollcount, 0 );
++            if (ret == pollcount)
++            {
++                BOOL abandoned = FALSE;
++
++                /* Quick, grab everything. */
++                for (i = 0; i < count; i++)
++                {
++                    struct esync *obj = objs[i];
++
++                    switch (obj->type)
++                    {
++                    case ESYNC_MUTEX:
++                    {
++                        struct mutex *mutex = obj->shm;
++                        if (mutex->tid == GetCurrentThreadId())
++                            break;
++                        /* otherwise fall through */
++                    }
++                    case ESYNC_SEMAPHORE:
++                    case ESYNC_AUTO_EVENT:
++                        if ((size = read( fds[i].fd, &value, sizeof(value) )) != sizeof(value))
++                        {
++                            /* We were too slow. Put everything back. */
++                            value = 1;
++                            for (j = i; j >= 0; j--)
++                            {
++                                if (write( obj->fd, &value, sizeof(value) ) == -1)
++                                    return errno_to_status( errno );
++                            }
++
++                            goto tryagain;  /* break out of two loops and a switch */
++                        }
++                        break;
++                    default:
++                        /* If a manual-reset event changed between there and
++                         * here, it's shouldn't be a problem. */
++                        break;
++                    }
++                }
++
++                /* If we got here, we successfully waited on every object. */
++                /* Make sure to let ourselves know that we grabbed the mutexes
++                 * and semaphores. */
++                for (i = 0; i < count; i++)
++                    abandoned |= update_grabbed_object( objs[i] );
++
++                if (abandoned)
++                {
++                    TRACE("Wait successful, but some object(s) were abandoned.\n");
++                    return STATUS_ABANDONED;
++                }
++                TRACE("Wait successful.\n");
++                return STATUS_SUCCESS;
++            }
++
++            /* If we got here, ppoll() returned less than all of our objects.
++             * So loop back to the beginning and try again. */
++        } /* while(1) */
++    } /* else (wait-all) */
++
++err:
++    /* We should only get here if poll() failed. */
++
++    if (ret == 0)
++    {
++        TRACE("Wait timed out.\n");
++        return STATUS_TIMEOUT;
++    }
++    else
++    {
++        ERR("ppoll failed: %s\n", strerror(errno));
++        return errno_to_status( errno );
++    }
++
++userapc:
++    TRACE("Woken up by user APC.\n");
++
++    /* We have to make a server call anyway to get the APC to execute, so just
++     * delegate down to server_select(). */
++    ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &zero );
++
++    /* This can happen if we received a system APC, and the APC fd was woken up
++     * before we got SIGUSR1. poll() doesn't return EINTR in that case. The
++     * right thing to do seems to be to return STATUS_USER_APC anyway. */
++    if (ret == STATUS_TIMEOUT) ret = STATUS_USER_APC;
++    return ret;
++}
++
++/* We need to let the server know when we are doing a message wait, and when we
++ * are done with one, so that all of the code surrounding hung queues works.
++ * We also need this for WaitForInputIdle(). */
++static void server_set_msgwait( int in_msgwait )
++{
++    SERVER_START_REQ( esync_msgwait )
++    {
++        req->in_msgwait = in_msgwait;
++        wine_server_call( req );
++    }
++    SERVER_END_REQ;
++}
++
++/* This is a very thin wrapper around the proper implementation above. The
++ * purpose is to make sure the server knows when we are doing a message wait.
++ * This is separated into a wrapper function since there are at least a dozen
++ * exit paths from esync_wait_objects(). */
++NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
++                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
++{
++    BOOL msgwait = FALSE;
++    struct esync *obj;
++    NTSTATUS ret;
++
++    if (count && !get_object( handles[count - 1], &obj ) && obj->type == ESYNC_QUEUE)
++    {
++        msgwait = TRUE;
++        server_set_msgwait( 1 );
++    }
++
++    ret = __esync_wait_objects( count, handles, wait_any, alertable, timeout );
++
++    if (msgwait)
++        server_set_msgwait( 0 );
++
++    return ret;
++}
++
++NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
++    const LARGE_INTEGER *timeout )
++{
++    struct esync *obj;
++    NTSTATUS ret;
++
++    if ((ret = get_object( signal, &obj ))) return ret;
++
++    switch (obj->type)
++    {
++    case ESYNC_SEMAPHORE:
++        ret = esync_release_semaphore( signal, 1, NULL );
++        break;
++    case ESYNC_AUTO_EVENT:
++    case ESYNC_MANUAL_EVENT:
++        ret = esync_set_event( signal );
++        break;
++    case ESYNC_MUTEX:
++        ret = esync_release_mutex( signal, NULL );
++        break;
++    default:
++        return STATUS_OBJECT_TYPE_MISMATCH;
++    }
++    if (ret) return ret;
++
++    return esync_wait_objects( 1, &wait, TRUE, alertable, timeout );
++}
++
++void esync_init(void)
++{
++    struct stat st;
++
++    if (!do_esync())
++    {
++        /* make sure the server isn't running with WINEESYNC */
++        HANDLE handle;
++        NTSTATUS ret;
++
++        ret = create_esync( 0, &handle, 0, NULL, 0, 0 );
++        if (ret != STATUS_NOT_IMPLEMENTED)
++        {
++            ERR("Server is running with WINEESYNC but this process is not, please enable WINEESYNC or restart wineserver.\n");
++            exit(1);
++        }
++
++        return;
++    }
++
++    if (stat( config_dir, &st ) == -1)
++        ERR("Cannot stat %s\n", config_dir);
++
++    if (st.st_ino != (unsigned long)st.st_ino)
++        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
++    else
++        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
++
++    if ((shm_fd = shm_open( shm_name, O_RDWR, 0644 )) == -1)
++    {
++        /* probably the server isn't running with WINEESYNC, tell the user and bail */
++        if (errno == ENOENT)
++            ERR("Failed to open esync shared memory file; make sure no stale wineserver instances are running without WINEESYNC.\n");
++        else
++            ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
++        exit(1);
++    }
++
++    pagesize = sysconf( _SC_PAGESIZE );
++
++    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
++    shm_addrs_size = 128;
++}
+diff --git a/dlls/ntdll/unix/esync.h b/dlls/ntdll/unix/esync.h
+new file mode 100644
+index 000000000000..9102cf911aa1
+--- /dev/null
++++ b/dlls/ntdll/unix/esync.h
+@@ -0,0 +1,61 @@
++/*
++ * eventfd-based synchronization objects
++ *
++ * Copyright (C) 2018 Zebediah Figura
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++extern int do_esync(void);
++extern void esync_init(void);
++extern NTSTATUS esync_close( HANDLE handle );
++
++extern NTSTATUS esync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr, int initial, int max);
++extern NTSTATUS esync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr );
++extern NTSTATUS esync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len );
++extern NTSTATUS esync_release_semaphore( HANDLE handle, unsigned int count, ULONG *prev );
++
++extern NTSTATUS esync_create_event( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
++extern NTSTATUS esync_open_event( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr );
++extern NTSTATUS esync_pulse_event( HANDLE handle );
++extern NTSTATUS esync_query_event( HANDLE handle, void *info, ULONG *ret_len );
++extern NTSTATUS esync_reset_event( HANDLE handle );
++extern NTSTATUS esync_set_event( HANDLE handle );
++
++extern NTSTATUS esync_create_mutex( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
++extern NTSTATUS esync_open_mutex( HANDLE *handle, ACCESS_MASK access,
++    const OBJECT_ATTRIBUTES *attr );
++extern NTSTATUS esync_query_mutex( HANDLE handle, void *info, ULONG *ret_len );
++extern NTSTATUS esync_release_mutex( HANDLE *handle, LONG *prev );
++
++extern NTSTATUS esync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
++                                    BOOLEAN alertable, const LARGE_INTEGER *timeout );
++extern NTSTATUS esync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
++    const LARGE_INTEGER *timeout );
++
++
++/* We have to synchronize on the fd cache mutex so that our calls to receive_fd
++ * don't race with theirs. It looks weird, I know.
++ *
++ * If we weren't trying to avoid touching the code I'd rename the mutex to
++ * "server_fd_mutex" or something similar. */
++extern pthread_mutex_t fd_cache_mutex;
++
++extern int receive_fd( obj_handle_t *handle );
+diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
+index 8bc69557057e..fa8d49b6b63e 100644
+--- a/dlls/ntdll/unix/file.c
++++ b/dlls/ntdll/unix/file.c
+@@ -36,6 +36,8 @@
+ #include <stdlib.h>
+ #include <stdint.h>
+ #include <stdio.h>
++#include <math.h>
++#include <libgen.h>
+ #include <limits.h>
+ #include <unistd.h>
+ #ifdef HAVE_MNTENT_H
+@@ -121,6 +123,7 @@
+ #include "wine/list.h"
+ #include "wine/debug.h"
+ #include "unix_private.h"
++#include "ddk/ntifs.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(file);
+ WINE_DECLARE_DEBUG_CHANNEL(winediag);
+@@ -132,6 +135,12 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
+ #undef EXT2_IOC_GETFLAGS
+ #undef EXT4_CASEFOLD_FL
+ 
++#ifndef RENAME_EXCHANGE
++#define RENAME_EXCHANGE		(1 << 1)
++#endif
++
++#define SYM_MAX (PATH_MAX-1) /* PATH_MAX includes the NUL character */
++
+ #ifdef linux
+ 
+ /* We want the real kernel dirent structure, not the libc one */
+@@ -243,6 +252,173 @@ static const BOOL is_case_sensitive = FALSE;
+ static pthread_mutex_t dir_mutex = PTHREAD_MUTEX_INITIALIZER;
+ static pthread_mutex_t mnt_mutex = PTHREAD_MUTEX_INITIALIZER;
+ 
++#ifndef HAVE_RENAMEAT2
++int renameat2( int olddirfd, const char *oldpath, int newdirfd, const char *newpath,
++               unsigned int flags )
++{
++    if (flags == 0)
++        return renameat( olddirfd, oldpath, newdirfd, newpath );
++#if defined(__NR_renameat2)
++    return syscall( __NR_renameat2, olddirfd, oldpath, newdirfd, newpath, flags );
++#elif defined(RENAME_SWAP)
++    return renameatx_np(olddirfd, oldpath, newdirfd, newpath,
++                        (flags & RENAME_EXCHANGE ? RENAME_SWAP : 0));
++#else
++    errno = ENOSYS;
++    return -1;
++#endif
++}
++#endif /* HAVE_RENAMEAT2 */
++
++static char *itoa( int i )
++{
++    static char buffer[11];
++
++    snprintf(buffer, sizeof(buffer), "%d", i);
++    return buffer;
++}
++
++/* base64url (RFC 4648 §5) encode a binary string
++ * 1) start with base64
++ * 2) replace '+' by '-' and replace '/' by '_'
++ * 3) do not add padding characters
++ * 4) do not add line separators
++ */
++static UINT encode_base64url( const char *bin, unsigned int len, char *base64 )
++{
++    UINT n = 0, x;
++    static const char base64enc[] =
++        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
++
++    while (len > 0)
++    {
++        /* first 6 bits, all from bin[0] */
++        base64[n++] = base64enc[(bin[0] & 0xfc) >> 2];
++        x = (bin[0] & 3) << 4;
++
++        /* next 6 bits, 2 from bin[0] and 4 from bin[1] */
++        if (len == 1)
++        {
++            base64[n++] = base64enc[x];
++            break;
++        }
++        base64[n++] = base64enc[x | ((bin[1] & 0xf0) >> 4)];
++        x = (bin[1] & 0x0f) << 2;
++
++        /* next 6 bits 4 from bin[1] and 2 from bin[2] */
++        if (len == 2)
++        {
++            base64[n++] = base64enc[x];
++            break;
++        }
++        base64[n++] = base64enc[x | ((bin[2] & 0xc0) >> 6)];
++
++        /* last 6 bits, all from bin [2] */
++        base64[n++] = base64enc[bin[2] & 0x3f];
++        bin += 3;
++        len -= 3;
++    }
++    base64[n] = 0;
++    return n;
++}
++
++static inline char decode_base64url_char( char c )
++{
++    if (c >= 'A' && c <= 'Z') return c - 'A';
++    if (c >= 'a' && c <= 'z') return c - 'a' + 26;
++    if (c >= '0' && c <= '9') return c - '0' + 52;
++    if (c == '-') return 62;
++    if (c == '_') return 63;
++    return 64;
++}
++
++/* decode a base64url (RFC 4648 §5) binary string
++ * 1) start with base64
++ * 2) replace '+' by '-' and replace '/' by '_'
++ * 3) do not add padding characters
++ * 4) do not add line separators
++ */
++static unsigned int decode_base64url( const char *base64, unsigned int len, char *buf )
++{
++    unsigned int i = 0;
++    char c0, c1, c2, c3;
++    const char *p = base64;
++
++    while (len > 4)
++    {
++        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
++        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
++        if ((c2 = decode_base64url_char( p[2] )) > 63) return 0;
++        if ((c3 = decode_base64url_char( p[3] )) > 63) return 0;
++
++        if (buf)
++        {
++            buf[i + 0] = (c0 << 2) | (c1 >> 4);
++            buf[i + 1] = (c1 << 4) | (c2 >> 2);
++            buf[i + 2] = (c2 << 6) |  c3;
++        }
++        len -= 4;
++        i += 3;
++        p += 4;
++    }
++    if (len == 2)
++    {
++        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
++        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
++
++        if (buf) buf[i] = (c0 << 2) | (c1 >> 4);
++        i++;
++    }
++    else if (len == 3)
++    {
++        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
++        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
++        if ((c2 = decode_base64url_char( p[2] )) > 63) return 0;
++
++        if (buf)
++        {
++            buf[i + 0] = (c0 << 2) | (c1 >> 4);
++            buf[i + 1] = (c1 << 4) | (c2 >> 2);
++        }
++        i += 2;
++    }
++    else
++    {
++        if ((c0 = decode_base64url_char( p[0] )) > 63) return 0;
++        if ((c1 = decode_base64url_char( p[1] )) > 63) return 0;
++        if ((c2 = decode_base64url_char( p[2] )) > 63) return 0;
++        if ((c3 = decode_base64url_char( p[3] )) > 63) return 0;
++
++        if (buf)
++        {
++            buf[i + 0] = (c0 << 2) | (c1 >> 4);
++            buf[i + 1] = (c1 << 4) | (c2 >> 2);
++            buf[i + 2] = (c2 << 6) |  c3;
++        }
++        i += 3;
++    }
++    return i;
++}
++
++/* create a directory and all the needed parent directories */
++static int mkdir_p( int dirfd, const char *path, mode_t mode )
++{
++    char path_tmp[PATH_MAX], *p;
++
++    strcpy( path_tmp, path );
++    for (p = path_tmp + 1; *p; p++) {
++        if (*p == '/') {
++            *p = '\0';
++            if (mkdirat( dirfd, path_tmp, mode ) != 0 && errno != EEXIST)
++                return -1;
++            *p = '/';
++        }
++    }
++    if (mkdirat( dirfd, path_tmp, mode ) != 0 && errno != EEXIST)
++        return -1;
++    return 0;
++}
++
+ /* check if a given Unicode char is OK in a DOS short name */
+ static inline BOOL is_invalid_dos_char( WCHAR ch )
+ {
+@@ -1641,6 +1817,28 @@ static int parse_samba_dos_attrib_data( char *data, int len )
+ }
+ 
+ 
++/* determine whether a reparse point is meant to be a directory or a file */
++static int is_reparse_dir( int fd, const char *path, BOOL *is_dir )
++{
++    char link_path[PATH_MAX], *p;
++    int ret;
++
++    if ((ret = readlinkat( fd, path, link_path, sizeof(link_path) )) < 0)
++        return ret;
++    /* confirm that this file is a reparse point */
++    if (strncmp( link_path, ".REPARSE_POINT/", 15) != 0)
++        return -1;
++    /* skip past the reparse point indicator and the filename */
++    p = &link_path[15];
++    if ((p = strchr( p, '/' )) == NULL)
++        return -1;
++    p++;
++    /* read the flag indicating whether this reparse point is a directory */
++    if (is_dir) *is_dir = (*p == '.');
++    return 0;
++}
++
++
+ static BOOL fd_is_mount_point( int fd, const struct stat *st )
+ {
+     struct stat parent;
+@@ -1658,6 +1856,18 @@ static int fd_get_file_info( int fd, unsigned int options, struct stat *st, ULON
+     *attr = 0;
+     ret = fstat( fd, st );
+     if (ret == -1) return ret;
++    if (S_ISLNK( st->st_mode ))
++    {
++        BOOL is_dir;
++
++        /* symbolic links (either junction points or NT symlinks) are "reparse points" */
++        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
++        /* symbolic links always report size 0 */
++        st->st_size = 0;
++        /* whether a reparse point is a file or a directory is stored inside the link target */
++        if (is_reparse_dir( fd, "", &is_dir ) == 0)
++            st->st_mode = (st->st_mode & ~S_IFMT) | (is_dir ? S_IFDIR : S_IFREG);
++    }
+     *attr |= get_file_attributes( st );
+     /* consider mount points to be reparse points (IO_REPARSE_TAG_MOUNT_POINT) */
+     if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, st ))
+@@ -1743,10 +1953,17 @@ static int get_file_info( const char *path, struct stat *st, ULONG *attr )
+     if (ret == -1) return ret;
+     if (S_ISLNK( st->st_mode ))
+     {
+-        ret = stat( path, st );
+-        if (ret == -1) return ret;
+-        /* is a symbolic link and a directory, consider these "reparse points" */
+-        if (S_ISDIR( st->st_mode )) *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
++        BOOL is_dir;
++
++        /* return information about the destination (unless this is a dangling symlink) */
++        stat( path, st );
++        /* symbolic links (either junction points or NT symlinks) are "reparse points" */
++        *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
++        /* symbolic links always report size 0 */
++        st->st_size = 0;
++        /* whether a reparse point is a file or a directory is stored inside the link target */
++        if (is_reparse_dir( AT_FDCWD, path, &is_dir ) == 0)
++            st->st_mode = (st->st_mode & ~S_IFMT) | (is_dir ? S_IFDIR : S_IFREG);
+     }
+     else if (S_ISDIR( st->st_mode ) && (parent_path = malloc( strlen(path) + 4 )))
+     {
+@@ -2802,7 +3019,7 @@ static NTSTATUS find_file_in_dir( char *unix_name, int pos, const WCHAR *name, i
+     if (ret >= 0 && ret <= MAX_DIR_ENTRY_LEN)
+     {
+         unix_name[pos + ret] = 0;
+-        if (!stat( unix_name, &st )) return STATUS_SUCCESS;
++        if (!lstat( unix_name, &st )) return STATUS_SUCCESS;
+     }
+     if (check_case) goto not_found;  /* we want an exact match */
+ 
+@@ -3416,15 +3633,698 @@ static NTSTATUS file_id_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char *
+ }
+ 
+ 
++static NTSTATUS get_reparse_target( UNICODE_STRING *nt_target, REPARSE_DATA_BUFFER *buffer,
++                                    int *is_relative )
++{
++    int target_len, offset;
++    WCHAR *target;
++
++    switch( buffer->ReparseTag )
++    {
++    case IO_REPARSE_TAG_MOUNT_POINT:
++        offset = buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR);
++        target = &buffer->MountPointReparseBuffer.PathBuffer[offset];
++        target_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
++        *is_relative = FALSE;
++        break;
++    case IO_REPARSE_TAG_SYMLINK:
++        offset = buffer->SymbolicLinkReparseBuffer.SubstituteNameOffset/sizeof(WCHAR);
++        target = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
++        target_len = buffer->SymbolicLinkReparseBuffer.SubstituteNameLength;
++        *is_relative = (buffer->SymbolicLinkReparseBuffer.Flags & SYMLINK_FLAG_RELATIVE) == SYMLINK_FLAG_RELATIVE;
++        break;
++    default:
++        return STATUS_IO_REPARSE_TAG_NOT_HANDLED;
++    }
++    nt_target->Buffer = target;
++    nt_target->Length = target_len;
++    return STATUS_REPARSE;
++}
++
++
++int find_prefix_end( const char *path, int *offset )
++{
++    static int config_dir_len = 0;
++
++    if (!config_dir_len) config_dir_len = strlen(config_dir);
++    if (path[config_dir_len] != '/') return FALSE;
++    if (strncmp( config_dir, path, config_dir_len ) != 0) return FALSE;
++    *offset = config_dir_len;
++    return TRUE;
++}
++
++
++/* add a symlink to the unix target at the last point of the reparse point metadata */
++NTSTATUS create_reparse_target( int dirfd, const char *unix_src, int depth, const char *link_path,
++                                REPARSE_DATA_BUFFER *buffer )
++{
++    ULONG nt_path_len = PATH_MAX, unix_path_len = PATH_MAX;
++    UNICODE_STRING nt_target, nt_full_target;
++    ULONG unix_target_len = PATH_MAX;
++    char *unix_path = NULL, *d;
++    char target_path[PATH_MAX];
++    OBJECT_ATTRIBUTES attr;
++    int nt_target_len;
++    char *unix_target;
++    int is_relative;
++    NTSTATUS status;
++    WCHAR *nt_path;
++
++    if ((status = get_reparse_target( &nt_target, buffer, &is_relative )) != STATUS_REPARSE)
++        return status;
++    /* if the target path is relative then turn the source path into an NT path */
++    if (is_relative)
++    {
++        UNICODE_STRING nt_path_tmp;
++
++        /* resolve the NT path of the source */
++        unix_path = malloc( strlen(unix_src) + 2 );
++        if (!unix_path) return STATUS_NO_MEMORY;
++        strcpy( unix_path, unix_src );
++        d = dirname( unix_path );
++        if (d != unix_path) strcpy( unix_path, d );
++        strcat( unix_path, "/");
++        for (;;)
++        {
++            nt_path = malloc( nt_path_len * sizeof(WCHAR) );
++            if (!nt_path)
++            {
++                free( unix_path );
++                return STATUS_NO_MEMORY;
++            }
++            status = wine_unix_to_nt_file_name( unix_path, nt_path, &nt_path_len );
++            if (status != STATUS_BUFFER_TOO_SMALL) break;
++            free( nt_path );
++        }
++        free( unix_path );
++        if (status != STATUS_SUCCESS)
++            return status;
++        /* re-resolve the unix path for the source */
++        nt_path_tmp.Buffer = nt_path;
++        nt_path_tmp.Length = wcslen(nt_path) * sizeof(WCHAR);
++        InitializeObjectAttributes( &attr, &nt_path_tmp, 0, 0, NULL );
++        for (;;)
++        {
++            unix_path = malloc( unix_path_len );
++            if (!unix_path) return STATUS_NO_MEMORY;
++            status = wine_nt_to_unix_file_name( &attr, unix_path, &unix_path_len, FILE_OPEN_IF );
++            if (status != STATUS_BUFFER_TOO_SMALL) break;
++            free( unix_path );
++        }
++    }
++    else
++    {
++        nt_path = malloc( sizeof(WCHAR) );
++        if (!nt_path) return STATUS_NO_MEMORY;
++        nt_path[0] = 0;
++    }
++    /* append the target path (if absolute, appends to empty string) */
++    nt_target_len = nt_target.Length + sizeof(WCHAR);
++    nt_full_target.MaximumLength = nt_target_len + wcslen(nt_path) * sizeof(WCHAR);
++    nt_full_target.Buffer = malloc( nt_full_target.MaximumLength + 2 );
++    if (!nt_full_target.Buffer)
++    {
++        status = STATUS_NO_MEMORY;
++        goto cleanup;
++    }
++    wcscpy( nt_full_target.Buffer, nt_path );
++    free( nt_path );
++    memcpy( &nt_full_target.Buffer[wcslen(nt_full_target.Buffer)], nt_target.Buffer, nt_target_len );
++    nt_full_target.Length = wcslen( nt_full_target.Buffer ) * sizeof(WCHAR);
++    /* find the unix path for the target */
++    InitializeObjectAttributes( &attr, &nt_full_target, 0, 0, NULL );
++    for (;;)
++    {
++        unix_target = malloc( unix_target_len );
++        if (!unix_target)
++        {
++            status = STATUS_NO_MEMORY;
++            goto cleanup;
++        }
++        status = wine_nt_to_unix_file_name( &attr, unix_target, &unix_target_len, FILE_OPEN_IF );
++        if (status != STATUS_BUFFER_TOO_SMALL) break;
++        free( unix_target );
++    }
++    /* create the symlink to the target at the last metadata location */
++    if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
++    {
++        const char prefix_string[] = "${WINEPREFIX}";
++        int append_prefix = FALSE;
++        int relative_offset;
++
++        target_path[0] = 0;
++        relative_offset = unix_path ? strlen( unix_path ) : 0;
++        if (unix_path && strncmp( unix_path, unix_target, relative_offset ) != 0)
++        {
++            relative_offset = 0;
++            is_relative = FALSE;
++        }
++        else if (find_prefix_end( unix_target, &relative_offset ))
++        {
++            char prefix_link[PATH_MAX];
++
++            append_prefix = TRUE;
++            is_relative = FALSE;
++            strcpy( prefix_link, link_path );
++            prefix_link[strlen(prefix_link)-1] = 0;
++            strcat( prefix_link, prefix_string );
++            symlinkat( config_dir, dirfd, prefix_link );
++        }
++        for (;is_relative && depth > 0; depth--)
++            strcat( target_path, "../" );
++        if (append_prefix)
++            strcat( target_path, prefix_string );
++        strcat( target_path, &unix_target[relative_offset] );
++        TRACE( "adding reparse point target: %s\n", debugstr_a(target_path) );
++        symlinkat( target_path, dirfd, link_path );
++    }
++    free( unix_target );
++    status = STATUS_SUCCESS;
++
++cleanup:
++    free( unix_path );
++    free( nt_full_target.Buffer );
++    return status;
++}
++
++
++/*
++ * Retrieve the unix name corresponding to a file handle, remove that directory, and then symlink
++ * the requested directory to the location of the old directory.
++ */
++NTSTATUS create_reparse_point(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
++{
++    int buffer_len = buffer->ReparseDataLength+FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
++    char target_path[PATH_MAX], link_path[PATH_MAX], link_dir[PATH_MAX];
++    int encoded_len = (int)ceil(buffer_len*4/3.0) + 1, chunk_len;
++    char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
++    BOOL needs_close, tempdir_created = FALSE;
++    char filename_buf[PATH_MAX], *filename;
++    char *unix_src = NULL, *encoded = NULL;
++    int i = 0, j = 0, depth = 0, fd;
++    int link_dir_fd = -1;
++    NTSTATUS status;
++    struct stat st;
++    BOOL is_dir;
++
++    if (buffer_len > 16*1024)
++        return STATUS_IO_REPARSE_DATA_INVALID;
++
++    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &fd, &needs_close, NULL, NULL )))
++        return status;
++    if (fstat( fd, &st ) == -1)
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    if ((status = server_get_unix_name( handle, &unix_src )))
++        goto cleanup;
++    is_dir = S_ISDIR( st.st_mode );
++    is_reparse_dir( AT_FDCWD, unix_src, &is_dir ); /* keep type (replace existing reparse point) */
++    encoded = malloc( encoded_len );
++    if (!encoded)
++    {
++        status = STATUS_NO_MEMORY;
++        goto cleanup;
++    }
++    encoded_len = encode_base64url( (const char *)buffer, buffer_len, encoded );
++
++    TRACE( "Linking %s to %s\n", debugstr_a(unix_src), encoded );
++    strcpy( filename_buf, unix_src );
++    filename = basename( filename_buf );
++
++    /* Create the symlink that represents the initial data in the reparse tag:
++     * *) Begin all reparse tags with the hidden folder .REPARSE_POINT.  This serves two purposes:
++     *    1) it makes it easy to identify reparse points
++     *    2) if the reparse buffer exceeds what can be stored in a single symlink (4095+1 bytes)
++     *       then we need to store additional data, so link to it and store it in a hidden folder
++     * *) Append the filename of the reparse point to the hidden folder, this ensures that if
++     *    multiple reparse points contain the same data that there is no possibility of collision
++     * *) Append a special flag to indicate whether this is a directory (./) or file (/)
++     * *) Append the base64-url encoded reparse point buffer
++     * *) Append the filename of the first continuing symlink (0) in case we need it
++     */
++    if (buffer->ReparseTag != IO_REPARSE_TAG_LX_SYMLINK)
++    {
++        strcpy( target_path, ".REPARSE_POINT/" );
++        strcat( target_path, filename );
++        strcat( target_path, "/" );
++        if (is_dir)
++            strcat( target_path, "." );
++        strcat( target_path, "/" );
++        for (depth=0; i<encoded_len && strlen(target_path)<SYM_MAX-2; i+=chunk_len, depth++)
++        {
++            chunk_len = min(NAME_MAX, SYM_MAX-2-strlen(target_path));
++            strncat( target_path, &encoded[i], chunk_len );
++            strcat( target_path, "/" );
++        }
++        strcat( target_path, itoa(j) );
++    }
++    else
++    {
++        int unix_dest_len;
++        char *unix_dest;
++
++        unix_dest_len = buffer->ReparseDataLength - sizeof(ULONG);
++        unix_dest = (char *) &buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer[0];
++        memcpy( target_path, unix_dest, unix_dest_len );
++        target_path[unix_dest_len] = 0;
++        i = encoded_len; /* no extended metadata to store */
++    }
++
++    /* Produce the link in a temporary location in the same folder */
++    strcpy( tmpdir, unix_src );
++    d = dirname( tmpdir);
++    if (d != tmpdir) strcpy( tmpdir, d );
++    strcat( tmpdir, "/.winelink.XXXXXX" );
++    if (mkdtemp( tmpdir ) == NULL)
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    tempdir_created = TRUE;
++    strcpy( tmplink, tmpdir );
++    strcat( tmplink, "/tmplink" );
++    if (symlink( target_path, tmplink ))
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++
++    /* change to the link folder so that we can build any necessary additional data */
++    strcpy( link_dir, tmpdir );
++    link_dir[strlen(link_dir)-16] = 0;
++    link_dir_fd = open( link_dir, O_RDONLY|O_DIRECTORY );
++
++    /* If there is any further information in the reparse tag then store it in the hidden folder */
++    while(i < encoded_len)
++    {
++        int fd;
++
++        j++;
++        strcpy( link_path, target_path );
++
++        target_path[0] = 0;
++        for (; depth>0; depth--)
++        {
++            strcat( target_path, "../" );
++        }
++        for (depth=0; i<encoded_len && strlen(target_path)<SYM_MAX-2; i+=chunk_len, depth++)
++        {
++            chunk_len = min(NAME_MAX, SYM_MAX-2-strlen(target_path));
++            strncat( target_path, &encoded[i], chunk_len );
++            strcat( target_path, "/" );
++        }
++        strcat( target_path, itoa(j) );
++
++        strcpy( link_dir, link_path );
++        link_dir[strlen(link_dir)-1] = 0;
++        if (mkdir_p( link_dir_fd, link_dir, 0777))
++        {
++            status = errno_to_status( errno );
++            goto cleanup;
++        }
++        if (symlinkat( target_path, link_dir_fd, link_path ))
++        {
++            status = errno_to_status( errno );
++            goto cleanup;
++        }
++        fd = openat( link_dir_fd, link_dir, O_RDONLY|O_DIRECTORY );
++        close( link_dir_fd );
++        link_dir_fd = fd;
++    }
++
++    /* create the very last link directory */
++    if (IsReparseTagNameSurrogate( buffer->ReparseTag )
++        && buffer->ReparseTag != IO_REPARSE_TAG_LX_SYMLINK)
++    {
++        strcpy( link_path, target_path );
++        strcpy( link_dir, link_path );
++        link_dir[strlen(link_dir)-1] = 0;
++        if (mkdir_p( link_dir_fd, link_dir, 0777 ) == 0)
++            create_reparse_target( link_dir_fd, unix_src, depth + 2, link_path, buffer );
++    }
++
++    /* Atomically move the initial link into position */
++    if (!renameat2( -1, tmplink, -1, unix_src, RENAME_EXCHANGE ))
++    {
++        /* success: link and folder/file have switched locations */
++        if (S_ISDIR( st.st_mode ))
++            rmdir( tmplink ); /* remove the folder (at link location) */
++        else
++            unlink( tmplink ); /* remove the file (at link location) */
++    }
++    else if (errno == ENOSYS)
++    {
++        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
++               "using unsafe exchange instead.\n" );
++        if (rmdir( unix_src ))
++        {
++            status = errno_to_status( errno );
++            goto cleanup;
++        }
++        if (rename( tmplink, unix_src ))
++        {
++            status = errno_to_status( errno );
++            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
++        }
++    }
++    else
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    status = STATUS_SUCCESS;
++
++cleanup:
++    if (link_dir_fd != -1) close( link_dir_fd );
++    if (tempdir_created) rmdir( tmpdir );
++    if (needs_close) close( fd );
++    free( unix_src );
++    free( encoded );
++
++    return status;
++}
++
++
++/*
++ * Obtain the reparse point buffer from the unix filename for the reparse point.
++ */
++NTSTATUS get_reparse_point_unix(const char *unix_name, REPARSE_DATA_BUFFER *buffer, ULONG *size)
++{
++    char link_dir[PATH_MAX], link_path[PATH_MAX], *d;
++    const char prefix_string[] = "${WINEPREFIX}";
++    int link_path_len, buffer_len, encoded_len;
++    REPARSE_DATA_BUFFER header;
++    ULONG out_size = *size;
++    char *encoded = NULL;
++    int link_dir_fd = -1;
++    NTSTATUS status;
++    ssize_t ret;
++    int depth;
++    char *p;
++
++    ret = readlink( unix_name, link_path, sizeof(link_path) );
++
++    if (ret < 0)
++    {
++        if (errno == EINVAL) status = STATUS_NOT_A_REPARSE_POINT;
++        else status = errno_to_status( errno );
++        goto cleanup;
++    }
++    link_path_len = ret;
++    link_path[link_path_len] = 0;
++    if (strncmp( link_path, ".REPARSE_POINT/", 15 ) != 0)
++    {
++        /* treat regular Unix symlinks as WSL Linux/Unix symlinks */
++        *size = FIELD_OFFSET(typeof(*buffer), LinuxSymbolicLinkReparseBuffer.PathBuffer[link_path_len]);
++        if (*size > out_size) { status = STATUS_BUFFER_TOO_SMALL; goto cleanup; }
++        buffer->ReparseTag = IO_REPARSE_TAG_LX_SYMLINK;
++        buffer->LinuxSymbolicLinkReparseBuffer.Version = 2;
++        memcpy( &buffer->LinuxSymbolicLinkReparseBuffer.PathBuffer[0], link_path, link_path_len );
++        buffer->ReparseDataLength = *size - FIELD_OFFSET(typeof(*buffer), GenericReparseBuffer);
++        status = STATUS_SUCCESS;
++        goto cleanup;
++    }
++    encoded_len = link_path_len;
++    encoded = malloc( encoded_len );
++    if (!encoded)
++    {
++        status = STATUS_NO_MEMORY;
++        goto cleanup;
++    }
++
++    /* Copy the encoded data from the inital symlink */
++    encoded[0] = 0;
++    p = &link_path[15];
++    if ((p = strchr( p, '/' )) == NULL)
++    {
++        status = STATUS_IO_REPARSE_DATA_INVALID;
++        goto cleanup;
++    }
++    p++;
++    if (*(p++) == '.')
++        p++;
++    for (depth=0; p < link_path + link_path_len; p += NAME_MAX+1, depth++)
++        strncat( encoded, p, NAME_MAX );
++    encoded[strlen(encoded)-1] = 0; /* chunk id */
++    encoded[strlen(encoded)-1] = 0; /* final slash */
++
++    /* get the length of the full buffer so that we know when to stop collecting data */
++    decode_base64url( encoded, sizeof(header), (char*)&header );
++    buffer_len = header.ReparseDataLength+FIELD_OFFSET(typeof(header), GenericReparseBuffer);
++    *size = buffer_len;
++
++    if (buffer_len > out_size)
++    {
++        status = STATUS_BUFFER_TOO_SMALL;
++        goto cleanup;
++    }
++    encoded_len = (int)ceil(buffer_len*4/3.0);
++    encoded = realloc( encoded, encoded_len + 3 ); /* 3 chars = slash, chunk ID, NUL character */
++    if (!encoded)
++    {
++        status = STATUS_NO_MEMORY;
++        goto cleanup;
++    }
++
++    /* change to the link folder so that we can build any necessary additional data */
++    strcpy( link_dir, unix_name );
++    d = dirname( link_dir);
++    if (d != link_dir) strcpy( link_dir, d );
++    link_dir_fd = open( link_dir, O_RDONLY|O_DIRECTORY );
++
++    /* Copy the encoded data from the follow on symlinks */
++    while(strlen(encoded) < encoded_len)
++    {
++        int fd;
++
++        strcpy( link_dir, link_path );
++        ret = readlinkat( link_dir_fd, link_dir, link_path, sizeof(link_path) );
++        if (ret < 0)
++        {
++            status = errno_to_status( errno );
++            goto cleanup;
++        }
++        link_path_len = ret;
++        link_path[link_path_len] = 0; /* readlink does not NUL terminate */
++
++        p = &link_path[3*depth];
++        for (depth=0; p < link_path + link_path_len; p += NAME_MAX+1, depth++)
++            strncat( encoded, p, NAME_MAX );
++        encoded[strlen(encoded)-1] = 0; /* chunk id */
++        encoded[strlen(encoded)-1] = 0; /* final slash */
++
++        link_dir[strlen(link_dir)-1] = 0;
++        fd = openat( link_dir_fd, link_dir, O_RDONLY|O_DIRECTORY );
++        close( link_dir_fd );
++        link_dir_fd = fd;
++    }
++
++    /* if the prefix location has moved then update the Unix prefix passthrough link */
++    strcpy( link_dir, link_path );
++    link_dir[strlen(link_dir)-1] = 0;
++    link_path_len = readlinkat( link_dir_fd, prefix_string, link_path, sizeof(link_path) );
++    if (link_path_len > 0) link_path[link_path_len] = 0;
++    if (link_path_len > 0 && strcmp( config_dir, link_path) != 0)
++    {
++        unlinkat( link_dir_fd, prefix_string, 0 );
++        symlinkat( config_dir, link_dir_fd, prefix_string );
++    }
++
++    /* Decode the reparse buffer from the base64-encoded symlink data */
++    *size = decode_base64url( encoded, strlen(encoded), (char*)buffer );
++    status = STATUS_SUCCESS;
++    if (buffer_len != *size)
++    {
++        status = STATUS_IO_REPARSE_DATA_INVALID;
++        ERR("Size mismatch decoding reparse point buffer (%d != %d)\n", *size, buffer_len);
++    }
++
++cleanup:
++    if (link_dir_fd != -1) close( link_dir_fd );
++    free( encoded );
++    return status;
++}
++
++
++/*
++ * Retrieve the unix name corresponding to a file handle and use that to find the destination of the
++ * symlink corresponding to that file handle.
++ */
++NTSTATUS get_reparse_point(HANDLE handle, REPARSE_DATA_BUFFER *buffer, ULONG *size)
++{
++    char *unix_name = NULL;
++    NTSTATUS status;
++
++    if ((status = server_get_unix_name( handle, &unix_name )))
++        return status;
++    status = get_reparse_point_unix( unix_name, buffer, size );
++    free( unix_name );
++    return status;
++}
++
++
++/* find the NT target of a reparse point */
++static NTSTATUS find_reparse_target( const char *unix_name, const WCHAR *parent, int parent_len,
++                                     WCHAR **new_name, int *new_name_len)
++{
++    REPARSE_DATA_BUFFER *buffer = NULL;
++    UNICODE_STRING nt_target;
++    ULONG buffer_len = 0;
++    int is_relative;
++    NTSTATUS status;
++
++    status = get_reparse_point_unix( unix_name, NULL, &buffer_len );
++    if (status != STATUS_BUFFER_TOO_SMALL)
++        return status;
++
++    buffer = malloc( buffer_len );
++    if (!buffer)
++        return STATUS_NO_MEMORY;
++    if ((status = get_reparse_point_unix( unix_name, buffer, &buffer_len )) != STATUS_SUCCESS)
++    {
++        free( buffer );
++        return status;
++    }
++    if ((status = get_reparse_target( &nt_target, buffer, &is_relative )) == STATUS_REPARSE)
++    {
++        WCHAR *p;
++
++        p = *new_name = malloc( nt_target.Length + parent_len*sizeof(WCHAR) );
++        if (!p)
++        {
++            status = STATUS_NO_MEMORY;
++            goto done;
++        }
++        if (is_relative)
++        {
++            memcpy( p, parent, parent_len*sizeof(WCHAR) );
++            p += parent_len;
++        }
++        memcpy( p, nt_target.Buffer, nt_target.Length );
++        p += nt_target.Length/sizeof(WCHAR);
++        *new_name_len = p - *new_name;
++    }
++
++done:
++    free( buffer );
++    return status;
++}
++
++
++/*
++ * Retrieve the unix name corresponding to a file handle, remove that symlink, and then recreate
++ * a directory at the location of the old filename.
++ */
++NTSTATUS remove_reparse_point(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
++{
++    char tmpdir[PATH_MAX], tmplink[PATH_MAX], *d;
++    BOOL tempdir_created = FALSE;
++    int dest_fd, needs_close;
++    BOOL is_dir = TRUE;
++    NTSTATUS status;
++    char *unix_name;
++    struct stat st;
++
++    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
++        return status;
++
++    if ((status = server_get_unix_name( handle, &unix_name )))
++        goto cleanup;
++
++    TRACE( "Deleting symlink %s\n", unix_name );
++
++    /* Produce the file/directory in a temporary location in the same folder */
++    if (fstat( dest_fd, &st ) == -1)
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    is_dir = S_ISDIR(st.st_mode);
++    strcpy( tmpdir, unix_name );
++    d = dirname( tmpdir);
++    if (d != tmpdir) strcpy( tmpdir, d );
++    strcat( tmpdir, "/.winelink.XXXXXX" );
++    if (mkdtemp( tmpdir ) == NULL)
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    tempdir_created = TRUE;
++    strcpy( tmplink, tmpdir );
++    strcat( tmplink, "/tmplink" );
++    if (is_dir && mkdir( tmplink, st.st_mode ))
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    else if (!is_dir)
++    {
++        int fd = open( tmplink, O_CREAT|O_WRONLY|O_TRUNC, st.st_mode );
++        if (fd < 0)
++        {
++            status = errno_to_status( errno );
++            goto cleanup;
++        }
++        close( fd );
++    }
++    /* attemp to retain the ownership (if possible) */
++    lchown( tmplink, st.st_uid, st.st_gid );
++    /* Atomically move the directory into position */
++    if (!renameat2( -1, tmplink, -1, unix_name, RENAME_EXCHANGE ))
++    {
++        /* success: link and folder/file have switched locations */
++        unlink( tmplink ); /* remove the file (at link location) */
++    }
++    else if (errno == ENOSYS)
++    {
++        FIXME( "Atomic exchange of directory with symbolic link unsupported on this system, "
++               "using unsafe exchange instead.\n" );
++        if (unlink( unix_name ))
++        {
++            status = errno_to_status( errno );
++            goto cleanup;
++        }
++        if (rename( tmplink, unix_name ))
++        {
++            status = errno_to_status( errno );
++            goto cleanup; /* not moved, orignal file/folder at destination is orphaned */
++        }
++    }
++    else
++    {
++        status = errno_to_status( errno );
++        goto cleanup;
++    }
++    status = STATUS_SUCCESS;
++
++cleanup:
++    if (tempdir_created) rmdir( tmpdir );
++    if (needs_close) close( dest_fd );
++    return status;
++}
++
++
++static NTSTATUS IoReplaceFileObjectName( FILE_OBJECT *fileobj, PWSTR name, USHORT name_len )
++{
++    fileobj->FileName.Buffer = name;
++    fileobj->FileName.Length = name_len;
++    return STATUS_SUCCESS;
++}
++
++
+ /******************************************************************************
+  *           lookup_unix_name
+  *
+  * Helper for nt_to_unix_file_name
+  */
+-static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer, int unix_len, int pos,
+-                                  UINT disposition, BOOL is_unix )
++static NTSTATUS lookup_unix_name( FILE_OBJECT *fileobj, const WCHAR *name, int name_len,
++                                  char **buffer, int unix_len, int pos, UINT disposition,
++                                  BOOL is_unix )
+ {
+     static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, '/', 0 };
++    const WCHAR *fullname = fileobj->FileName.Buffer;
+     NTSTATUS status;
+     int ret;
+     struct stat st;
+@@ -3464,7 +4364,7 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
+         char *p;
+         unix_name[pos + 1 + ret] = 0;
+         for (p = unix_name + pos ; *p; p++) if (*p == '\\') *p = '/';
+-        if (!stat( unix_name, &st ))
++        if (!lstat( unix_name, &st ))
+         {
+             if (disposition == FILE_CREATE) return STATUS_OBJECT_NAME_COLLISION;
+             return STATUS_SUCCESS;
+@@ -3481,6 +4381,8 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
+     while (name_len)
+     {
+         const WCHAR *end, *next;
++        WCHAR *target = NULL;
++        int target_len = 0;
+ 
+         end = name;
+         while (end < name + name_len && *end != '\\') end++;
+@@ -3500,8 +4402,31 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
+ 
+         status = find_file_in_dir( unix_name, pos, name, end - name, is_unix );
+ 
++        /* follow reparse point and restart from there (if applicable) */
++        if (name_len && find_reparse_target( unix_name, fullname, name - fullname, &target, &target_len ) == STATUS_REPARSE)
++        {
++            int new_name_len = target_len + name_len + 1;
++            WCHAR *p, *new_name;
++
++            if (!(p = new_name = malloc( new_name_len*sizeof(WCHAR) )))
++            {
++                free( target );
++                status = STATUS_NO_MEMORY;
++                break;
++            }
++            memcpy( p, target, target_len*sizeof(WCHAR) );
++            p += target_len;
++            (p++)[0] = '\\';
++            memcpy( p, next, name_len*sizeof(WCHAR) );
++            TRACE( "Follow reparse point %s => %s\n", debugstr_wn(fullname, end-fullname),
++                                                      debugstr_wn(new_name, new_name_len) );
++            free( target );
++            if (IoReplaceFileObjectName( fileobj, new_name, new_name_len*sizeof(WCHAR) ))
++                free( new_name );
++            return STATUS_REPARSE;
++        }
+         /* if this is the last element, not finding it is not necessarily fatal */
+-        if (!name_len)
++        else if (!name_len)
+         {
+             if (status == STATUS_OBJECT_NAME_NOT_FOUND)
+             {
+@@ -3540,12 +4465,12 @@ static NTSTATUS lookup_unix_name( const WCHAR *name, int name_len, char **buffer
+ /******************************************************************************
+  *           nt_to_unix_file_name_no_root
+  */
+-static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char **unix_name_ret,
++static NTSTATUS nt_to_unix_file_name_no_root( FILE_OBJECT *fileobj, char **unix_name_ret,
+                                               UINT disposition )
+ {
+     static const WCHAR unixW[] = {'u','n','i','x'};
+     static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
+-
++    const UNICODE_STRING *nameW = &fileobj->FileName;
+     NTSTATUS status = STATUS_SUCCESS;
+     const WCHAR *name;
+     struct stat st;
+@@ -3635,7 +4560,7 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
+     name += prefix_len;
+     name_len -= prefix_len;
+ 
+-    status = lookup_unix_name( name, name_len, &unix_name, unix_len, pos, disposition, is_unix );
++    status = lookup_unix_name( fileobj, name, name_len, &unix_name, unix_len, pos, disposition, is_unix );
+     if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+     {
+         TRACE( "%s -> %s\n", debugstr_us(nameW), debugstr_a(unix_name) );
+@@ -3643,7 +4568,8 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
+     }
+     else
+     {
+-        TRACE( "%s not found in %s\n", debugstr_w(name), debugstr_an(unix_name, pos) );
++        if (status != STATUS_REPARSE)
++            TRACE( "%s not found in %s\n", debugstr_w(name), debugstr_an(unix_name, pos) );
+         free( unix_name );
+     }
+     return status;
+@@ -3661,18 +4587,30 @@ static NTSTATUS nt_to_unix_file_name_no_root( const UNICODE_STRING *nameW, char
+  */
+ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, UINT disposition )
+ {
++    HANDLE rootdir = attr->RootDirectory;
+     enum server_fd_type type;
+     int old_cwd, root_fd, needs_close;
++    int reparse_count = 0;
++    FILE_OBJECT fileobj;
+     const WCHAR *name;
+     char *unix_name;
+     int name_len, unix_len;
+     NTSTATUS status;
+ 
+-    if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
+-        return nt_to_unix_file_name_no_root( attr->ObjectName, name_ret, disposition );
++    fileobj.FileName = *attr->ObjectName;
++reparse:
++    if (reparse_count++ == 31)
++        return STATUS_REPARSE_POINT_NOT_RESOLVED;
++    if (!rootdir) /* without root dir fall back to normal lookup */
++    {
++        status = nt_to_unix_file_name_no_root( &fileobj, name_ret, disposition );
++        if (status == STATUS_REPARSE) goto reparse;
++        if (fileobj.FileName.Buffer != attr->ObjectName->Buffer) free( fileobj.FileName.Buffer);
++        return status;
++    }
+ 
+-    name     = attr->ObjectName->Buffer;
+-    name_len = attr->ObjectName->Length / sizeof(WCHAR);
++    name     = fileobj.FileName.Buffer;
++    name_len = fileobj.FileName.Length / sizeof(WCHAR);
+ 
+     if (name_len && name[0] == '\\') return STATUS_INVALID_PARAMETER;
+ 
+@@ -3680,7 +4618,7 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
+     if (!(unix_name = malloc( unix_len ))) return STATUS_NO_MEMORY;
+     unix_name[0] = '.';
+ 
+-    if (!(status = server_get_unix_fd( attr->RootDirectory, 0, &root_fd, &needs_close, &type, NULL )))
++    if (!(status = server_get_unix_fd( rootdir, 0, &root_fd, &needs_close, &type, NULL )))
+     {
+         if (type != FD_TYPE_DIR)
+         {
+@@ -3692,7 +4630,8 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
+             mutex_lock( &dir_mutex );
+             if ((old_cwd = open( ".", O_RDONLY )) != -1 && fchdir( root_fd ) != -1)
+             {
+-                status = lookup_unix_name( name, name_len, &unix_name, unix_len, 1, disposition, FALSE );
++                status = lookup_unix_name( &fileobj, name, name_len, &unix_name, unix_len, 1,
++                                           disposition, FALSE );
+                 if (fchdir( old_cwd ) == -1) chdir( "/" );
+             }
+             else status = errno_to_status( errno );
+@@ -3705,14 +4644,22 @@ NTSTATUS nt_to_unix_file_name( const OBJECT_ATTRIBUTES *attr, char **name_ret, U
+ 
+     if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+     {
+-        TRACE( "%s -> %s\n", debugstr_us(attr->ObjectName), debugstr_a(unix_name) );
++        TRACE( "%s -> %s\n", debugstr_us(&fileobj.FileName), debugstr_a(unix_name) );
+         *name_ret = unix_name;
+     }
++    else if (status == STATUS_REPARSE)
++    {
++        if (fileobj.FileName.Buffer[0] == '\\') rootdir = 0;
++        free( unix_name );
++        goto reparse;
++    }
+     else
+     {
+         TRACE( "%s not found in %s\n", debugstr_w(name), unix_name );
+         free( unix_name );
+     }
++
++    if (fileobj.FileName.Buffer != attr->ObjectName->Buffer) free( fileobj.FileName.Buffer);
+     return status;
+ }
+ 
+@@ -4583,7 +5530,20 @@ NTSTATUS WINAPI NtQueryInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+         {
+             FILE_ATTRIBUTE_TAG_INFORMATION *info = ptr;
+             info->FileAttributes = attr;
+-            info->ReparseTag = 0; /* FIXME */
++            info->ReparseTag = 0;
++            if (attr & FILE_ATTRIBUTE_REPARSE_POINT)
++            {
++                REPARSE_DATA_BUFFER *buffer = NULL;
++                ULONG buffer_len = 0;
++
++                if (get_reparse_point( handle, NULL, &buffer_len ) == STATUS_BUFFER_TOO_SMALL)
++                {
++                    buffer = malloc( buffer_len );
++                    if (get_reparse_point( handle, buffer, &buffer_len ) == STATUS_SUCCESS)
++                        info->ReparseTag = buffer->ReparseTag;
++                    free( buffer );
++                }
++            }
+             if ((options & FILE_OPEN_REPARSE_POINT) && fd_is_mount_point( fd, &st ))
+                 info->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+         }
+@@ -4861,8 +5821,10 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+         {
+             FILE_RENAME_INFORMATION *info = ptr;
+             unsigned int flags;
++            REPARSE_DATA_BUFFER *buffer = NULL;
+             UNICODE_STRING name_str, redir;
+             OBJECT_ATTRIBUTES attr;
++            ULONG buffer_len = 0;
+             char *unix_name;
+ 
+             if (class == FileRenameInformation)
+@@ -4879,6 +5841,19 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+             InitializeObjectAttributes( &attr, &name_str, OBJ_CASE_INSENSITIVE, info->RootDirectory, NULL );
+             get_redirect( &attr, &redir );
+ 
++            /* obtain all the data from the reparse point (if applicable) */
++            status = get_reparse_point( handle, NULL, &buffer_len );
++            if (status == STATUS_BUFFER_TOO_SMALL)
++            {
++                buffer = malloc( buffer_len );
++                status = get_reparse_point( handle, buffer, &buffer_len );
++                if (status != STATUS_SUCCESS)
++                {
++                    free( buffer );
++                    break;
++                }
++            }
++
+             status = nt_to_unix_file_name( &attr, &unix_name, FILE_OPEN_IF );
+             if (status == STATUS_SUCCESS || status == STATUS_NO_SUCH_FILE)
+             {
+@@ -4895,9 +5870,14 @@ NTSTATUS WINAPI NtSetInformationFile( HANDLE handle, IO_STATUS_BLOCK *io,
+                 }
+                 SERVER_END_REQ;
+ 
++                /* rebuild reparse point in new location (if applicable) */
++                if (buffer && status == STATUS_SUCCESS)
++                    status = create_reparse_point( handle, buffer );
++
+                 free( unix_name );
+             }
+             free( redir.Buffer );
++            free( buffer );
+         }
+         else status = STATUS_INVALID_PARAMETER_3;
+         break;
+@@ -5552,6 +6532,11 @@ NTSTATUS WINAPI NtReadFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, vo
+         if (needs_close) close( unix_handle );
+         return status;
+     }
++    else if (type == FD_TYPE_SYMLINK)
++    {
++        status = STATUS_SUCCESS;
++        goto done;
++    }
+ 
+     if (type == FD_TYPE_SERIAL && async_read && length)
+     {
+@@ -6216,15 +7201,6 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
+         break;
+     }
+ 
+-    case FSCTL_GET_REPARSE_POINT:
+-        if (out_buffer && out_size)
+-        {
+-            FIXME("FSCTL_GET_REPARSE_POINT semi-stub\n");
+-            status = STATUS_NOT_A_REPARSE_POINT;
+-        }
+-        else status = STATUS_INVALID_USER_BUFFER;
+-        break;
+-
+     case FSCTL_GET_OBJECT_ID:
+     {
+         FILE_OBJECTID_BUFFER *info = out_buffer;
+@@ -6246,6 +7222,34 @@ NTSTATUS WINAPI NtFsControlFile( HANDLE handle, HANDLE event, PIO_APC_ROUTINE ap
+         break;
+     }
+ 
++    case FSCTL_DELETE_REPARSE_POINT:
++    {
++        REPARSE_GUID_DATA_BUFFER *buffer = (REPARSE_GUID_DATA_BUFFER *)in_buffer;
++        status = remove_reparse_point( handle, buffer );
++        break;
++    }
++    case FSCTL_GET_REPARSE_POINT:
++    {
++        io->Information = 0;
++        if (out_buffer){
++            REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)out_buffer;
++            ULONG size = out_size;
++            status = get_reparse_point( handle, buffer, &size );
++            if (status == STATUS_SUCCESS)
++                io->Information = size;
++        }
++        else {
++            status = STATUS_INVALID_USER_BUFFER;
++        }
++        break;
++    }
++    case FSCTL_SET_REPARSE_POINT:
++    {
++        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)in_buffer;
++        status = create_reparse_point( handle, buffer );
++        break;
++    }
++
+     case FSCTL_SET_SPARSE:
+         TRACE("FSCTL_SET_SPARSE: Ignoring request\n");
+         status = STATUS_SUCCESS;
+diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
+index 7011cbd8e0f4..7d27559e48d6 100644
+--- a/dlls/ntdll/unix/loader.c
++++ b/dlls/ntdll/unix/loader.c
+@@ -87,6 +87,7 @@
+ #include "winioctl.h"
+ #include "winternl.h"
+ #include "unix_private.h"
++#include "esync.h"
+ #include "wine/list.h"
+ #include "ntsyscalls.h"
+ #include "wine/debug.h"
+@@ -1855,6 +1856,7 @@ static void start_main_thread(void)
+     signal_alloc_thread( teb );
+     dbg_init();
+     startup_info_size = server_init_process();
++    esync_init();
+     virtual_map_user_shared_data();
+     init_cpu_info();
+     init_files();
+diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
+index 234d0777772d..e79269ecb3d5 100644
+--- a/dlls/ntdll/unix/server.c
++++ b/dlls/ntdll/unix/server.c
+@@ -79,6 +79,7 @@
+ #include "wine/server.h"
+ #include "wine/debug.h"
+ #include "unix_private.h"
++#include "esync.h"
+ #include "ddk/wdm.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(server);
+@@ -103,7 +104,7 @@ sigset_t server_block_set;  /* signals to block during server calls */
+ static int fd_socket = -1;  /* socket to exchange file descriptors with the server */
+ static int initial_cwd = -1;
+ static pid_t server_pid;
+-static pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
++pthread_mutex_t fd_cache_mutex = PTHREAD_MUTEX_INITIALIZER;
+ 
+ /* atomically exchange a 64-bit value */
+ static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
+@@ -932,7 +933,7 @@ void wine_server_send_fd( int fd )
+  *
+  * Receive a file descriptor passed from the server.
+  */
+-static int receive_fd( obj_handle_t *handle )
++int receive_fd( obj_handle_t *handle )
+ {
+     struct iovec vec;
+     struct msghdr msghdr;
+@@ -1875,6 +1876,9 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
+      * retrieve it again */
+     fd = remove_fd_from_cache( handle );
+ 
++    if (do_esync())
++        esync_close( handle );
++
+     SERVER_START_REQ( close_handle )
+     {
+         req->handle = wine_server_obj_handle( handle );
+diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
+index d486b50001dc..75525f34bf76 100644
+--- a/dlls/ntdll/unix/sync.c
++++ b/dlls/ntdll/unix/sync.c
+@@ -66,6 +66,7 @@
+ #include "wine/server.h"
+ #include "wine/debug.h"
+ #include "unix_private.h"
++#include "esync.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(sync);
+ 
+@@ -315,6 +316,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
+     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
+     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+ 
++    if (do_esync())
++        return esync_create_semaphore( handle, access, attr, initial, max );
++
+     SERVER_START_REQ( create_semaphore )
+     {
+         req->access  = access;
+@@ -339,6 +343,10 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
+     unsigned int ret;
+ 
+     *handle = 0;
++
++    if (do_esync())
++        return esync_open_semaphore( handle, access, attr );
++
+     if ((ret = validate_open_object_attributes( attr ))) return ret;
+ 
+     SERVER_START_REQ( open_semaphore )
+@@ -375,6 +383,9 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
+ 
+     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+ 
++    if (do_esync())
++        return esync_query_semaphore( handle, info, ret_len );
++
+     SERVER_START_REQ( query_semaphore )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -397,6 +408,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
+ {
+     unsigned int ret;
+ 
++    if (do_esync())
++        return esync_release_semaphore( handle, count, previous );
++
+     SERVER_START_REQ( release_semaphore )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -423,6 +437,10 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
+ 
+     *handle = 0;
+     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
++
++    if (do_esync())
++        return esync_create_event( handle, access, attr, type, state );
++
+     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+ 
+     SERVER_START_REQ( create_event )
+@@ -451,6 +469,9 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
+     *handle = 0;
+     if ((ret = validate_open_object_attributes( attr ))) return ret;
+ 
++    if (do_esync())
++        return esync_open_event( handle, access, attr );
++
+     SERVER_START_REQ( open_event )
+     {
+         req->access     = access;
+@@ -471,8 +492,12 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
+  */
+ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
+ {
++    /* This comment is a dummy to make sure this patch applies in the right place. */
+     unsigned int ret;
+ 
++    if (do_esync())
++        return esync_set_event( handle );
++
+     SERVER_START_REQ( event_op )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -490,8 +515,13 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
+  */
+ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
+ {
++    /* This comment is a dummy to make sure this patch applies in the right place. */
+     unsigned int ret;
+ 
++    if (do_esync())
++        return esync_reset_event( handle );
++
++
+     SERVER_START_REQ( event_op )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -521,6 +551,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
+ {
+     unsigned int ret;
+ 
++    if (do_esync())
++        return esync_pulse_event( handle );
++
+     SERVER_START_REQ( event_op )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -552,6 +585,9 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
+ 
+     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+ 
++    if (do_esync())
++        return esync_query_event( handle, info, ret_len );
++
+     SERVER_START_REQ( query_event )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -578,6 +614,10 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
+     struct object_attributes *objattr;
+ 
+     *handle = 0;
++
++    if (do_esync())
++        return esync_create_mutex( handle, access, attr, owned );
++
+     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+ 
+     SERVER_START_REQ( create_mutex )
+@@ -605,6 +645,9 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
+     *handle = 0;
+     if ((ret = validate_open_object_attributes( attr ))) return ret;
+ 
++    if (do_esync())
++        return esync_open_mutex( handle, access, attr );
++
+     SERVER_START_REQ( open_mutex )
+     {
+         req->access  = access;
+@@ -627,6 +670,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
+ {
+     unsigned int ret;
+ 
++    if (do_esync())
++        return esync_release_mutex( handle, prev_count );
++
+     SERVER_START_REQ( release_mutex )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -657,6 +703,9 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
+ 
+     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
+ 
++    if (do_esync())
++        return esync_query_mutex( handle, info, ret_len );
++
+     SERVER_START_REQ( query_mutex )
+     {
+         req->handle = wine_server_obj_handle( handle );
+@@ -1577,6 +1626,13 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
+ 
+     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
+ 
++    if (do_esync())
++    {
++        NTSTATUS ret = esync_wait_objects( count, handles, wait_any, alertable, timeout );
++        if (ret != STATUS_NOT_IMPLEMENTED)
++            return ret;
++    }
++
+     if (alertable) flags |= SELECT_ALERTABLE;
+     select_op.wait.op = wait_any ? SELECT_WAIT : SELECT_WAIT_ALL;
+     for (i = 0; i < count; i++) select_op.wait.handles[i] = wine_server_obj_handle( handles[i] );
+@@ -1602,6 +1658,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
+     union select_op select_op;
+     UINT flags = SELECT_INTERRUPTIBLE;
+ 
++    if (do_esync())
++        return esync_signal_and_wait( signal, wait, alertable, timeout );
++
+     if (!signal) return STATUS_INVALID_HANDLE;
+ 
+     if (alertable) flags |= SELECT_ALERTABLE;
+diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
+index f840045f8419..d9482485bf3d 100644
+--- a/dlls/ntdll/unix/unix_private.h
++++ b/dlls/ntdll/unix/unix_private.h
+@@ -103,6 +103,7 @@ struct ntdll_thread_data
+ {
+     void              *cpu_data[16];  /* reserved for CPU-specific data */
+     void              *kernel_stack;  /* stack for thread startup and kernel syscalls */
++    int                esync_apc_fd;  /* fd to wait on for user APCs */
+     int                request_fd;    /* fd for sending server requests */
+     int                reply_fd;      /* fd for receiving server replies */
+     int                wait_fd[2];    /* fd for sleeping server requests */
+diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
+index 0c0a12c394df..ab90c0f1000a 100644
+--- a/dlls/ntdll/unix/virtual.c
++++ b/dlls/ntdll/unix/virtual.c
+@@ -3685,6 +3685,7 @@ static TEB *init_teb( void *ptr, BOOL is_wow )
+     teb->StaticUnicodeString.Buffer = teb->StaticUnicodeBuffer;
+     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
+     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
++    thread_data->esync_apc_fd = -1;
+     thread_data->request_fd = -1;
+     thread_data->reply_fd   = -1;
+     thread_data->wait_fd[0] = -1;
+diff --git a/dlls/rpcrt4/rpc_server.c b/dlls/rpcrt4/rpc_server.c
+index eb733f699808..02193b862ba6 100644
+--- a/dlls/rpcrt4/rpc_server.c
++++ b/dlls/rpcrt4/rpc_server.c
+@@ -701,10 +701,6 @@ static DWORD CALLBACK RPCRT4_server_thread(LPVOID the_arg)
+   }
+   LeaveCriticalSection(&cps->cs);
+ 
+-  EnterCriticalSection(&listen_cs);
+-  CloseHandle(cps->server_thread);
+-  cps->server_thread = NULL;
+-  LeaveCriticalSection(&listen_cs);
+   TRACE("done\n");
+   return 0;
+ }
+@@ -1570,7 +1566,10 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
+       LIST_FOR_EACH_ENTRY(protseq, &protseqs, RpcServerProtseq, entry)
+       {
+           if ((wait_thread = protseq->server_thread))
++          {
++              protseq->server_thread = NULL;
+               break;
++          }
+       }
+       LeaveCriticalSection(&server_cs);
+       if (!wait_thread)
+@@ -1579,6 +1578,7 @@ RPC_STATUS WINAPI RpcMgmtWaitServerListen( void )
+       TRACE("waiting for thread %lu\n", GetThreadId(wait_thread));
+       LeaveCriticalSection(&listen_cs);
+       WaitForSingleObject(wait_thread, INFINITE);
++      CloseHandle(wait_thread);
+       EnterCriticalSection(&listen_cs);
+   }
+   if (listen_done_event == event)
+diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
+index baad938b6c73..d6c946c026d4 100644
+--- a/dlls/user32/tests/msg.c
++++ b/dlls/user32/tests/msg.c
+@@ -14420,13 +14420,10 @@ static void test_PeekMessage3(void)
+     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     PostMessageA(hwnd, WM_USER, 0, 0);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, PM_NOREMOVE);
+-    todo_wine
+     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+-    todo_wine
+     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+-    todo_wine
+     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
+     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
+@@ -14436,10 +14433,8 @@ static void test_PeekMessage3(void)
+     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     PostMessageA(hwnd, WM_USER, 0, 0);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, PM_REMOVE);
+-    todo_wine
+     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, PM_REMOVE);
+-    todo_wine
+     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
+     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
+@@ -14451,10 +14446,11 @@ static void test_PeekMessage3(void)
+     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     PostMessageA(hwnd, WM_USER, 0, 0);
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+-    todo_wine
+     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+-    todo_wine
++    ret = GetMessageA(&msg, NULL, 0, 0);
++    ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
++    ret = GetMessageA(&msg, NULL, 0, 0);
+     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
+     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
+@@ -14482,14 +14478,32 @@ static void test_PeekMessage3(void)
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+-    todo_wine
+     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
+     ret = GetMessageA(&msg, hwnd, 0, 0);
+-    todo_wine
+     ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
+     ret = PeekMessageA(&msg, hwnd, 0, 0, 0);
+     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
+ 
++    /* Newer messages are still returned when specifying a message range. */
++
++    SetTimer(hwnd, 1, 0, NULL);
++    while (!PeekMessageA(&msg, NULL, WM_TIMER, WM_TIMER, PM_NOREMOVE));
++    ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
++    PostMessageA(hwnd, WM_USER + 1, 0, 0);
++    PostMessageA(hwnd, WM_USER, 0, 0);
++    ret = PeekMessageA(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);
++    ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
++    ret = PeekMessageA(&msg, NULL, WM_USER, WM_USER + 1, PM_NOREMOVE);
++    ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
++    ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
++    ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
++    ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
++    ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
++    ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
++    ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
++    ret = PeekMessageA(&msg, NULL, 0, 0, 0);
++    ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
++
+     /* Also works for posted messages, but the situation is a bit different,
+      * because both messages are in the same queue. */
+ 
+diff --git a/include/config.h.in b/include/config.h.in
+index 84c43d2cced4..2598fd1e16de 100644
+--- a/include/config.h.in
++++ b/include/config.h.in
+@@ -321,6 +321,9 @@
+ /* Define to 1 if you have the 'posix_fallocate' function. */
+ #undef HAVE_POSIX_FALLOCATE
+ 
++/* Define to 1 if you have the 'ppoll' function. */
++#undef HAVE_PPOLL
++
+ /* Define to 1 if you have the 'prctl' function. */
+ #undef HAVE_PRCTL
+ 
+@@ -333,6 +336,12 @@
+ /* Define to 1 if you have the <pwd.h> header file. */
+ #undef HAVE_PWD_H
+ 
++/* Define to 1 if you have the 'renameat' function. */
++#undef HAVE_RENAMEAT
++
++/* Define to 1 if you have the 'renameat2' function. */
++#undef HAVE_RENAMEAT2
++
+ /* Define to 1 if the system has the type 'request_sense'. */
+ #undef HAVE_REQUEST_SENSE
+ 
+@@ -381,6 +390,9 @@
+ /* Define to 1 if 'interface_id' is a member of 'sg_io_hdr_t'. */
+ #undef HAVE_SG_IO_HDR_T_INTERFACE_ID
+ 
++/* Define to 1 if you have the `shm_open' function. */
++#undef HAVE_SHM_OPEN
++
+ /* Define to 1 if 'si_fd' is a member of 'siginfo_t'. */
+ #undef HAVE_SIGINFO_T_SI_FD
+ 
+@@ -510,6 +522,9 @@
+ /* Define to 1 if you have the <sys/epoll.h> header file. */
+ #undef HAVE_SYS_EPOLL_H
+ 
++/* Define to 1 if you have the <sys/eventfd.h> header file. */
++#undef HAVE_SYS_EVENTFD_H
++
+ /* Define to 1 if you have the <sys/event.h> header file. */
+ #undef HAVE_SYS_EVENT_H
+ 
+diff --git a/include/ddk/ntifs.h b/include/ddk/ntifs.h
+index 980235abdc91..90248b4897cc 100644
+--- a/include/ddk/ntifs.h
++++ b/include/ddk/ntifs.h
+@@ -166,6 +166,11 @@ typedef struct _REPARSE_DATA_BUFFER
+             WCHAR  PathBuffer[1];
+         } MountPointReparseBuffer;
+ 
++        struct {
++            ULONG  Version;
++            UCHAR  PathBuffer[1];
++        } LinuxSymbolicLinkReparseBuffer;
++
+         struct
+         {
+             UCHAR DataBuffer[1];
+diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
+index a39ab1239707..c057b3e623ad 100644
+--- a/include/wine/server_protocol.h
++++ b/include/wine/server_protocol.h
+@@ -1857,6 +1857,7 @@ enum server_fd_type
+ {
+     FD_TYPE_INVALID,
+     FD_TYPE_FILE,
++    FD_TYPE_SYMLINK,
+     FD_TYPE_DIR,
+     FD_TYPE_SOCKET,
+     FD_TYPE_SERIAL,
+@@ -5849,7 +5850,6 @@ struct resume_process_reply
+ };
+ 
+ 
+-
+ struct get_next_thread_request
+ {
+     struct request_header __header;
+@@ -5866,6 +5866,78 @@ struct get_next_thread_reply
+     char __pad_12[4];
+ };
+ 
++enum esync_type
++{
++    ESYNC_SEMAPHORE = 1,
++    ESYNC_AUTO_EVENT,
++    ESYNC_MANUAL_EVENT,
++    ESYNC_MUTEX,
++    ESYNC_AUTO_SERVER,
++    ESYNC_MANUAL_SERVER,
++    ESYNC_QUEUE,
++};
++
++
++struct create_esync_request
++{
++    struct request_header __header;
++    unsigned int access;
++    int          initval;
++    int          type;
++    int          max;
++    /* VARARG(objattr,object_attributes); */
++    char __pad_28[4];
++};
++struct create_esync_reply
++{
++    struct reply_header __header;
++    obj_handle_t handle;
++    int          type;
++    unsigned int shm_idx;
++    char __pad_20[4];
++};
++
++struct open_esync_request
++{
++    struct request_header __header;
++    unsigned int access;
++    unsigned int attributes;
++    obj_handle_t rootdir;
++    int          type;
++    /* VARARG(name,unicode_str); */
++    char __pad_28[4];
++};
++struct open_esync_reply
++{
++    struct reply_header __header;
++    obj_handle_t handle;
++    int          type;
++    unsigned int shm_idx;
++    char __pad_20[4];
++};
++
++
++struct get_esync_fd_request
++{
++    struct request_header __header;
++    obj_handle_t handle;
++};
++struct get_esync_fd_reply
++{
++    struct reply_header __header;
++    int          type;
++    unsigned int shm_idx;
++};
++
++struct esync_msgwait_request
++{
++    struct request_header __header;
++    int          in_msgwait;
++};
++struct esync_msgwait_reply
++{
++    struct reply_header __header;
++};
+ 
+ 
+ struct set_keyboard_repeat_request
+@@ -5883,6 +5955,17 @@ struct set_keyboard_repeat_reply
+ };
+ 
+ 
++struct get_esync_apc_fd_request
++{
++    struct request_header __header;
++    char __pad_12[4];
++};
++struct get_esync_apc_fd_reply
++{
++    struct reply_header __header;
++};
++
++
+ enum request
+ {
+     REQ_new_process,
+@@ -6176,7 +6259,12 @@ enum request
+     REQ_suspend_process,
+     REQ_resume_process,
+     REQ_get_next_thread,
++    REQ_create_esync,
++    REQ_open_esync,
++    REQ_get_esync_fd,
++    REQ_esync_msgwait,
+     REQ_set_keyboard_repeat,
++    REQ_get_esync_apc_fd,
+     REQ_NB_REQUESTS
+ };
+ 
+@@ -6475,7 +6563,12 @@ union generic_request
+     struct suspend_process_request suspend_process_request;
+     struct resume_process_request resume_process_request;
+     struct get_next_thread_request get_next_thread_request;
++    struct create_esync_request create_esync_request;
++    struct open_esync_request open_esync_request;
++    struct get_esync_fd_request get_esync_fd_request;
++    struct esync_msgwait_request esync_msgwait_request;
+     struct set_keyboard_repeat_request set_keyboard_repeat_request;
++    struct get_esync_apc_fd_request get_esync_apc_fd_request;
+ };
+ union generic_reply
+ {
+@@ -6772,7 +6865,12 @@ union generic_reply
+     struct suspend_process_reply suspend_process_reply;
+     struct resume_process_reply resume_process_reply;
+     struct get_next_thread_reply get_next_thread_reply;
++    struct create_esync_reply create_esync_reply;
++    struct open_esync_reply open_esync_reply;
++    struct get_esync_fd_reply get_esync_fd_reply;
++    struct esync_msgwait_reply esync_msgwait_reply;
+     struct set_keyboard_repeat_reply set_keyboard_repeat_reply;
++    struct get_esync_apc_fd_reply get_esync_apc_fd_reply;
+ };
+ 
+ #define SERVER_PROTOCOL_VERSION 855
+diff --git a/include/winnt.h b/include/winnt.h
+index 2547f841b7c4..442dcb5179a3 100644
+--- a/include/winnt.h
++++ b/include/winnt.h
+@@ -2553,6 +2553,7 @@ static FORCEINLINE struct _TEB * WINAPI NtCurrentTeb(void)
+ #define IO_REPARSE_TAG_CLOUD_MASK       __MSABI_LONG(0x0000F000)
+ #define IO_REPARSE_TAG_APPEXECLINK      __MSABI_LONG(0x8000001B)
+ #define IO_REPARSE_TAG_GVFS             __MSABI_LONG(0x9000001C)
++#define IO_REPARSE_TAG_LX_SYMLINK       __MSABI_LONG(0xA000001D)
+ #define IO_REPARSE_TAG_STORAGE_SYNC     __MSABI_LONG(0x8000001E)
+ #define IO_REPARSE_TAG_WCI_TOMBSTONE    __MSABI_LONG(0xA000001F)
+ #define IO_REPARSE_TAG_UNHANDLED        __MSABI_LONG(0x80000020)
+diff --git a/programs/cmd/builtins.c b/programs/cmd/builtins.c
+index d7c5090d17f7..a7b908546193 100644
+--- a/programs/cmd/builtins.c
++++ b/programs/cmd/builtins.c
+@@ -31,6 +31,9 @@
+ #include "wcmd.h"
+ #include <shellapi.h>
+ #include "wine/debug.h"
++#include "winternl.h"
++#include "winioctl.h"
++#include "ddk/ntifs.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(cmd);
+ 
+@@ -3971,6 +3974,49 @@ RETURN_CODE WCMD_color(void)
+   return errorlevel = return_code;
+ }
+ 
++BOOL WCMD_create_junction(WCHAR *link, WCHAR *target) {
++    static INT struct_size = offsetof(REPARSE_DATA_BUFFER, SymbolicLinkReparseBuffer.PathBuffer[0]);
++    static INT header_size = offsetof(REPARSE_DATA_BUFFER, GenericReparseBuffer);
++    INT buffer_size, data_size, string_len, prefix_len;
++    WCHAR *subst_dest, *print_dest, *string;
++    REPARSE_DATA_BUFFER *buffer;
++    UNICODE_STRING nt_name;
++    NTSTATUS status;
++    HANDLE hlink;
++    DWORD dwret;
++    BOOL ret;
++
++    if (!CreateDirectoryW(link, NULL ))
++        return FALSE;
++    hlink = CreateFileW(link, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++    if (hlink == INVALID_HANDLE_VALUE)
++        return FALSE;
++    status = RtlDosPathNameToNtPathName_U_WithStatus(target, &nt_name, NULL, NULL);
++    if (status)
++        return FALSE;
++    prefix_len = strlen("\\??\\");
++    string = nt_name.Buffer;
++    string_len = lstrlenW( &string[prefix_len] );
++    data_size = (prefix_len + 2 * string_len + 2) * sizeof(WCHAR);
++    buffer_size = struct_size + data_size;
++    buffer = HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_size );
++    buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
++    buffer->ReparseDataLength = struct_size - header_size + data_size;
++    buffer->MountPointReparseBuffer.SubstituteNameLength = (prefix_len + string_len) * sizeof(WCHAR);
++    buffer->MountPointReparseBuffer.PrintNameOffset = (prefix_len + string_len + 1) * sizeof(WCHAR);
++    buffer->MountPointReparseBuffer.PrintNameLength = string_len * sizeof(WCHAR);
++    subst_dest = &buffer->MountPointReparseBuffer.PathBuffer[0];
++    print_dest = &buffer->MountPointReparseBuffer.PathBuffer[prefix_len + string_len + 1];
++    lstrcpyW(subst_dest, string);
++    lstrcpyW(print_dest, &string[prefix_len]);
++    RtlFreeUnicodeString(&nt_name );
++    ret = DeviceIoControl(hlink, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_size, NULL, 0,
++                          &dwret, 0 );
++    HeapFree(GetProcessHeap(), 0, buffer);
++    return ret;
++}
++
+ /****************************************************************************
+  * WCMD_mklink
+  */
+@@ -4021,7 +4067,7 @@ RETURN_CODE WCMD_mklink(WCHAR *args)
+         else if(!junction)
+             ret = CreateSymbolicLinkW(file1, file2, isdir);
+         else
+-            TRACE("Junction links currently not supported.\n");
++            ret = WCMD_create_junction(file1, file2);
+     }
+ 
+     if (ret) return errorlevel = NO_ERROR;
+diff --git a/programs/cmd/directory.c b/programs/cmd/directory.c
+index 3f4f78537103..6b24f728b323 100644
+--- a/programs/cmd/directory.c
++++ b/programs/cmd/directory.c
+@@ -23,6 +23,8 @@
+ 
+ #include "wcmd.h"
+ #include "wine/debug.h"
++#include "winioctl.h"
++#include "ddk/ntifs.h"
+ 
+ WINE_DEFAULT_DEBUG_CHANNEL(cmd);
+ 
+@@ -371,6 +373,65 @@ static DIRECTORY_STACK *WCMD_list_directory (DIRECTORY_STACK *inputparms, int le
+             WCMD_output(L"%1!*s!", cur_width - tmp_width, L"");
+         }
+ 
++      } else if (fd[i].dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
++        if (!bare) {
++           const WCHAR *type;
++
++           switch(fd[i].dwReserved0) {
++           case IO_REPARSE_TAG_MOUNT_POINT:
++              type = L"<JUNCTION>";
++              break;
++           case IO_REPARSE_TAG_SYMLINK:
++           default:
++              type = (fd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? L"<SYMLINKD>" : L"<SYMLINK>";
++              break;
++           }
++           WCMD_output (L"%1!10s!  %2!8s!  %3!-14s!", datestring, timestring, type);
++           if (shortname) WCMD_output (L"%1!-13s!", fd[i].cAlternateFileName);
++           if (usernames) WCMD_output (L"%1!-23s!", username);
++           WCMD_output(L"%1",fd[i].cFileName);
++           if (fd[i].dwReserved0) {
++              REPARSE_DATA_BUFFER *buffer = NULL;
++              WCHAR *target = NULL;
++              INT buffer_len;
++              HANDLE hlink;
++              DWORD dwret;
++              BOOL bret;
++
++              lstrcpyW(string, inputparms->dirName);
++              lstrcatW(string, fd[i].cFileName);
++              hlink = CreateFileW(string, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
++                                  FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
++              buffer_len = sizeof(*buffer) + 2*MAX_PATH*sizeof(WCHAR);
++              buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
++              bret = DeviceIoControl(hlink, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer,
++                                     buffer_len, &dwret, 0);
++              if (bret) {
++                 INT offset;
++                 switch(buffer->ReparseTag) {
++                 case IO_REPARSE_TAG_MOUNT_POINT:
++                    offset = buffer->MountPointReparseBuffer.PrintNameOffset/sizeof(WCHAR);
++                    target = &buffer->MountPointReparseBuffer.PathBuffer[offset];
++                    break;
++                 case IO_REPARSE_TAG_SYMLINK:
++                    offset = buffer->SymbolicLinkReparseBuffer.PrintNameOffset/sizeof(WCHAR);
++                    target = &buffer->SymbolicLinkReparseBuffer.PathBuffer[offset];
++                    break;
++                 }
++              }
++              CloseHandle(hlink);
++              if (target) WCMD_output(L" [%1]", target);
++              HeapFree(GetProcessHeap(), 0, buffer);
++           }
++        } else {
++           if (!((lstrcmpW(fd[i].cFileName, L".") == 0) ||
++                 (lstrcmpW(fd[i].cFileName, L"..") == 0))) {
++              WCMD_output (L"%1%2", recurse?inputparms->dirName : L"", fd[i].cFileName);
++           } else {
++              addNewLine = FALSE;
++           }
++        }
++
+       } else if (fd[i].dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
+         dir_count++;
+ 
+diff --git a/server/Makefile.in b/server/Makefile.in
+index 7e571ac2ba64..87103cb20026 100644
+--- a/server/Makefile.in
++++ b/server/Makefile.in
+@@ -11,6 +11,7 @@ SOURCES = \
+ 	debugger.c \
+ 	device.c \
+ 	directory.c \
++	esync.c \
+ 	event.c \
+ 	fd.c \
+ 	file.c \
+@@ -30,6 +31,7 @@ SOURCES = \
+ 	region.c \
+ 	registry.c \
+ 	request.c \
++	scheduler.c \
+ 	semaphore.c \
+ 	serial.c \
+ 	signal.c \
+diff --git a/server/async.c b/server/async.c
+index d2d929c9709f..9768a4932a6c 100644
+--- a/server/async.c
++++ b/server/async.c
+@@ -78,6 +78,7 @@ static const struct object_ops async_ops =
+     add_queue,                 /* add_queue */
+     remove_queue,              /* remove_queue */
+     async_signaled,            /* signaled */
++    NULL,                      /* get_esync_fd */
+     async_satisfied,           /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+@@ -698,6 +699,7 @@ static const struct object_ops iosb_ops =
+     no_add_queue,             /* add_queue */
+     NULL,                     /* remove_queue */
+     NULL,                     /* signaled */
++    NULL,                     /* get_esync_fd */
+     NULL,                     /* satisfied */
+     no_signal,                /* signal */
+     no_get_fd,                /* get_fd */
+diff --git a/server/atom.c b/server/atom.c
+index ff0799f5880d..d9824de8eac3 100644
+--- a/server/atom.c
++++ b/server/atom.c
+@@ -79,6 +79,7 @@ static const struct object_ops atom_table_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+diff --git a/server/change.c b/server/change.c
+index f42ce0663407..1c394c9d3a24 100644
+--- a/server/change.c
++++ b/server/change.c
+@@ -112,6 +112,7 @@ static const struct object_ops dir_ops =
+     add_queue,                /* add_queue */
+     remove_queue,             /* remove_queue */
+     default_fd_signaled,      /* signaled */
++    default_fd_get_esync_fd,  /* get_esync_fd */
+     no_satisfied,             /* satisfied */
+     no_signal,                /* signal */
+     dir_get_fd,               /* get_fd */
+diff --git a/server/clipboard.c b/server/clipboard.c
+index 91f159bc7c9b..0df7fd2f18e7 100644
+--- a/server/clipboard.c
++++ b/server/clipboard.c
+@@ -76,6 +76,7 @@ static const struct object_ops clipboard_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+diff --git a/server/completion.c b/server/completion.c
+index 99680ae06806..3d750154d1ba 100644
+--- a/server/completion.c
++++ b/server/completion.c
+@@ -92,6 +92,7 @@ static const struct object_ops completion_wait_ops =
+     add_queue,                      /* add_queue */
+     remove_queue,                   /* remove_queue */
+     completion_wait_signaled,       /* signaled */
++    NULL,                           /* get_esync_fd */
+     completion_wait_satisfied,      /* satisfied */
+     no_signal,                      /* signal */
+     no_get_fd,                      /* get_fd */
+@@ -166,6 +167,7 @@ static const struct object_ops completion_ops =
+     add_queue,                 /* add_queue */
+     remove_queue,              /* remove_queue */
+     completion_signaled,       /* signaled */
++    NULL,                      /* get_esync_fd */
+     no_satisfied,              /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+diff --git a/server/console.c b/server/console.c
+index c3e7bf57e924..c85eb98fa1f5 100644
+--- a/server/console.c
++++ b/server/console.c
+@@ -41,6 +41,7 @@
+ #include "wincon.h"
+ #include "winternl.h"
+ #include "wine/condrv.h"
++#include "esync.h"
+ 
+ struct screen_buffer;
+ 
+@@ -81,6 +82,7 @@ static const struct object_ops console_ops =
+     console_add_queue,                /* add_queue */
+     remove_queue,                     /* remove_queue */
+     console_signaled,                 /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     console_get_fd,                   /* get_fd */
+@@ -130,20 +132,22 @@ struct console_host_ioctl
+ 
+ struct console_server
+ {
+-    struct object         obj;            /* object header */
+-    struct fd            *fd;             /* pseudo-fd for ioctls */
+-    struct console       *console;        /* attached console */
+-    struct list           queue;          /* ioctl queue */
+-    struct list           read_queue;     /* blocking read queue */
++    struct object         obj;         /* object header */
++    struct fd            *fd;          /* pseudo-fd for ioctls */
++    struct console       *console;     /* attached console */
++    struct list           queue;       /* ioctl queue */
++    struct list           read_queue;  /* blocking read queue */
+     unsigned int          busy : 1;       /* flag if server processing an ioctl */
+     unsigned int          once_input : 1; /* flag if input thread has already been requested */
+-    int                   term_fd;        /* UNIX terminal fd */
+-    struct termios        termios;        /* original termios */
++    int                   term_fd;     /* UNIX terminal fd */
++    struct termios        termios;     /* original termios */
++    int                   esync_fd;
+ };
+ 
+ static void console_server_dump( struct object *obj, int verbose );
+ static void console_server_destroy( struct object *obj );
+ static int console_server_signaled( struct object *obj, struct wait_queue_entry *entry );
++static int console_server_get_esync_fd( struct object *obj, enum esync_type *type );
+ static struct fd *console_server_get_fd( struct object *obj );
+ static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
+                                                 unsigned int attr, struct object *root );
+@@ -158,6 +162,7 @@ static const struct object_ops console_server_ops =
+     add_queue,                        /* add_queue */
+     remove_queue,                     /* remove_queue */
+     console_server_signaled,          /* signaled */
++    console_server_get_esync_fd,      /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     console_server_get_fd,            /* get_fd */
+@@ -227,6 +232,7 @@ static const struct object_ops screen_buffer_ops =
+     screen_buffer_add_queue,          /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     NULL,                             /* satisfied */
+     no_signal,                        /* signal */
+     screen_buffer_get_fd,             /* get_fd */
+@@ -276,6 +282,7 @@ static const struct object_ops console_device_ops =
+     no_add_queue,                     /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     no_get_fd,                        /* get_fd */
+@@ -313,6 +320,7 @@ static const struct object_ops console_input_ops =
+     console_input_add_queue,          /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     console_input_get_fd,             /* get_fd */
+@@ -370,6 +378,7 @@ static const struct object_ops console_output_ops =
+     console_output_add_queue,         /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     console_output_get_fd,            /* get_fd */
+@@ -428,6 +437,7 @@ static const struct object_ops console_connection_ops =
+     no_add_queue,                     /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     console_connection_get_fd,        /* get_fd */
+@@ -590,6 +600,8 @@ static void disconnect_console_server( struct console_server *server )
+         list_remove( &call->entry );
+         console_host_ioctl_terminate( call, STATUS_CANCELLED );
+     }
++    if (do_esync())
++        esync_clear( server->esync_fd );
+     while (!list_empty( &server->read_queue ))
+     {
+         struct console_host_ioctl *call = LIST_ENTRY( list_head( &server->read_queue ), struct console_host_ioctl, entry );
+@@ -878,6 +890,7 @@ static void console_server_destroy( struct object *obj )
+     assert( obj->ops == &console_server_ops );
+     disconnect_console_server( server );
+     if (server->fd) release_object( server->fd );
++    if (do_esync()) close( server->esync_fd );
+ }
+ 
+ static struct object *console_server_lookup_name( struct object *obj, struct unicode_str *name,
+@@ -925,6 +938,13 @@ static int console_server_signaled( struct object *obj, struct wait_queue_entry
+     return !server->console || !list_empty( &server->queue );
+ }
+ 
++static int console_server_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct console_server *server = (struct console_server*)obj;
++    *type = ESYNC_MANUAL_SERVER;
++    return server->esync_fd;
++}
++
+ static struct fd *console_server_get_fd( struct object* obj )
+ {
+     struct console_server *server = (struct console_server*)obj;
+@@ -956,6 +976,10 @@ static struct object *create_console_server( void )
+         return NULL;
+     }
+     allow_fd_caching(server->fd);
++    server->esync_fd = -1;
++
++    if (do_esync())
++        server->esync_fd = esync_create_fd( 0, 0 );
+ 
+     return &server->obj;
+ }
+@@ -1569,6 +1593,8 @@ DECL_HANDLER(get_next_console_request)
+         /* set result of previous ioctl */
+         ioctl = LIST_ENTRY( list_head( &server->queue ), struct console_host_ioctl, entry );
+         list_remove( &ioctl->entry );
++        if (do_esync() && list_empty( &server->queue ))
++            esync_clear( server->esync_fd );
+     }
+ 
+     if (ioctl)
+@@ -1654,6 +1680,8 @@ DECL_HANDLER(get_next_console_request)
+     {
+         set_error( STATUS_PENDING );
+     }
++    if (do_esync() && list_empty( &server->queue ))
++        esync_clear( server->esync_fd );
+ 
+     release_object( server );
+ }
+diff --git a/server/debugger.c b/server/debugger.c
+index 39a740e07e53..0c01ec1c0d3a 100644
+--- a/server/debugger.c
++++ b/server/debugger.c
+@@ -86,6 +86,7 @@ static const struct object_ops debug_event_ops =
+     add_queue,                     /* add_queue */
+     remove_queue,                  /* remove_queue */
+     debug_event_signaled,          /* signaled */
++    NULL,                          /* get_esync_fd */
+     no_satisfied,                  /* satisfied */
+     no_signal,                     /* signal */
+     no_get_fd,                     /* get_fd */
+@@ -114,6 +115,7 @@ static const struct object_ops debug_obj_ops =
+     add_queue,                     /* add_queue */
+     remove_queue,                  /* remove_queue */
+     debug_obj_signaled,            /* signaled */
++    NULL,                          /* get_esync_fd */
+     no_satisfied,                  /* satisfied */
+     no_signal,                     /* signal */
+     no_get_fd,                     /* get_fd */
+diff --git a/server/device.c b/server/device.c
+index cab09700d8c1..52a22968ed2a 100644
+--- a/server/device.c
++++ b/server/device.c
+@@ -38,6 +38,7 @@
+ #include "handle.h"
+ #include "request.h"
+ #include "process.h"
++#include "esync.h"
+ 
+ /* IRP object */
+ 
+@@ -66,6 +67,7 @@ static const struct object_ops irp_call_ops =
+     no_add_queue,                     /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     NULL,                             /* satisfied */
+     no_signal,                        /* signal */
+     no_get_fd,                        /* get_fd */
+@@ -92,10 +94,12 @@ struct device_manager
+     struct list            requests;       /* list of pending irps across all devices */
+     struct irp_call       *current_call;   /* call currently executed on client side */
+     struct wine_rb_tree    kernel_objects; /* map of objects that have client side pointer associated */
++    int                    esync_fd;       /* esync file descriptor */
+ };
+ 
+ static void device_manager_dump( struct object *obj, int verbose );
+ static int device_manager_signaled( struct object *obj, struct wait_queue_entry *entry );
++static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type );
+ static void device_manager_destroy( struct object *obj );
+ 
+ static const struct object_ops device_manager_ops =
+@@ -106,6 +110,7 @@ static const struct object_ops device_manager_ops =
+     add_queue,                        /* add_queue */
+     remove_queue,                     /* remove_queue */
+     device_manager_signaled,          /* signaled */
++    device_manager_get_esync_fd,      /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     no_get_fd,                        /* get_fd */
+@@ -163,6 +168,7 @@ static const struct object_ops device_ops =
+     no_add_queue,                     /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     no_get_fd,                        /* get_fd */
+@@ -215,6 +221,7 @@ static const struct object_ops device_file_ops =
+     add_queue,                        /* add_queue */
+     remove_queue,                     /* remove_queue */
+     default_fd_signaled,              /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     device_file_get_fd,               /* get_fd */
+@@ -748,6 +755,9 @@ static void delete_file( struct device_file *file )
+     /* terminate all pending requests */
+     LIST_FOR_EACH_ENTRY_SAFE( irp, next, &file->requests, struct irp_call, dev_entry )
+     {
++        if (do_esync() && file->device->manager && list_empty( &file->device->manager->requests ))
++            esync_clear( file->device->manager->esync_fd );
++
+         list_remove( &irp->mgr_entry );
+         set_irp_result( irp, STATUS_FILE_DELETED, NULL, 0, 0 );
+     }
+@@ -783,6 +793,13 @@ static int device_manager_signaled( struct object *obj, struct wait_queue_entry
+     return !list_empty( &manager->requests );
+ }
+ 
++static int device_manager_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct device_manager *manager = (struct device_manager *)obj;
++    *type = ESYNC_MANUAL_SERVER;
++    return manager->esync_fd;
++}
++
+ static void device_manager_destroy( struct object *obj )
+ {
+     struct device_manager *manager = (struct device_manager *)obj;
+@@ -817,6 +834,9 @@ static void device_manager_destroy( struct object *obj )
+         assert( !irp->file && !irp->async );
+         release_object( irp );
+     }
++
++    if (do_esync())
++        close( manager->esync_fd );
+ }
+ 
+ static struct device_manager *create_device_manager(void)
+@@ -829,6 +849,9 @@ static struct device_manager *create_device_manager(void)
+         list_init( &manager->devices );
+         list_init( &manager->requests );
+         wine_rb_init( &manager->kernel_objects, compare_kernel_object );
++
++        if (do_esync())
++            manager->esync_fd = esync_create_fd( 0, 0 );
+     }
+     return manager;
+ }
+@@ -1018,6 +1041,9 @@ DECL_HANDLER(get_next_device_request)
+                 /* we already own the object if it's only on manager queue */
+                 if (irp->file) grab_object( irp );
+                 manager->current_call = irp;
++
++                if (do_esync() && list_empty( &manager->requests ))
++                    esync_clear( manager->esync_fd );
+             }
+             else close_handle( current->process, reply->next );
+         }
+diff --git a/server/directory.c b/server/directory.c
+index fd689c561bc9..2894f7669dbf 100644
+--- a/server/directory.c
++++ b/server/directory.c
+@@ -69,6 +69,7 @@ static const struct object_ops object_type_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+@@ -119,6 +120,7 @@ static const struct object_ops directory_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+diff --git a/server/esync.c b/server/esync.c
+new file mode 100644
+index 000000000000..e193f61b3a76
+--- /dev/null
++++ b/server/esync.c
+@@ -0,0 +1,588 @@
++/*
++ * eventfd-based synchronization objects
++ *
++ * Copyright (C) 2018 Zebediah Figura
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#include "config.h"
++
++
++#include <fcntl.h>
++#include <stdio.h>
++#include <stdarg.h>
++#ifdef HAVE_SYS_EVENTFD_H
++# include <sys/eventfd.h>
++#endif
++#include <sys/mman.h>
++#ifdef HAVE_SYS_STAT_H
++# include <sys/stat.h>
++#endif
++#include <unistd.h>
++
++#include "ntstatus.h"
++#define WIN32_NO_STATUS
++#include "windef.h"
++#include "winternl.h"
++
++#include "handle.h"
++#include "request.h"
++#include "file.h"
++#include "esync.h"
++
++int do_esync(void)
++{
++#ifdef HAVE_SYS_EVENTFD_H
++    static int do_esync_cached = -1;
++
++    if (do_esync_cached == -1)
++        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
++
++    return do_esync_cached;
++#else
++    return 0;
++#endif
++}
++
++static char shm_name[29];
++static int shm_fd;
++static off_t shm_size;
++static void **shm_addrs;
++static int shm_addrs_size;  /* length of the allocated shm_addrs array */
++static long pagesize;
++
++static void shm_cleanup(void)
++{
++    close( shm_fd );
++    if (shm_unlink( shm_name ) == -1)
++        perror( "shm_unlink" );
++}
++
++void esync_init(void)
++{
++    struct stat st;
++
++    if (fstat( config_dir_fd, &st ) == -1)
++        fatal_error( "cannot stat config dir\n" );
++
++    if (st.st_ino != (unsigned long)st.st_ino)
++        sprintf( shm_name, "/wine-%lx%08lx-esync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
++    else
++        sprintf( shm_name, "/wine-%lx-esync", (unsigned long)st.st_ino );
++
++    shm_unlink( shm_name );
++
++    shm_fd = shm_open( shm_name, O_RDWR | O_CREAT | O_EXCL, 0644 );
++    if (shm_fd == -1)
++        perror( "shm_open" );
++
++    pagesize = sysconf( _SC_PAGESIZE );
++
++    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
++    shm_addrs_size = 128;
++
++    shm_size = pagesize;
++    if (ftruncate( shm_fd, shm_size ) == -1)
++        perror( "ftruncate" );
++
++    fprintf( stderr, "esync: up and running.\n" );
++
++    atexit( shm_cleanup );
++}
++
++static struct list mutex_list = LIST_INIT(mutex_list);
++
++struct esync
++{
++    struct object   obj;            /* object header */
++    int             fd;             /* eventfd file descriptor */
++    enum esync_type type;
++    unsigned int    shm_idx;        /* index into the shared memory section */
++    struct list     mutex_entry;    /* entry in the mutex list (if applicable) */
++};
++
++static void esync_dump( struct object *obj, int verbose );
++static int esync_get_esync_fd( struct object *obj, enum esync_type *type );
++static unsigned int esync_map_access( struct object *obj, unsigned int access );
++static void esync_destroy( struct object *obj );
++
++const struct object_ops esync_ops =
++{
++    sizeof(struct esync),      /* size */
++    &no_type,                  /* type */
++    esync_dump,                /* dump */
++    no_add_queue,              /* add_queue */
++    NULL,                      /* remove_queue */
++    NULL,                      /* signaled */
++    esync_get_esync_fd,        /* get_esync_fd */
++    NULL,                      /* satisfied */
++    no_signal,                 /* signal */
++    no_get_fd,                 /* get_fd */
++    esync_map_access,          /* map_access */
++    default_get_sd,            /* get_sd */
++    default_set_sd,            /* set_sd */
++    default_get_full_name,     /* get_full_name */
++    no_lookup_name,            /* lookup_name */
++    directory_link_name,       /* link_name */
++    default_unlink_name,       /* unlink_name */
++    no_open_file,              /* open_file */
++    no_kernel_obj_list,        /* get_kernel_obj_list */
++    no_close_handle,           /* close_handle */
++    esync_destroy              /* destroy */
++};
++
++static void esync_dump( struct object *obj, int verbose )
++{
++    struct esync *esync = (struct esync *)obj;
++    assert( obj->ops == &esync_ops );
++    fprintf( stderr, "esync fd=%d\n", esync->fd );
++}
++
++static int esync_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct esync *esync = (struct esync *)obj;
++    *type = esync->type;
++    return esync->fd;
++}
++
++static unsigned int esync_map_access( struct object *obj, unsigned int access )
++{
++    /* Sync objects have the same flags. */
++    if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | EVENT_QUERY_STATE;
++    if (access & GENERIC_WRITE)   access |= STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE;
++    if (access & GENERIC_EXECUTE) access |= STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE;
++    if (access & GENERIC_ALL)     access |= STANDARD_RIGHTS_ALL | EVENT_QUERY_STATE | EVENT_MODIFY_STATE;
++    return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
++}
++
++static void esync_destroy( struct object *obj )
++{
++    struct esync *esync = (struct esync *)obj;
++    if (esync->type == ESYNC_MUTEX)
++        list_remove( &esync->mutex_entry );
++    close( esync->fd );
++}
++
++static int type_matches( enum esync_type type1, enum esync_type type2 )
++{
++    return (type1 == type2) ||
++           ((type1 == ESYNC_AUTO_EVENT || type1 == ESYNC_MANUAL_EVENT) &&
++            (type2 == ESYNC_AUTO_EVENT || type2 == ESYNC_MANUAL_EVENT));
++}
++
++static void *get_shm( unsigned int idx )
++{
++    int entry  = (idx * 8) / pagesize;
++    int offset = (idx * 8) % pagesize;
++
++    if (entry >= shm_addrs_size)
++    {
++        int new_size = max(shm_addrs_size * 2, entry + 1);
++
++        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
++            fprintf( stderr, "esync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
++
++        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
++
++        shm_addrs_size = new_size;
++    }
++
++    if (!shm_addrs[entry])
++    {
++        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
++        if (addr == (void *)-1)
++        {
++            fprintf( stderr, "esync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
++            perror( "mmap" );
++        }
++
++        if (debug_level)
++            fprintf( stderr, "esync: Mapping page %d at %p.\n", entry, addr );
++
++        if (__sync_val_compare_and_swap( &shm_addrs[entry], 0, addr ))
++            munmap( addr, pagesize ); /* someone beat us to it */
++    }
++
++    return (void *)((unsigned long)shm_addrs[entry] + offset);
++}
++
++struct semaphore
++{
++    int max;
++    int count;
++};
++C_ASSERT(sizeof(struct semaphore) == 8);
++
++struct mutex
++{
++    DWORD tid;
++    int count;    /* recursion count */
++};
++C_ASSERT(sizeof(struct mutex) == 8);
++
++struct event
++{
++    int signaled;
++    int locked;
++};
++C_ASSERT(sizeof(struct event) == 8);
++
++struct esync *create_esync( struct object *root, const struct unicode_str *name,
++                            unsigned int attr, int initval, int max, enum esync_type type,
++                            const struct security_descriptor *sd )
++{
++#ifdef HAVE_SYS_EVENTFD_H
++    struct esync *esync;
++
++    if ((esync = create_named_object( root, &esync_ops, name, attr, sd )))
++    {
++        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
++        {
++            int flags = EFD_CLOEXEC | EFD_NONBLOCK;
++
++            if (type == ESYNC_SEMAPHORE)
++                flags |= EFD_SEMAPHORE;
++
++            /* initialize it if it didn't already exist */
++            esync->fd = eventfd( initval, flags );
++            if (esync->fd == -1)
++            {
++                perror( "eventfd" );
++                file_set_error();
++                release_object( esync );
++                return NULL;
++            }
++            esync->type = type;
++
++            /* Use the fd as index, since that'll be unique across all
++             * processes, but should hopefully end up also allowing reuse. */
++            esync->shm_idx = esync->fd + 1; /* we keep index 0 reserved */
++            while (esync->shm_idx * 8 >= shm_size)
++            {
++                /* Better expand the shm section. */
++                shm_size += pagesize;
++                if (ftruncate( shm_fd, shm_size ) == -1)
++                {
++                    fprintf( stderr, "esync: couldn't expand %s to size %ld: ",
++                             shm_name, (long)shm_size );
++                    perror( "ftruncate" );
++                }
++            }
++
++            /* Initialize the shared memory portion. We want to do this on the
++             * server side to avoid a potential though unlikely race whereby
++             * the same object is opened and used between the time it's created
++             * and the time its shared memory portion is initialized. */
++            switch (type)
++            {
++            case ESYNC_SEMAPHORE:
++            {
++                struct semaphore *semaphore = get_shm( esync->shm_idx );
++                semaphore->max = max;
++                semaphore->count = initval;
++                break;
++            }
++            case ESYNC_AUTO_EVENT:
++            case ESYNC_MANUAL_EVENT:
++            {
++                struct event *event = get_shm( esync->shm_idx );
++                event->signaled = initval ? 1 : 0;
++                event->locked = 0;
++                break;
++            }
++            case ESYNC_MUTEX:
++            {
++                struct mutex *mutex = get_shm( esync->shm_idx );
++                mutex->tid = initval ? 0 : current->id;
++                mutex->count = initval ? 0 : 1;
++                list_add_tail( &mutex_list, &esync->mutex_entry );
++                break;
++            }
++            default:
++                assert( 0 );
++            }
++        }
++        else
++        {
++            /* validate the type */
++            if (!type_matches( type, esync->type ))
++            {
++                release_object( &esync->obj );
++                set_error( STATUS_OBJECT_TYPE_MISMATCH );
++                return NULL;
++            }
++        }
++    }
++    return esync;
++#else
++    /* FIXME: Provide a fallback implementation using pipe(). */
++    set_error( STATUS_NOT_IMPLEMENTED );
++    return NULL;
++#endif
++}
++
++/* Create a file descriptor for an existing handle.
++ * Caller must close the handle when it's done; it's not linked to an esync
++ * server object in any way. */
++int esync_create_fd( int initval, int flags )
++{
++#ifdef HAVE_SYS_EVENTFD_H
++    int fd;
++
++    fd = eventfd( initval, flags | EFD_CLOEXEC | EFD_NONBLOCK );
++    if (fd == -1)
++        perror( "eventfd" );
++
++    return fd;
++#else
++    return -1;
++#endif
++}
++
++/* Wake up a specific fd. */
++void esync_wake_fd( int fd )
++{
++    static const uint64_t value = 1;
++
++    if (write( fd, &value, sizeof(value) ) == -1)
++        perror( "esync: write" );
++}
++
++/* Wake up a server-side esync object. */
++void esync_wake_up( struct object *obj )
++{
++    enum esync_type dummy;
++    int fd;
++
++    if (obj->ops->get_esync_fd)
++    {
++        fd = obj->ops->get_esync_fd( obj, &dummy );
++        esync_wake_fd( fd );
++    }
++}
++
++void esync_clear( int fd )
++{
++    uint64_t value;
++
++    /* we don't care about the return value */
++    read( fd, &value, sizeof(value) );
++}
++
++static inline void small_pause(void)
++{
++#ifdef __i386__
++    __asm__ __volatile__( "rep;nop" : : : "memory" );
++#else
++    __asm__ __volatile__( "" : : : "memory" );
++#endif
++}
++
++/* Server-side event support. */
++void esync_set_event( struct esync *esync )
++{
++    static const uint64_t value = 1;
++    struct event *event = get_shm( esync->shm_idx );
++
++    assert( esync->obj.ops == &esync_ops );
++    assert( event != NULL );
++
++    if (debug_level)
++        fprintf( stderr, "esync_set_event() fd=%d\n", esync->fd );
++
++    if (esync->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Acquire the spinlock. */
++        while (__sync_val_compare_and_swap( &event->locked, 0, 1 ))
++            small_pause();
++    }
++
++    if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
++    {
++        if (write( esync->fd, &value, sizeof(value) ) == -1)
++            perror( "esync: write" );
++    }
++
++    if (esync->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Release the spinlock. */
++        event->locked = 0;
++    }
++}
++
++void esync_reset_event( struct esync *esync )
++{
++    static uint64_t value = 1;
++    struct event *event = get_shm( esync->shm_idx );
++
++    assert( esync->obj.ops == &esync_ops );
++    assert( event != NULL );
++
++    if (debug_level)
++        fprintf( stderr, "esync_reset_event() fd=%d\n", esync->fd );
++
++    if (esync->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Acquire the spinlock. */
++        while (__sync_val_compare_and_swap( &event->locked, 0, 1 ))
++            small_pause();
++    }
++
++    /* Only bother signaling the fd if we weren't already signaled. */
++    if (__atomic_exchange_n( &event->signaled, 0, __ATOMIC_SEQ_CST ))
++    {
++        /* we don't care about the return value */
++        read( esync->fd, &value, sizeof(value) );
++    }
++
++    if (esync->type == ESYNC_MANUAL_EVENT)
++    {
++        /* Release the spinlock. */
++        event->locked = 0;
++    }
++}
++
++void esync_abandon_mutexes( struct thread *thread )
++{
++    struct esync *esync;
++
++    LIST_FOR_EACH_ENTRY( esync, &mutex_list, struct esync, mutex_entry )
++    {
++        struct mutex *mutex = get_shm( esync->shm_idx );
++
++        if (mutex->tid == thread->id)
++        {
++            if (debug_level)
++                fprintf( stderr, "esync_abandon_mutexes() fd=%d\n", esync->fd );
++            mutex->tid = ~0;
++            mutex->count = 0;
++            esync_wake_fd( esync->fd );
++        }
++    }
++}
++
++DECL_HANDLER(create_esync)
++{
++    struct esync *esync;
++    struct unicode_str name;
++    struct object *root;
++    const struct security_descriptor *sd;
++    const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
++
++    if (!do_esync())
++    {
++        set_error( STATUS_NOT_IMPLEMENTED );
++        return;
++    }
++
++    if (!req->type)
++    {
++        set_error( STATUS_INVALID_PARAMETER );
++        return;
++    }
++
++    if (!objattr) return;
++
++    if ((esync = create_esync( root, &name, objattr->attributes, req->initval, req->max, req->type, sd )))
++    {
++        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
++            reply->handle = alloc_handle( current->process, esync, req->access, objattr->attributes );
++        else
++            reply->handle = alloc_handle_no_access_check( current->process, esync,
++                                                          req->access, objattr->attributes );
++
++        reply->type = esync->type;
++        reply->shm_idx = esync->shm_idx;
++        send_client_fd( current->process, esync->fd, reply->handle );
++        release_object( esync );
++    }
++
++    if (root) release_object( root );
++}
++
++DECL_HANDLER(open_esync)
++{
++    struct unicode_str name = get_req_unicode_str();
++
++    reply->handle = open_object( current->process, req->rootdir, req->access,
++                                 &esync_ops, &name, req->attributes );
++
++    /* send over the fd */
++    if (reply->handle)
++    {
++        struct esync *esync;
++
++        if (!(esync = (struct esync *)get_handle_obj( current->process, reply->handle,
++                                                      0, &esync_ops )))
++            return;
++
++        if (!type_matches( req->type, esync->type ))
++        {
++            set_error( STATUS_OBJECT_TYPE_MISMATCH );
++            release_object( esync );
++            return;
++        }
++
++        reply->type = esync->type;
++        reply->shm_idx = esync->shm_idx;
++
++        send_client_fd( current->process, esync->fd, reply->handle );
++        release_object( esync );
++    }
++}
++
++/* Retrieve a file descriptor for an esync object which will be signaled by the
++ * server. The client should only read from (i.e. wait on) this object. */
++DECL_HANDLER(get_esync_fd)
++{
++    struct object *obj;
++    enum esync_type type;
++    int fd;
++
++    if (!(obj = get_handle_obj( current->process, req->handle, SYNCHRONIZE, NULL )))
++        return;
++
++    if (obj->ops->get_esync_fd)
++    {
++        fd = obj->ops->get_esync_fd( obj, &type );
++        reply->type = type;
++        if (obj->ops == &esync_ops)
++        {
++            struct esync *esync = (struct esync *)obj;
++            reply->shm_idx = esync->shm_idx;
++        }
++        else
++            reply->shm_idx = 0;
++        send_client_fd( current->process, fd, req->handle );
++    }
++    else
++    {
++        if (debug_level)
++        {
++            fprintf( stderr, "%04x: esync: can't wait on object: ", current->id );
++            obj->ops->dump( obj, 0 );
++        }
++        set_error( STATUS_NOT_IMPLEMENTED );
++    }
++
++    release_object( obj );
++}
++
++/* Return the fd used for waiting on user APCs. */
++DECL_HANDLER(get_esync_apc_fd)
++{
++    send_client_fd( current->process, current->esync_apc_fd, current->id );
++}
+diff --git a/server/esync.h b/server/esync.h
+new file mode 100644
+index 000000000000..d39f4efa3ecf
+--- /dev/null
++++ b/server/esync.h
+@@ -0,0 +1,35 @@
++/*
++ * eventfd-based synchronization objects
++ *
++ * Copyright (C) 2018 Zebediah Figura
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#include <unistd.h>
++
++extern int do_esync(void);
++void esync_init(void);
++int esync_create_fd( int initval, int flags );
++void esync_wake_fd( int fd );
++void esync_wake_up( struct object *obj );
++void esync_clear( int fd );
++
++struct esync;
++
++extern const struct object_ops esync_ops;
++void esync_set_event( struct esync *esync );
++void esync_reset_event( struct esync *esync );
++void esync_abandon_mutexes( struct thread *thread );
+diff --git a/server/event.c b/server/event.c
+index ad7c09acc992..28a5620268fb 100644
+--- a/server/event.c
++++ b/server/event.c
+@@ -35,6 +35,7 @@
+ #include "thread.h"
+ #include "request.h"
+ #include "security.h"
++#include "esync.h"
+ 
+ static const WCHAR event_name[] = {'E','v','e','n','t'};
+ 
+@@ -56,13 +57,16 @@ struct event
+     struct list    kernel_object;   /* list of kernel object pointers */
+     int            manual_reset;    /* is it a manual reset event? */
+     int            signaled;        /* event has been signaled */
++    int            esync_fd;        /* esync file descriptor */
+ };
+ 
+ static void event_dump( struct object *obj, int verbose );
+ static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
+ static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
++static int event_get_esync_fd( struct object *obj, enum esync_type *type );
+ static int event_signal( struct object *obj, unsigned int access);
+ static struct list *event_get_kernel_obj_list( struct object *obj );
++static void event_destroy( struct object *obj );
+ 
+ static const struct object_ops event_ops =
+ {
+@@ -72,6 +76,7 @@ static const struct object_ops event_ops =
+     add_queue,                 /* add_queue */
+     remove_queue,              /* remove_queue */
+     event_signaled,            /* signaled */
++    event_get_esync_fd,        /* get_esync_fd */
+     event_satisfied,           /* satisfied */
+     event_signal,              /* signal */
+     no_get_fd,                 /* get_fd */
+@@ -85,7 +90,7 @@ static const struct object_ops event_ops =
+     no_open_file,              /* open_file */
+     event_get_kernel_obj_list, /* get_kernel_obj_list */
+     no_close_handle,           /* close_handle */
+-    no_destroy                 /* destroy */
++    event_destroy              /* destroy */
+ };
+ 
+ 
+@@ -119,6 +124,7 @@ static const struct object_ops keyed_event_ops =
+     add_queue,                   /* add_queue */
+     remove_queue,                /* remove_queue */
+     keyed_event_signaled,        /* signaled */
++    NULL,                        /* get_esync_fd */
+     no_satisfied,                /* satisfied */
+     no_signal,                   /* signal */
+     no_get_fd,                   /* get_fd */
+@@ -150,6 +156,9 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
+             list_init( &event->kernel_object );
+             event->manual_reset = manual_reset;
+             event->signaled     = initial_state;
++
++            if (do_esync())
++                event->esync_fd = esync_create_fd( initial_state, 0 );
+         }
+     }
+     return event;
+@@ -157,6 +166,10 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
+ 
+ struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access )
+ {
++    struct object *obj;
++    if (do_esync() && (obj = get_handle_obj( process, handle, access, &esync_ops)))
++        return (struct event *)obj; /* even though it's not an event */
++
+     return (struct event *)get_handle_obj( process, handle, access, &event_ops );
+ }
+ 
+@@ -170,6 +183,12 @@ static void pulse_event( struct event *event )
+ 
+ void set_event( struct event *event )
+ {
++    if (do_esync() && event->obj.ops == &esync_ops)
++    {
++        esync_set_event( (struct esync *)event );
++        return;
++    }
++
+     event->signaled = 1;
+     /* wake up all waiters if manual reset, a single one otherwise */
+     wake_up( &event->obj, !event->manual_reset );
+@@ -177,7 +196,15 @@ void set_event( struct event *event )
+ 
+ void reset_event( struct event *event )
+ {
++    if (do_esync() && event->obj.ops == &esync_ops)
++    {
++        esync_reset_event( (struct esync *)event );
++        return;
++    }
+     event->signaled = 0;
++
++    if (do_esync())
++        esync_clear( event->esync_fd );
+ }
+ 
+ static void event_dump( struct object *obj, int verbose )
+@@ -195,6 +222,13 @@ static int event_signaled( struct object *obj, struct wait_queue_entry *entry )
+     return event->signaled;
+ }
+ 
++static int event_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct event *event = (struct event *)obj;
++    *type = event->manual_reset ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
++    return event->esync_fd;
++}
++
+ static void event_satisfied( struct object *obj, struct wait_queue_entry *entry )
+ {
+     struct event *event = (struct event *)obj;
+@@ -223,6 +257,14 @@ static struct list *event_get_kernel_obj_list( struct object *obj )
+     return &event->kernel_object;
+ }
+ 
++static void event_destroy( struct object *obj )
++{
++    struct event *event = (struct event *)obj;
++
++    if (do_esync())
++        close( event->esync_fd );
++}
++
+ struct keyed_event *create_keyed_event( struct object *root, const struct unicode_str *name,
+                                         unsigned int attr, const struct security_descriptor *sd )
+ {
+diff --git a/server/fd.c b/server/fd.c
+index ce32e7f8397d..313220b5aaf5 100644
+--- a/server/fd.c
++++ b/server/fd.c
+@@ -32,6 +32,7 @@
+ #include <string.h>
+ #include <stdlib.h>
+ #include <stdint.h>
++#include <libgen.h>
+ #include <poll.h>
+ #ifdef HAVE_LINUX_MAJOR_H
+ #include <linux/major.h>
+@@ -94,11 +95,16 @@
+ #include "handle.h"
+ #include "process.h"
+ #include "request.h"
++#include "esync.h"
+ 
+ #include "winternl.h"
+ #include "winioctl.h"
+ #include "ddk/wdm.h"
+ 
++#if !defined(O_SYMLINK) && defined(O_PATH)
++# define O_SYMLINK (O_NOFOLLOW | O_PATH)
++#endif
++
+ #if defined(HAVE_SYS_EPOLL_H) && defined(HAVE_EPOLL_CREATE)
+ # include <sys/epoll.h>
+ # define USE_EPOLL
+@@ -154,6 +160,7 @@ struct fd
+     struct completion   *completion;  /* completion object attached to this fd */
+     apc_param_t          comp_key;    /* completion key to set in completion events */
+     unsigned int         comp_flags;  /* completion flags */
++    int                  esync_fd;    /* esync file descriptor */
+ };
+ 
+ static void fd_dump( struct object *obj, int verbose );
+@@ -167,6 +174,7 @@ static const struct object_ops fd_ops =
+     no_add_queue,             /* add_queue */
+     NULL,                     /* remove_queue */
+     NULL,                     /* signaled */
++    NULL,                     /* get_esync_fd */
+     NULL,                     /* satisfied */
+     no_signal,                /* signal */
+     no_get_fd,                /* get_fd */
+@@ -208,6 +216,7 @@ static const struct object_ops device_ops =
+     no_add_queue,             /* add_queue */
+     NULL,                     /* remove_queue */
+     NULL,                     /* signaled */
++    NULL,                     /* get_esync_fd */
+     NULL,                     /* satisfied */
+     no_signal,                /* signal */
+     no_get_fd,                /* get_fd */
+@@ -248,6 +257,7 @@ static const struct object_ops inode_ops =
+     no_add_queue,             /* add_queue */
+     NULL,                     /* remove_queue */
+     NULL,                     /* signaled */
++    NULL,                     /* get_esync_fd */
+     NULL,                     /* satisfied */
+     no_signal,                /* signal */
+     no_get_fd,                /* get_fd */
+@@ -290,6 +300,7 @@ static const struct object_ops file_lock_ops =
+     add_queue,                  /* add_queue */
+     remove_queue,               /* remove_queue */
+     file_lock_signaled,         /* signaled */
++    NULL,                       /* get_esync_fd */
+     no_satisfied,               /* satisfied */
+     no_signal,                  /* signal */
+     no_get_fd,                  /* get_fd */
+@@ -1064,6 +1075,9 @@ static void device_destroy( struct object *obj )
+     list_remove( &device->entry );  /* remove it from the hash table */
+ }
+ 
++static int is_reparse_dir( const char *path, int *is_dir );
++static int rmdir_recursive( int dir_fd, const char *pathname );
++
+ /****************************************************************/
+ /* inode functions */
+ 
+@@ -1071,10 +1085,29 @@ static void unlink_closed_fd( struct inode *inode, struct closed_fd *fd )
+ {
+     /* make sure it is still the same file */
+     struct stat st;
+-    if (!stat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
++    if (!lstat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
+     {
++        int is_reparse_point = (is_reparse_dir( fd->unix_name, NULL ) == 0);
+         if (S_ISDIR(st.st_mode)) rmdir( fd->unix_name );
+         else unlink( fd->unix_name );
++        /* remove reparse point metadata (if applicable) */
++        if (is_reparse_point)
++        {
++            char tmp[PATH_MAX], metadata_path[PATH_MAX], *p;
++
++            strcpy( tmp, fd->unix_name );
++            p = dirname( tmp );
++            if (p != tmp ) strcpy( tmp, p );
++            strcpy( metadata_path, tmp );
++            strcat( metadata_path, "/.REPARSE_POINT/" );
++            strcpy( tmp, fd->unix_name );
++            p = basename( tmp );
++            if (p != tmp) strcpy( tmp, p );
++            strcat( metadata_path, tmp );
++
++            rmdir_recursive( AT_FDCWD, metadata_path );
++            rmdir( dirname( metadata_path ) );
++        }
+     }
+ }
+ 
+@@ -1113,6 +1146,59 @@ static void inode_dump( struct object *obj, int verbose )
+     fprintf( stderr, "\n" );
+ }
+ 
++/* recursively delete everything in a directory */
++static int rmdir_recursive( int dir_fd, const char *pathname )
++{
++    int ret = 0, tmp_fd;
++    struct dirent *p;
++    struct stat st;
++    DIR *d;
++
++    tmp_fd = openat( dir_fd, pathname, O_DIRECTORY|O_RDONLY|O_NONBLOCK|O_CLOEXEC );
++    d = fdopendir( tmp_fd );
++    if (!d)
++    {
++        close( tmp_fd );
++        return -1;
++    }
++
++    while (!ret && (p = readdir( d )))
++    {
++        if (!strcmp( p->d_name, "." ) || !strcmp( p->d_name, ".." ))
++            continue;
++        if (!fstatat( dirfd(d), p->d_name, &st, AT_SYMLINK_NOFOLLOW ))
++        {
++            if (S_ISDIR( st.st_mode ))
++                ret = rmdir_recursive( dirfd(d), p->d_name );
++            else
++                ret = unlinkat( dirfd(d), p->d_name, 0 );
++        }
++    }
++    closedir( d );
++    return unlinkat( dir_fd, pathname, AT_REMOVEDIR );
++}
++
++/* determine whether a reparse point is meant to be a directory or a file */
++static int is_reparse_dir( const char *path, int *is_dir )
++{
++    char link_path[PATH_MAX], *p;
++    int ret;
++
++    if ((ret = readlink( path, link_path, sizeof(link_path) )) < 0)
++        return ret;
++    /* confirm that this file is a reparse point */
++    if (strncmp( link_path, ".REPARSE_POINT/", 15) != 0)
++        return -1;
++    /* skip past the reparse point indicator and the filename */
++    p = &link_path[15];
++    if ((p = strchr( p, '/' )) == NULL)
++        return -1;
++    p++;
++    /* read the flag indicating whether this reparse point is a directory */
++    if (is_dir) *is_dir = (*p == '.');
++    return 0;
++}
++
+ static void inode_destroy( struct object *obj )
+ {
+     struct inode *inode = (struct inode *)obj;
+@@ -1572,6 +1658,9 @@ static void fd_destroy( struct object *obj )
+         if (fd->unix_fd != -1) close( fd->unix_fd );
+         free( fd->unix_name );
+     }
++
++    if (do_esync())
++        close( fd->esync_fd );
+ }
+ 
+ /* check if the desired access is possible without violating */
+@@ -1690,12 +1779,16 @@ static struct fd *alloc_fd_object(void)
+     fd->poll_index = -1;
+     fd->completion = NULL;
+     fd->comp_flags = 0;
++    fd->esync_fd   = -1;
+     init_async_queue( &fd->read_q );
+     init_async_queue( &fd->write_q );
+     init_async_queue( &fd->wait_q );
+     list_init( &fd->inode_entry );
+     list_init( &fd->locks );
+ 
++    if (do_esync())
++        fd->esync_fd = esync_create_fd( 1, 0 );
++
+     if ((fd->poll_index = add_poll_user( fd )) == -1)
+     {
+         release_object( fd );
+@@ -1731,11 +1824,15 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
+     fd->completion = NULL;
+     fd->comp_flags = 0;
+     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
++    fd->esync_fd   = -1;
+     init_async_queue( &fd->read_q );
+     init_async_queue( &fd->write_q );
+     init_async_queue( &fd->wait_q );
+     list_init( &fd->inode_entry );
+     list_init( &fd->locks );
++
++    if (do_esync())
++        fd->esync_fd = esync_create_fd( 0, 0 );
+     return fd;
+ }
+ 
+@@ -1870,6 +1967,38 @@ void get_nt_name( struct fd *fd, struct unicode_str *name )
+     name->len = fd->nt_namelen;
+ }
+ 
++/* check whether a file is a symlink */
++int check_symlink( char *name )
++{
++    struct stat st;
++
++    lstat( name, &st );
++    return S_ISLNK( st.st_mode );
++}
++
++/* if flags does not contain O_SYMLINK then just use realpath */
++/* otherwise return the real path of the parent and append the filename of the symlink */
++char *normalize_path( const char *path, int flags )
++{
++    char tmp[PATH_MAX], resolved_path[PATH_MAX], *p;
++
++#if defined(O_SYMLINK)
++    if ((flags & O_SYMLINK) != O_SYMLINK)
++        return realpath( path, NULL );
++#endif
++
++    strcpy( tmp, path );
++    p = dirname( tmp );
++    if (p != tmp ) strcpy( tmp, p );
++    realpath( tmp, resolved_path );
++    strcat( resolved_path, "/" );
++    strcpy( tmp, path );
++    p = basename( tmp );
++    if (p != tmp) strcpy( tmp, p );
++    strcat( resolved_path, tmp );
++    return strdup( resolved_path );
++}
++
+ /* open() wrapper that returns a struct fd with no fd user set */
+ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_name,
+                     int flags, mode_t *mode, unsigned int access,
+@@ -1930,6 +2059,15 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
+     }
+     else rw_mode = O_RDONLY;
+ 
++    if ((path = dup_fd_name( root, name )))
++    {
++#if defined(O_SYMLINK)
++        if (check_symlink( path ) && (options & FILE_OPEN_REPARSE_POINT) && !(flags & O_CREAT))
++            flags |= O_SYMLINK;
++#endif
++        free( path );
++    }
++
+     if ((fd->unix_fd = open( name, rw_mode | (flags & ~O_TRUNC), *mode )) == -1)
+     {
+         /* if we tried to open a directory for write access, retry read-only */
+@@ -1956,10 +2094,11 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
+     *mode = st.st_mode;
+ 
+     /* only bother with an inode for normal files and directories */
+-    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode))
++    if (S_ISREG(st.st_mode) || S_ISDIR(st.st_mode) || S_ISLNK(st.st_mode))
+     {
+         unsigned int err;
+         struct inode *inode = get_inode( st.st_dev, st.st_ino, fd->unix_fd );
++        int is_link = S_ISLNK(st.st_mode), is_dir;
+ 
+         if (!inode)
+         {
+@@ -1971,7 +2110,7 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
+ 
+         if ((path = dup_fd_name( root, name )))
+         {
+-            fd->unix_name = realpath( path, NULL );
++            fd->unix_name = normalize_path( path, flags );
+             free( path );
+         }
+ 
+@@ -1984,13 +2123,17 @@ struct fd *open_fd( struct fd *root, const char *name, struct unicode_str nt_nam
+         list_add_head( &inode->open, &fd->inode_entry );
+         closed_fd = NULL;
+ 
++        is_dir = S_ISDIR(st.st_mode);
++        if (is_link)
++            is_reparse_dir(fd->unix_name, &is_dir);
++
+         /* check directory options */
+-        if ((options & FILE_DIRECTORY_FILE) && !S_ISDIR(st.st_mode))
++        if ((options & FILE_DIRECTORY_FILE) && !is_dir)
+         {
+             set_error( STATUS_NOT_A_DIRECTORY );
+             goto error;
+         }
+-        if ((options & FILE_NON_DIRECTORY_FILE) && S_ISDIR(st.st_mode))
++        if ((options & FILE_NON_DIRECTORY_FILE) && is_dir)
+         {
+             set_error( STATUS_FILE_IS_A_DIRECTORY );
+             goto error;
+@@ -2141,6 +2284,9 @@ void set_fd_signaled( struct fd *fd, int signaled )
+     if (fd->comp_flags & FILE_SKIP_SET_EVENT_ON_HANDLE) return;
+     fd->signaled = signaled;
+     if (signaled) wake_up( fd->user, 0 );
++
++    if (do_esync() && !signaled)
++        esync_clear( fd->esync_fd );
+ }
+ 
+ /* check if events are pending and if yes return which one(s) */
+@@ -2166,6 +2312,15 @@ int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry )
+     return ret;
+ }
+ 
++int default_fd_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct fd *fd = get_obj_fd( obj );
++    int ret = fd->esync_fd;
++    *type = ESYNC_MANUAL_SERVER;
++    release_object( fd );
++    return ret;
++}
++
+ int default_fd_get_poll_events( struct fd *fd )
+ {
+     int events = 0;
+@@ -2437,6 +2592,7 @@ static struct fd *get_handle_fd_obj( struct process *process, obj_handle_t handl
+ 
+ static int is_dir_empty( int fd )
+ {
++    int dir_fd;
+     DIR *dir;
+     int empty;
+     struct dirent *de;
+@@ -2444,8 +2600,13 @@ static int is_dir_empty( int fd )
+     if ((fd = dup( fd )) == -1)
+         return -1;
+ 
+-    if (!(dir = fdopendir( fd )))
++    /* use openat() so that if 'fd' was opened with O_SYMLINK we can still check the contents */
++    dir_fd = openat( fd, ".", O_RDONLY | O_DIRECTORY | O_NONBLOCK );
++    if (dir_fd == -1)
++        return -1;
++    if (!(dir = fdopendir( dir_fd )))
+     {
++        close( dir_fd );
+         close( fd );
+         return -1;
+     }
+@@ -2457,6 +2618,7 @@ static int is_dir_empty( int fd )
+         empty = 0;
+     }
+     closedir( dir );
++    close( dir_fd );
+     return empty;
+ }
+ 
+@@ -2495,7 +2657,7 @@ static void set_fd_disposition( struct fd *fd, unsigned int flags )
+             file_set_error();
+             return;
+         }
+-        if (S_ISREG( st.st_mode ))  /* can't unlink files we don't have permission to write */
++        if (S_ISREG( st.st_mode ) || S_ISLNK( st.st_mode ))  /* can't unlink files we don't have permission to write */
+         {
+             if (!(flags & FILE_DISPOSITION_IGNORE_READONLY_ATTRIBUTE) &&
+                 !(st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
+@@ -2579,7 +2741,7 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr, da
+         goto failed;
+     }
+ 
+-    if (!stat( name, &st ))
++    if (!lstat( name, &st ))
+     {
+         if (!fstat( fd->unix_fd, &st2 ) && st.st_ino == st2.st_ino && st.st_dev == st2.st_dev)
+         {
+@@ -2595,7 +2757,7 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr, da
+         }
+ 
+         /* can't replace directories or special files */
+-        if (!S_ISREG( st.st_mode ))
++        if (!S_ISREG( st.st_mode ) && !S_ISLNK( st.st_mode ))
+         {
+             set_error( STATUS_ACCESS_DENIED );
+             goto failed;
+@@ -2661,6 +2823,8 @@ static void set_fd_name( struct fd *fd, struct fd *root, const char *nameptr, da
+     fd->nt_name = dup_nt_name( root, nt_name, &fd->nt_namelen );
+     free( fd->unix_name );
+     fd->closed->unix_name = fd->unix_name = realpath( name, NULL );
++    if (!fd->unix_name)
++        fd->closed->unix_name = fd->unix_name = dup_fd_name( root, name ); /* dangling symlink */
+     free( name );
+     if (!fd->unix_name)
+         set_error( STATUS_NO_MEMORY );
+diff --git a/server/file.c b/server/file.c
+index 8f6566a0077d..cbef0c633833 100644
+--- a/server/file.c
++++ b/server/file.c
+@@ -94,6 +94,7 @@ static const struct object_ops file_ops =
+     add_queue,                    /* add_queue */
+     remove_queue,                 /* remove_queue */
+     default_fd_signaled,          /* signaled */
++    NULL,                         /* get_esync_fd */
+     no_satisfied,                 /* satisfied */
+     no_signal,                    /* signal */
+     file_get_fd,                  /* get_fd */
+@@ -294,6 +295,7 @@ static enum server_fd_type file_get_fd_type( struct fd *fd )
+ {
+     struct file *file = get_fd_user( fd );
+ 
++    if (S_ISLNK(file->mode)) return FD_TYPE_SYMLINK;
+     if (S_ISREG(file->mode) || S_ISBLK(file->mode)) return FD_TYPE_FILE;
+     if (S_ISDIR(file->mode)) return FD_TYPE_DIR;
+     return FD_TYPE_CHAR;
+diff --git a/server/file.h b/server/file.h
+index 4f5fc7b26f1d..82660f6f40c9 100644
+--- a/server/file.h
++++ b/server/file.h
+@@ -109,6 +109,7 @@ extern char *dup_fd_name( struct fd *root, const char *name ) __WINE_DEALLOC(fre
+ extern void get_nt_name( struct fd *fd, struct unicode_str *name );
+ 
+ extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
++extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
+ extern int default_fd_get_poll_events( struct fd *fd );
+ extern void default_poll_event( struct fd *fd, int event );
+ extern void fd_cancel_async( struct fd *fd, struct async *async );
+diff --git a/server/handle.c b/server/handle.c
+index c43b19c1160f..3b79982f18cb 100644
+--- a/server/handle.c
++++ b/server/handle.c
+@@ -126,6 +126,7 @@ static const struct object_ops handle_table_ops =
+     no_add_queue,                    /* add_queue */
+     NULL,                            /* remove_queue */
+     NULL,                            /* signaled */
++    NULL,                            /* get_esync_fd */
+     NULL,                            /* satisfied */
+     no_signal,                       /* signal */
+     no_get_fd,                       /* get_fd */
+diff --git a/server/hook.c b/server/hook.c
+index ffe7206369e1..921aa8aba2e0 100644
+--- a/server/hook.c
++++ b/server/hook.c
+@@ -81,6 +81,7 @@ static const struct object_ops hook_table_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+diff --git a/server/mailslot.c b/server/mailslot.c
+index b14954ad6c3c..e2ee8246633f 100644
+--- a/server/mailslot.c
++++ b/server/mailslot.c
+@@ -81,6 +81,7 @@ static const struct object_ops mailslot_ops =
+     add_queue,                 /* add_queue */
+     remove_queue,              /* remove_queue */
+     default_fd_signaled,       /* signaled */
++    NULL,                      /* get_esync_fd */
+     no_satisfied,              /* satisfied */
+     no_signal,                 /* signal */
+     mailslot_get_fd,           /* get_fd */
+@@ -142,6 +143,7 @@ static const struct object_ops mail_writer_ops =
+     no_add_queue,               /* add_queue */
+     NULL,                       /* remove_queue */
+     NULL,                       /* signaled */
++    NULL,                       /* get_esync_fd */
+     NULL,                       /* satisfied */
+     no_signal,                  /* signal */
+     mail_writer_get_fd,         /* get_fd */
+@@ -207,6 +209,7 @@ static const struct object_ops mailslot_device_ops =
+     no_add_queue,                   /* add_queue */
+     NULL,                           /* remove_queue */
+     NULL,                           /* signaled */
++    NULL,                           /* get_esync_fd */
+     no_satisfied,                   /* satisfied */
+     no_signal,                      /* signal */
+     no_get_fd,                      /* get_fd */
+@@ -237,6 +240,7 @@ static const struct object_ops mailslot_device_file_ops =
+     add_queue,                              /* add_queue */
+     remove_queue,                           /* remove_queue */
+     default_fd_signaled,                    /* signaled */
++    NULL,                                   /* get_esync_fd */
+     no_satisfied,                           /* satisfied */
+     no_signal,                              /* signal */
+     mailslot_device_file_get_fd,            /* get_fd */
+diff --git a/server/main.c b/server/main.c
+index 1248b92f24d5..5062d0999faa 100644
+--- a/server/main.c
++++ b/server/main.c
+@@ -34,6 +34,7 @@
+ #include "thread.h"
+ #include "request.h"
+ #include "unicode.h"
++#include "esync.h"
+ 
+ /* command-line options */
+ int debug_level = 0;
+@@ -229,8 +230,12 @@ int main( int argc, char *argv[] )
+     sock_init();
+     open_master_socket();
+ 
++    if (do_esync())
++        esync_init();
++
+     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
+     set_current_time();
++    init_scheduler();
+     init_signals();
+     init_memory();
+     init_directories( load_intl_file() );
+diff --git a/server/mapping.c b/server/mapping.c
+index 4bdd7c5080ac..a8593de3a5bc 100644
+--- a/server/mapping.c
++++ b/server/mapping.c
+@@ -67,6 +67,7 @@ static const struct object_ops ranges_ops =
+     no_add_queue,              /* add_queue */
+     NULL,                      /* remove_queue */
+     NULL,                      /* signaled */
++    NULL,                      /* get_esync_fd */
+     NULL,                      /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+@@ -103,6 +104,7 @@ static const struct object_ops shared_map_ops =
+     no_add_queue,              /* add_queue */
+     NULL,                      /* remove_queue */
+     NULL,                      /* signaled */
++    NULL,                      /* get_esync_fd */
+     NULL,                      /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+@@ -176,6 +178,7 @@ static const struct object_ops mapping_ops =
+     no_add_queue,                /* add_queue */
+     NULL,                        /* remove_queue */
+     NULL,                        /* signaled */
++    NULL,                        /* get_esync_fd */
+     NULL,                        /* satisfied */
+     no_signal,                   /* signal */
+     mapping_get_fd,              /* get_fd */
+diff --git a/server/mutex.c b/server/mutex.c
+index af0efe721323..4785a830e92b 100644
+--- a/server/mutex.c
++++ b/server/mutex.c
+@@ -73,6 +73,7 @@ static const struct object_ops mutex_ops =
+     add_queue,                 /* add_queue */
+     remove_queue,              /* remove_queue */
+     mutex_signaled,            /* signaled */
++    NULL,                      /* get_esync_fd */
+     mutex_satisfied,           /* satisfied */
+     mutex_signal,              /* signal */
+     no_get_fd,                 /* get_fd */
+diff --git a/server/named_pipe.c b/server/named_pipe.c
+index 59a90c36663d..06a8e9d46256 100644
+--- a/server/named_pipe.c
++++ b/server/named_pipe.c
+@@ -119,6 +119,7 @@ static const struct object_ops named_pipe_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+@@ -167,6 +168,7 @@ static const struct object_ops pipe_server_ops =
+     add_queue,                    /* add_queue */
+     remove_queue,                 /* remove_queue */
+     default_fd_signaled,          /* signaled */
++    default_fd_get_esync_fd,      /* get_esync_fd */
+     no_satisfied,                 /* satisfied */
+     no_signal,                    /* signal */
+     pipe_end_get_fd,              /* get_fd */
+@@ -211,6 +213,7 @@ static const struct object_ops pipe_client_ops =
+     add_queue,                    /* add_queue */
+     remove_queue,                 /* remove_queue */
+     default_fd_signaled,          /* signaled */
++    default_fd_get_esync_fd,      /* get_esync_fd */
+     no_satisfied,                 /* satisfied */
+     no_signal,                    /* signal */
+     pipe_end_get_fd,              /* get_fd */
+@@ -258,6 +261,7 @@ static const struct object_ops named_pipe_device_ops =
+     no_add_queue,                     /* add_queue */
+     NULL,                             /* remove_queue */
+     NULL,                             /* signaled */
++    NULL,                             /* get_esync_fd */
+     no_satisfied,                     /* satisfied */
+     no_signal,                        /* signal */
+     no_get_fd,                        /* get_fd */
+@@ -289,6 +293,7 @@ static const struct object_ops named_pipe_device_file_ops =
+     add_queue,                               /* add_queue */
+     remove_queue,                            /* remove_queue */
+     default_fd_signaled,                     /* signaled */
++    NULL,                                    /* get_esync_fd */
+     no_satisfied,                            /* satisfied */
+     no_signal,                               /* signal */
+     named_pipe_device_file_get_fd,           /* get_fd */
+@@ -339,6 +344,7 @@ static const struct object_ops named_pipe_dir_ops =
+     add_queue,                               /* add_queue */
+     remove_queue,                            /* remove_queue */
+     default_fd_signaled,                     /* signaled */
++    NULL,                                    /* get_esync_fd */
+     no_satisfied,                            /* satisfied */
+     no_signal,                               /* signal */
+     named_pipe_dir_get_fd,                   /* get_fd */
+diff --git a/server/object.c b/server/object.c
+index cd368ef724a7..4d8fcc5a7742 100644
+--- a/server/object.c
++++ b/server/object.c
+@@ -108,6 +108,7 @@ static const struct object_ops apc_reserve_ops =
+     no_add_queue,               /* add_queue */
+     NULL,                       /* remove_queue */
+     NULL,                       /* signaled */
++    NULL,                       /* get_esync_fd */
+     no_satisfied,               /* satisfied */
+     no_signal,                  /* signal */
+     no_get_fd,                  /* get_fd */
+@@ -132,6 +133,7 @@ static const struct object_ops completion_reserve_ops =
+     no_add_queue,              /* add_queue */
+     NULL,                      /* remove_queue */
+     NULL,                      /* signaled */
++    NULL,                      /* get_esync_fd */
+     no_satisfied,              /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+diff --git a/server/object.h b/server/object.h
+index 7555f564a08d..c0678255b6ae 100644
+--- a/server/object.h
++++ b/server/object.h
+@@ -78,6 +78,8 @@ struct object_ops
+     void (*remove_queue)(struct object *,struct wait_queue_entry *);
+     /* is object signaled? */
+     int  (*signaled)(struct object *,struct wait_queue_entry *);
++    /* return the esync fd for this object */
++    int (*get_esync_fd)(struct object *, enum esync_type *type);
+     /* wait satisfied */
+     void (*satisfied)(struct object *,struct wait_queue_entry *);
+     /* signal an object */
+diff --git a/server/process.c b/server/process.c
+index e06350f73112..0ac50cc17bde 100644
+--- a/server/process.c
++++ b/server/process.c
+@@ -63,6 +63,7 @@
+ #include "request.h"
+ #include "user.h"
+ #include "security.h"
++#include "esync.h"
+ 
+ /* process object */
+ 
+@@ -95,6 +96,7 @@ static struct security_descriptor *process_get_sd( struct object *obj );
+ static void process_poll_event( struct fd *fd, int event );
+ static struct list *process_get_kernel_obj_list( struct object *obj );
+ static void process_destroy( struct object *obj );
++static int process_get_esync_fd( struct object *obj, enum esync_type *type );
+ static void terminate_process( struct process *process, struct thread *skip, int exit_code );
+ 
+ static const struct object_ops process_ops =
+@@ -105,6 +107,7 @@ static const struct object_ops process_ops =
+     add_queue,                   /* add_queue */
+     remove_queue,                /* remove_queue */
+     process_signaled,            /* signaled */
++    process_get_esync_fd,        /* get_esync_fd */
+     no_satisfied,                /* satisfied */
+     no_signal,                   /* signal */
+     no_get_fd,                   /* get_fd */
+@@ -156,6 +159,7 @@ static const struct object_ops startup_info_ops =
+     add_queue,                     /* add_queue */
+     remove_queue,                  /* remove_queue */
+     startup_info_signaled,         /* signaled */
++    NULL,                          /* get_esync_fd */
+     no_satisfied,                  /* satisfied */
+     no_signal,                     /* signal */
+     no_get_fd,                     /* get_fd */
+@@ -217,6 +221,7 @@ static const struct object_ops job_ops =
+     add_queue,                     /* add_queue */
+     remove_queue,                  /* remove_queue */
+     job_signaled,                  /* signaled */
++    NULL,                          /* get_esync_fd */
+     no_satisfied,                  /* satisfied */
+     no_signal,                     /* signal */
+     no_get_fd,                     /* get_fd */
+@@ -686,6 +691,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
+     process->rawinput_kbd    = NULL;
+     memset( &process->image_info, 0, sizeof(process->image_info) );
+     list_init( &process->rawinput_entry );
++    process->esync_fd        = -1;
+     list_init( &process->kernel_object );
+     list_init( &process->thread_list );
+     list_init( &process->locks );
+@@ -736,6 +742,9 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
+     if (!process->handles || !process->token) goto error;
+     process->session_id = token_get_session_id( process->token );
+ 
++    if (do_esync())
++        process->esync_fd = esync_create_fd( 0, 0 );
++
+     set_fd_events( process->msg_fd, POLLIN );  /* start listening to events */
+     return process;
+ 
+@@ -784,6 +793,7 @@ static void process_destroy( struct object *obj )
+     free( process->rawinput_devices );
+     free( process->dir_cache );
+     free( process->image );
++    if (do_esync()) close( process->esync_fd );
+ }
+ 
+ /* dump a process on stdout for debugging purposes */
+@@ -801,6 +811,13 @@ static int process_signaled( struct object *obj, struct wait_queue_entry *entry
+     return !process->running_threads;
+ }
+ 
++static int process_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct process *process = (struct process *)obj;
++    *type = ESYNC_MANUAL_SERVER;
++    return process->esync_fd;
++}
++
+ static unsigned int process_map_access( struct object *obj, unsigned int access )
+ {
+     access = default_map_access( obj, access );
+diff --git a/server/process.h b/server/process.h
+index 96814ab7cf8b..ec74ba0490a0 100644
+--- a/server/process.h
++++ b/server/process.h
+@@ -86,6 +86,7 @@ struct process
+     struct list          rawinput_entry;  /* entry in the rawinput process list */
+     struct list          kernel_object;   /* list of kernel object pointers */
+     struct pe_image_info image_info;      /* main exe image info */
++    int                  esync_fd;        /* esync file descriptor (signaled on exit) */
+ };
+ 
+ /* process functions */
+diff --git a/server/protocol.def b/server/protocol.def
+index 292303c385fc..ffefbd20e1e4 100644
+--- a/server/protocol.def
++++ b/server/protocol.def
+@@ -1576,6 +1576,7 @@ enum server_fd_type
+ {
+     FD_TYPE_INVALID,  /* invalid file (no associated fd) */
+     FD_TYPE_FILE,     /* regular file */
++    FD_TYPE_SYMLINK,  /* symbolic link */
+     FD_TYPE_DIR,      /* directory */
+     FD_TYPE_SOCKET,   /* socket */
+     FD_TYPE_SERIAL,   /* serial port */
+@@ -4058,7 +4059,6 @@ struct handle_info
+     obj_handle_t handle;       /* process handle */
+ @END
+ 
+-
+ /* Iterate thread list for process */
+ @REQ(get_next_thread)
+     obj_handle_t process;      /* process handle */
+@@ -4070,6 +4070,53 @@ struct handle_info
+     obj_handle_t handle;       /* next thread handle */
+ @END
+ 
++enum esync_type
++{
++    ESYNC_SEMAPHORE = 1,
++    ESYNC_AUTO_EVENT,
++    ESYNC_MANUAL_EVENT,
++    ESYNC_MUTEX,
++    ESYNC_AUTO_SERVER,
++    ESYNC_MANUAL_SERVER,
++    ESYNC_QUEUE,
++};
++
++/* Create a new eventfd-based synchronization object */
++@REQ(create_esync)
++    unsigned int access;        /* wanted access rights */
++    int          initval;       /* initial value */
++    int          type;          /* type of esync object */
++    int          max;           /* maximum count on a semaphore */
++    VARARG(objattr,object_attributes); /* object attributes */
++@REPLY
++    obj_handle_t handle;        /* handle to the object */
++    int          type;          /* actual type (may be different for events) */
++    unsigned int shm_idx;
++@END
++
++@REQ(open_esync)
++    unsigned int access;        /* wanted access rights */
++    unsigned int attributes;    /* object attributes */
++    obj_handle_t rootdir;       /* root directory */
++    int          type;          /* type of esync object (above) */
++    VARARG(name,unicode_str);   /* object name */
++@REPLY
++    obj_handle_t handle;        /* handle to the event */
++    int          type;          /* type of esync object (above) */
++    unsigned int shm_idx;       /* this object's index into the shm section */
++@END
++
++/* Retrieve the esync fd for an object. */
++@REQ(get_esync_fd)
++    obj_handle_t handle;        /* handle to the object */
++@REPLY
++    int          type;
++    unsigned int shm_idx;
++@END
++
++@REQ(esync_msgwait)
++    int          in_msgwait;    /* are we in a message wait? */
++@END
+ 
+ /* Setup keyboard auto-repeat */
+ @REQ(set_keyboard_repeat)
+@@ -4079,3 +4126,7 @@ struct handle_info
+ @REPLY
+     int enable;                /* previous state of auto-repeat enable */
+ @END
++
++/* Retrieve the fd to wait on for user APCs. */
++@REQ(get_esync_apc_fd)
++@END
+diff --git a/server/queue.c b/server/queue.c
+index 76a82dcf7123..137e723d40cb 100644
+--- a/server/queue.c
++++ b/server/queue.c
+@@ -44,6 +44,7 @@
+ #include "process.h"
+ #include "request.h"
+ #include "user.h"
++#include "esync.h"
+ 
+ #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
+ #define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
+@@ -133,6 +134,9 @@ struct msg_queue
+     timeout_t              last_get_msg;    /* time of last get message call */
+     int                    keystate_lock;   /* owns an input keystate lock */
+     const queue_shm_t     *shared;          /* queue in session shared memory */
++    unsigned int           ignore_post_msg; /* ignore post messages newer than this unique id */
++    int                    esync_fd;        /* esync file descriptor (signalled on message) */
++    int                    esync_in_msgwait; /* our thread is currently waiting on us */
+ };
+ 
+ struct hotkey
+@@ -149,6 +153,7 @@ static void msg_queue_dump( struct object *obj, int verbose );
+ static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *entry );
+ static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
+ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
++static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
+ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
+ static void msg_queue_destroy( struct object *obj );
+ static void msg_queue_poll_event( struct fd *fd, int event );
+@@ -164,6 +169,7 @@ static const struct object_ops msg_queue_ops =
+     msg_queue_add_queue,       /* add_queue */
+     msg_queue_remove_queue,    /* remove_queue */
+     msg_queue_signaled,        /* signaled */
++    msg_queue_get_esync_fd,    /* get_esync_fd */
+     msg_queue_satisfied,       /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+@@ -201,6 +207,7 @@ static const struct object_ops thread_input_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+@@ -312,6 +319,9 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
+         queue->hooks           = NULL;
+         queue->last_get_msg    = current_time;
+         queue->keystate_lock   = 0;
++        queue->ignore_post_msg = 0;
++        queue->esync_fd        = -1;
++        queue->esync_in_msgwait = 0;
+         list_init( &queue->send_result );
+         list_init( &queue->callback_result );
+         list_init( &queue->pending_timers );
+@@ -334,6 +344,9 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
+         }
+         SHARED_WRITE_END;
+ 
++        if (do_esync())
++            queue->esync_fd = esync_create_fd( 0, 0 );
++
+         thread->queue = queue;
+ 
+         if ((desktop = get_thread_desktop( thread, 0 )))
+@@ -748,6 +761,9 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
+         if (queue->keystate_lock) unlock_input_keystate( queue->input );
+         queue->keystate_lock = 0;
+     }
++
++    if (do_esync() && !is_signaled( queue ))
++        esync_clear( queue->esync_fd );
+ }
+ 
+ /* check if message is matched by the filter */
+@@ -792,13 +808,21 @@ static inline struct msg_queue *get_current_queue(void)
+ }
+ 
+ /* get a (pseudo-)unique id to tag hardware messages */
+-static inline unsigned int get_unique_id(void)
++static inline unsigned int get_unique_hw_id(void)
+ {
+     static unsigned int id;
+     if (!++id) id = 1;  /* avoid an id of 0 */
+     return id;
+ }
+ 
++/* get unique increasing id to tag post messages */
++static inline unsigned int get_unique_post_id(void)
++{
++    static unsigned int id;
++    if (!++id) id = 1;
++    return id;
++}
++
+ /* try to merge a WM_MOUSEMOVE message with the last in the list; return 1 if successful */
+ static int merge_mousemove( struct thread_input *input, const struct message *msg )
+ {
+@@ -1110,7 +1134,7 @@ static int match_window( user_handle_t win, user_handle_t msg_win )
+ }
+ 
+ /* retrieve a posted message */
+-static int get_posted_message( struct msg_queue *queue, user_handle_t win,
++static int get_posted_message( struct msg_queue *queue, unsigned int ignore_msg, user_handle_t win,
+                                unsigned int first, unsigned int last, unsigned int flags,
+                                struct get_message_reply *reply )
+ {
+@@ -1121,6 +1145,7 @@ static int get_posted_message( struct msg_queue *queue, user_handle_t win,
+     {
+         if (!match_window( win, msg->win )) continue;
+         if (!check_msg_filter( msg->msg, first, last )) continue;
++        if (ignore_msg && (int)(msg->unique_id - ignore_msg) >= 0) continue;
+         goto found; /* found one */
+     }
+     return 0;
+@@ -1228,6 +1253,10 @@ static int is_queue_hung( struct msg_queue *queue )
+         if (get_wait_queue_thread(entry)->queue == queue)
+             return 0;  /* thread is waiting on queue -> not hung */
+     }
++
++    if (do_esync() && queue->esync_in_msgwait)
++        return 0;   /* thread is waiting on queue in absentia -> not hung */
++
+     return 1;
+ }
+ 
+@@ -1282,6 +1311,13 @@ static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entr
+     return ret || is_signaled( queue );
+ }
+ 
++static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct msg_queue *queue = (struct msg_queue *)obj;
++    *type = ESYNC_QUEUE;
++    return queue->esync_fd;
++}
++
+ static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry )
+ {
+     struct msg_queue *queue = (struct msg_queue *)obj;
+@@ -1338,6 +1374,7 @@ static void msg_queue_destroy( struct object *obj )
+     if (queue->hooks) release_object( queue->hooks );
+     if (queue->fd) release_object( queue->fd );
+     if (queue->shared) free_shared_object( queue->shared );
++    if (do_esync()) close( queue->esync_fd );
+ }
+ 
+ static void msg_queue_poll_event( struct fd *fd, int event )
+@@ -1801,6 +1838,7 @@ static int queue_hotkey_message( struct desktop *desktop, struct message *msg )
+     msg->msg       = WM_HOTKEY;
+     msg->wparam    = hotkey->id;
+     msg->lparam    = ((hotkey->vkey & 0xffff) << 16) | modifiers;
++    msg->unique_id = get_unique_post_id();
+ 
+     free( msg->data );
+     msg->data      = NULL;
+@@ -2778,7 +2816,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
+         }
+ 
+         /* now we can return it */
+-        if (!msg->unique_id) msg->unique_id = get_unique_id();
++        if (!msg->unique_id) msg->unique_id = get_unique_hw_id();
+         reply->type   = MSG_HARDWARE;
+         reply->win    = win;
+         reply->msg    = msg_code;
+@@ -2885,6 +2923,7 @@ void post_message( user_handle_t win, unsigned int message, lparam_t wparam, lpa
+         msg->result    = NULL;
+         msg->data      = NULL;
+         msg->data_size = 0;
++        msg->unique_id = get_unique_post_id();
+ 
+         get_message_defaults( thread->queue, &msg->x, &msg->y, &msg->time );
+ 
+@@ -3117,6 +3156,9 @@ DECL_HANDLER(set_queue_mask)
+             }
+             else wake_up( &queue->obj, 0 );
+         }
++
++        if (do_esync() && !is_signaled( queue ))
++            esync_clear( queue->esync_fd );
+     }
+ }
+ 
+@@ -3137,6 +3179,9 @@ DECL_HANDLER(get_queue_status)
+             shared->changed_bits &= ~req->clear_bits;
+         }
+         SHARED_WRITE_END;
++
++        if (do_esync() && !is_signaled( queue ))
++            esync_clear( queue->esync_fd );
+     }
+     else reply->wake_bits = reply->changed_bits = 0;
+ }
+@@ -3202,6 +3247,7 @@ DECL_HANDLER(send_message)
+             set_queue_bits( recv_queue, QS_SENDMESSAGE );
+             break;
+         case MSG_POSTED:
++            msg->unique_id = get_unique_post_id();
+             list_add_tail( &recv_queue->msg_list[POST_MESSAGE], &msg->entry );
+             set_queue_bits( recv_queue, QS_POSTMESSAGE|QS_ALLPOSTMESSAGE );
+             if (msg->msg == WM_HOTKEY)
+@@ -3336,12 +3382,12 @@ DECL_HANDLER(get_message)
+ 
+     /* then check for posted messages */
+     if ((filter & QS_POSTMESSAGE) &&
+-        get_posted_message( queue, get_win, req->get_first, req->get_last, req->flags, reply ))
++        get_posted_message( queue, queue->ignore_post_msg, get_win, req->get_first, req->get_last, req->flags, reply ))
+         return;
+ 
+     if ((filter & QS_HOTKEY) && queue->hotkey_count &&
+         req->get_first <= WM_HOTKEY && req->get_last >= WM_HOTKEY &&
+-        get_posted_message( queue, get_win, WM_HOTKEY, WM_HOTKEY, req->flags, reply ))
++        get_posted_message( queue, queue->ignore_post_msg, get_win, WM_HOTKEY, WM_HOTKEY, req->flags, reply ))
+         return;
+ 
+     /* only check for quit messages if not posted messages pending */
+@@ -3352,7 +3398,7 @@ DECL_HANDLER(get_message)
+     if ((filter & QS_INPUT) &&
+         filter_contains_hw_range( req->get_first, req->get_last ) &&
+         get_hardware_message( current, req->hw_id, get_win, req->get_first, req->get_last, req->flags, reply ))
+-        return;
++        goto found_msg;
+ 
+     /* now check for WM_PAINT */
+     if ((filter & QS_PAINT) &&
+@@ -3365,7 +3411,7 @@ DECL_HANDLER(get_message)
+         reply->wparam = 0;
+         reply->lparam = 0;
+         get_message_defaults( queue, &reply->x, &reply->y, &reply->time );
+-        return;
++        goto found_msg;
+     }
+ 
+     /* now check for timer */
+@@ -3381,9 +3427,19 @@ DECL_HANDLER(get_message)
+         get_message_defaults( queue, &reply->x, &reply->y, &reply->time );
+         if (!(req->flags & PM_NOYIELD) && current->process->idle_event)
+             set_event( current->process->idle_event );
+-        return;
++        goto found_msg;
+     }
+ 
++    /* if we previously skipped posted messages then check again */
++    if (queue->ignore_post_msg && (filter & QS_POSTMESSAGE) &&
++        get_posted_message( queue, 0, get_win, req->get_first, req->get_last, req->flags, reply ))
++        return;
++
++    if (queue->ignore_post_msg && (filter & QS_HOTKEY) && queue->hotkey_count &&
++        req->get_first <= WM_HOTKEY && req->get_last >= WM_HOTKEY &&
++        get_posted_message( queue, 0, get_win, WM_HOTKEY, WM_HOTKEY, req->flags, reply ))
++        return;
++
+     if (get_win == -1 && current->process->idle_event) set_event( current->process->idle_event );
+ 
+     SHARED_WRITE_BEGIN( queue_shm, queue_shm_t )
+@@ -3394,6 +3450,17 @@ DECL_HANDLER(get_message)
+     SHARED_WRITE_END;
+ 
+     set_error( STATUS_PENDING );  /* FIXME */
++
++    if (do_esync() && !is_signaled( queue ))
++        esync_clear( queue->esync_fd );
++
++    return;
++
++found_msg:
++    if (req->flags & PM_REMOVE)
++        queue->ignore_post_msg = 0;
++    else if (!queue->ignore_post_msg)
++        queue->ignore_post_msg = get_unique_post_id();
+ }
+ 
+ 
+@@ -3411,7 +3478,10 @@ DECL_HANDLER(reply_message)
+ DECL_HANDLER(accept_hardware_message)
+ {
+     if (current->queue)
++    {
+         release_hardware_message( current->queue, req->hw_id );
++        current->queue->ignore_post_msg = 0;
++    }
+     else
+         set_error( STATUS_ACCESS_DENIED );
+ }
+@@ -4166,6 +4236,23 @@ DECL_HANDLER(update_rawinput_devices)
+     }
+ }
+ 
++DECL_HANDLER(esync_msgwait)
++{
++    struct msg_queue *queue = get_current_queue();
++    const queue_shm_t *queue_shm;
++
++    if (!queue) return;
++    queue_shm = queue->shared;
++    queue->esync_in_msgwait = req->in_msgwait;
++
++    if (current->process->idle_event && !(queue_shm->wake_mask & QS_SMRESULT))
++        set_event( current->process->idle_event );
++
++    /* and start/stop waiting on the driver */
++    if (queue->fd)
++        set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
++}
++
+ DECL_HANDLER(set_keyboard_repeat)
+ {
+     struct desktop *desktop;
+@@ -4184,3 +4271,4 @@ DECL_HANDLER(set_keyboard_repeat)
+ 
+     release_object( desktop );
+ }
++
+diff --git a/server/registry.c b/server/registry.c
+index 3f02faaaefda..7bf65ba499c1 100644
+--- a/server/registry.c
++++ b/server/registry.c
+@@ -180,6 +180,7 @@ static const struct object_ops key_ops =
+     no_add_queue,            /* add_queue */
+     NULL,                    /* remove_queue */
+     NULL,                    /* signaled */
++    NULL,                    /* get_esync_fd */
+     NULL,                    /* satisfied */
+     no_signal,               /* signal */
+     no_get_fd,               /* get_fd */
+diff --git a/server/request.c b/server/request.c
+index 2254315b79e5..f4f5e713935d 100644
+--- a/server/request.c
++++ b/server/request.c
+@@ -89,6 +89,7 @@ static const struct object_ops master_socket_ops =
+     no_add_queue,                  /* add_queue */
+     NULL,                          /* remove_queue */
+     NULL,                          /* signaled */
++    NULL,                          /* get_esync_fd */
+     NULL,                          /* satisfied */
+     no_signal,                     /* signal */
+     no_get_fd,                     /* get_fd */
+diff --git a/server/request_handlers.h b/server/request_handlers.h
+index fd39842df564..5747dae4b7c5 100644
+--- a/server/request_handlers.h
++++ b/server/request_handlers.h
+@@ -298,7 +298,12 @@ DECL_HANDLER(terminate_job);
+ DECL_HANDLER(suspend_process);
+ DECL_HANDLER(resume_process);
+ DECL_HANDLER(get_next_thread);
++DECL_HANDLER(create_esync);
++DECL_HANDLER(open_esync);
++DECL_HANDLER(get_esync_fd);
++DECL_HANDLER(esync_msgwait);
+ DECL_HANDLER(set_keyboard_repeat);
++DECL_HANDLER(get_esync_apc_fd);
+ 
+ typedef void (*req_handler)( const void *req, void *reply );
+ static const req_handler req_handlers[REQ_NB_REQUESTS] =
+@@ -594,7 +599,12 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
+     (req_handler)req_suspend_process,
+     (req_handler)req_resume_process,
+     (req_handler)req_get_next_thread,
++    (req_handler)req_create_esync,
++    (req_handler)req_open_esync,
++    (req_handler)req_get_esync_fd,
++    (req_handler)req_esync_msgwait,
+     (req_handler)req_set_keyboard_repeat,
++    (req_handler)req_get_esync_apc_fd,
+ };
+ 
+ C_ASSERT( sizeof(abstime_t) == 8 );
+@@ -2264,9 +2274,35 @@ C_ASSERT( offsetof(struct get_next_thread_request, flags) == 28 );
+ C_ASSERT( sizeof(struct get_next_thread_request) == 32 );
+ C_ASSERT( offsetof(struct get_next_thread_reply, handle) == 8 );
+ C_ASSERT( sizeof(struct get_next_thread_reply) == 16 );
++C_ASSERT( offsetof(struct create_esync_request, access) == 12 );
++C_ASSERT( offsetof(struct create_esync_request, initval) == 16 );
++C_ASSERT( offsetof(struct create_esync_request, type) == 20 );
++C_ASSERT( offsetof(struct create_esync_request, max) == 24 );
++C_ASSERT( sizeof(struct create_esync_request) == 32 );
++C_ASSERT( offsetof(struct create_esync_reply, handle) == 8 );
++C_ASSERT( offsetof(struct create_esync_reply, type) == 12 );
++C_ASSERT( offsetof(struct create_esync_reply, shm_idx) == 16 );
++C_ASSERT( sizeof(struct create_esync_reply) == 24 );
++C_ASSERT( offsetof(struct open_esync_request, access) == 12 );
++C_ASSERT( offsetof(struct open_esync_request, attributes) == 16 );
++C_ASSERT( offsetof(struct open_esync_request, rootdir) == 20 );
++C_ASSERT( offsetof(struct open_esync_request, type) == 24 );
++C_ASSERT( sizeof(struct open_esync_request) == 32 );
++C_ASSERT( offsetof(struct open_esync_reply, handle) == 8 );
++C_ASSERT( offsetof(struct open_esync_reply, type) == 12 );
++C_ASSERT( offsetof(struct open_esync_reply, shm_idx) == 16 );
++C_ASSERT( sizeof(struct open_esync_reply) == 24 );
++C_ASSERT( offsetof(struct get_esync_fd_request, handle) == 12 );
++C_ASSERT( sizeof(struct get_esync_fd_request) == 16 );
++C_ASSERT( offsetof(struct get_esync_fd_reply, type) == 8 );
++C_ASSERT( offsetof(struct get_esync_fd_reply, shm_idx) == 12 );
++C_ASSERT( sizeof(struct get_esync_fd_reply) == 16 );
++C_ASSERT( offsetof(struct esync_msgwait_request, in_msgwait) == 12 );
++C_ASSERT( sizeof(struct esync_msgwait_request) == 16 );
+ C_ASSERT( offsetof(struct set_keyboard_repeat_request, enable) == 12 );
+ C_ASSERT( offsetof(struct set_keyboard_repeat_request, delay) == 16 );
+ C_ASSERT( offsetof(struct set_keyboard_repeat_request, period) == 20 );
+ C_ASSERT( sizeof(struct set_keyboard_repeat_request) == 24 );
+ C_ASSERT( offsetof(struct set_keyboard_repeat_reply, enable) == 8 );
+ C_ASSERT( sizeof(struct set_keyboard_repeat_reply) == 16 );
++C_ASSERT( sizeof(struct get_esync_apc_fd_request) == 16 );
+diff --git a/server/request_trace.h b/server/request_trace.h
+index 6e38f2a8379d..ce23329a99b8 100644
+--- a/server/request_trace.h
++++ b/server/request_trace.h
+@@ -3332,6 +3332,54 @@ static void dump_get_next_thread_reply( const struct get_next_thread_reply *req
+     fprintf( stderr, " handle=%04x", req->handle );
+ }
+ 
++static void dump_create_esync_request( const struct create_esync_request *req )
++{
++    fprintf( stderr, " access=%08x", req->access );
++    fprintf( stderr, ", initval=%d", req->initval );
++    fprintf( stderr, ", type=%d", req->type );
++    fprintf( stderr, ", max=%d", req->max );
++    dump_varargs_object_attributes( ", objattr=", cur_size );
++}
++
++static void dump_create_esync_reply( const struct create_esync_reply *req )
++{
++    fprintf( stderr, " handle=%04x", req->handle );
++    fprintf( stderr, ", type=%d", req->type );
++    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
++}
++
++static void dump_open_esync_request( const struct open_esync_request *req )
++{
++    fprintf( stderr, " access=%08x", req->access );
++    fprintf( stderr, ", attributes=%08x", req->attributes );
++    fprintf( stderr, ", rootdir=%04x", req->rootdir );
++    fprintf( stderr, ", type=%d", req->type );
++    dump_varargs_unicode_str( ", name=", cur_size );
++}
++
++static void dump_open_esync_reply( const struct open_esync_reply *req )
++{
++    fprintf( stderr, " handle=%04x", req->handle );
++    fprintf( stderr, ", type=%d", req->type );
++    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
++}
++
++static void dump_get_esync_fd_request( const struct get_esync_fd_request *req )
++{
++    fprintf( stderr, " handle=%04x", req->handle );
++}
++
++static void dump_get_esync_fd_reply( const struct get_esync_fd_reply *req )
++{
++    fprintf( stderr, " type=%d", req->type );
++    fprintf( stderr, ", shm_idx=%08x", req->shm_idx );
++}
++
++static void dump_esync_msgwait_request( const struct esync_msgwait_request *req )
++{
++    fprintf( stderr, " in_msgwait=%d", req->in_msgwait );
++}
++
+ static void dump_set_keyboard_repeat_request( const struct set_keyboard_repeat_request *req )
+ {
+     fprintf( stderr, " enable=%d", req->enable );
+@@ -3344,6 +3392,10 @@ static void dump_set_keyboard_repeat_reply( const struct set_keyboard_repeat_rep
+     fprintf( stderr, " enable=%d", req->enable );
+ }
+ 
++static void dump_get_esync_apc_fd_request( const struct get_esync_apc_fd_request *req )
++{
++}
++
+ typedef void (*dump_func)( const void *req );
+ 
+ static const dump_func req_dumpers[REQ_NB_REQUESTS] =
+@@ -3639,7 +3691,12 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] =
+     (dump_func)dump_suspend_process_request,
+     (dump_func)dump_resume_process_request,
+     (dump_func)dump_get_next_thread_request,
++    (dump_func)dump_create_esync_request,
++    (dump_func)dump_open_esync_request,
++    (dump_func)dump_get_esync_fd_request,
++    (dump_func)dump_esync_msgwait_request,
+     (dump_func)dump_set_keyboard_repeat_request,
++    (dump_func)dump_get_esync_apc_fd_request,
+ };
+ 
+ static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
+@@ -3935,7 +3992,12 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] =
+     NULL,
+     NULL,
+     (dump_func)dump_get_next_thread_reply,
++    (dump_func)dump_create_esync_reply,
++    (dump_func)dump_open_esync_reply,
++    (dump_func)dump_get_esync_fd_reply,
++    NULL,
+     (dump_func)dump_set_keyboard_repeat_reply,
++    NULL,
+ };
+ 
+ static const char * const req_names[REQ_NB_REQUESTS] =
+@@ -4231,7 +4293,12 @@ static const char * const req_names[REQ_NB_REQUESTS] =
+     "suspend_process",
+     "resume_process",
+     "get_next_thread",
++    "create_esync",
++    "open_esync",
++    "get_esync_fd",
++    "esync_msgwait",
+     "set_keyboard_repeat",
++    "get_esync_apc_fd",
+ };
+ 
+ static const struct
+diff --git a/server/scheduler.c b/server/scheduler.c
+new file mode 100644
+index 000000000000..4a5d82b208d4
+--- /dev/null
++++ b/server/scheduler.c
+@@ -0,0 +1,166 @@
++/*
++ * Scheduler priority management
++ *
++ * Copyright (C) 2015 Joakim Hernberg
++ * Copyright (C) 2015 Sebastian Lackner
++ *
++ * This library is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU Lesser General Public
++ * License as published by the Free Software Foundation; either
++ * version 2.1 of the License, or (at your option) any later version.
++ *
++ * This library is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
++ * Lesser General Public License for more details.
++ *
++ * You should have received a copy of the GNU Lesser General Public
++ * License along with this library; if not, write to the Free Software
++ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
++ */
++
++#include "config.h"
++
++#define _GNU_SOURCE  /* for SCHED_BATCH, SCHED_IDLE */
++#include <assert.h>
++#include <stdio.h>
++#include <stdarg.h>
++#ifdef HAVE_SYS_RESOURCE_H
++# include <sys/resource.h>
++#endif
++#ifdef HAVE_SCHED_H
++# include <sched.h>
++#endif
++#ifndef SCHED_RESET_ON_FORK
++# define SCHED_RESET_ON_FORK 0x40000000
++#endif
++#ifndef SCHED_IDLE
++ #define SCHED_IDLE 5
++#endif
++
++#include "ntstatus.h"
++#define WIN32_NO_STATUS
++#include "winternl.h"
++#include "thread.h"
++
++#if defined(__linux__) && defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_SCHED_H)
++
++static int thread_base_priority = -1;
++
++/* gets the priority value from an environment variable */
++static int get_priority( const char *variable, int min, int max )
++{
++    const char *env;
++    int val;
++
++    env = getenv( variable );
++    if (!env) return -1;
++
++    val = atoi( env );
++    if (val >= min && val <= max) return val;
++    fprintf( stderr, "wineserver: %s should be between %d and %d\n", variable, min, max );
++    return -1;
++}
++
++/* initializes the scheduler */
++void init_scheduler( void )
++{
++    int min, max, priority;
++
++    min = sched_get_priority_min( SCHED_FIFO );
++    max = sched_get_priority_max( SCHED_FIFO );
++    if (min == -1 || max == -1)
++        return;
++
++    /* change the wineserver priority */
++    if ((priority = get_priority( "STAGING_RT_PRIORITY_SERVER", min, max )) != -1)
++    {
++        struct sched_param param;
++        memset( &param, 0, sizeof(param) );
++        param.sched_priority = priority;
++        if (sched_setscheduler( 0, SCHED_FIFO | SCHED_RESET_ON_FORK, &param ) == -1 &&
++            sched_setscheduler( 0, SCHED_FIFO, &param ) == -1)
++        {
++            fprintf( stderr, "wineserver: failed to change priority to SCHED_FIFO/%d\n",
++                     param.sched_priority );
++            /* do not bother to check the rest */
++            return;
++        }
++
++        if (debug_level) fprintf( stderr, "wineserver: changed priority to SCHED_FIFO/%d\n",
++                                  param.sched_priority );
++    }
++
++    /* determine base priority which will be used for all threads */
++    if ((priority = get_priority( "STAGING_RT_PRIORITY_BASE", min, max - 4 )) != -1)
++    {
++        thread_base_priority = priority;
++
++        if (debug_level) fprintf( stderr, "wineserver: initialized thread base priority to %d\n",
++                                  thread_base_priority );
++    }
++}
++
++/* sets the scheduler priority of a windows thread */
++void set_scheduler_priority( struct thread *thread )
++{
++    struct sched_param param;
++    int policy;
++
++    if (thread_base_priority == -1) return;
++    if (thread->unix_tid == -1) return;
++
++    memset( &param, 0, sizeof(param) );
++    if (thread->priority >= THREAD_PRIORITY_TIME_CRITICAL)
++    {
++        policy = SCHED_FIFO;
++        param.sched_priority = thread_base_priority + 4;
++    }
++    else if (thread->priority >= THREAD_PRIORITY_HIGHEST)
++    {
++        policy = SCHED_FIFO;
++        param.sched_priority = thread_base_priority + 2;
++    }
++    else if (thread->priority >= THREAD_PRIORITY_ABOVE_NORMAL)
++    {
++        policy = SCHED_FIFO;
++        param.sched_priority = thread_base_priority;
++    }
++    else if (thread->priority >= THREAD_PRIORITY_NORMAL)
++    {
++        policy = SCHED_OTHER;
++    }
++    else if (thread->priority >= THREAD_PRIORITY_LOWEST)
++    {
++        policy = SCHED_BATCH;
++    }
++    else
++    {
++        policy = SCHED_IDLE;
++    }
++
++    if (sched_setscheduler(thread->unix_tid, policy | SCHED_RESET_ON_FORK, &param) == -1 &&
++        sched_setscheduler(thread->unix_tid, policy, &param) == -1)
++    {
++        static int once;
++        if (debug_level || !once++)
++            fprintf( stderr, "%04x: failed to change priority to %d/%d\n",
++                     thread->id, policy, param.sched_priority );
++        return;
++    }
++
++    if (debug_level) fprintf( stderr, "%04x: changed priority to %d/%d\n",
++                              thread->id, policy, param.sched_priority );
++}
++
++#else
++
++void init_scheduler( void )
++{
++}
++
++void set_scheduler_priority( struct thread *thread )
++{
++}
++
++#endif
+diff --git a/server/semaphore.c b/server/semaphore.c
+index 53b42a886df5..e3889f24601b 100644
+--- a/server/semaphore.c
++++ b/server/semaphore.c
+@@ -70,6 +70,7 @@ static const struct object_ops semaphore_ops =
+     add_queue,                     /* add_queue */
+     remove_queue,                  /* remove_queue */
+     semaphore_signaled,            /* signaled */
++    NULL,                          /* get_esync_fd */
+     semaphore_satisfied,           /* satisfied */
+     semaphore_signal,              /* signal */
+     no_get_fd,                     /* get_fd */
+diff --git a/server/serial.c b/server/serial.c
+index 209f2e9174e2..0d49a996c2a8 100644
+--- a/server/serial.c
++++ b/server/serial.c
+@@ -91,6 +91,7 @@ static const struct object_ops serial_ops =
+     add_queue,                    /* add_queue */
+     remove_queue,                 /* remove_queue */
+     default_fd_signaled,          /* signaled */
++    NULL,                         /* get_esync_fd */
+     no_satisfied,                 /* satisfied */
+     no_signal,                    /* signal */
+     serial_get_fd,                /* get_fd */
+diff --git a/server/signal.c b/server/signal.c
+index 19b76d44c169..55cd6aa037ea 100644
+--- a/server/signal.c
++++ b/server/signal.c
+@@ -62,6 +62,7 @@ static const struct object_ops handler_ops =
+     no_add_queue,             /* add_queue */
+     NULL,                     /* remove_queue */
+     NULL,                     /* signaled */
++    NULL,                     /* get_esync_fd */
+     NULL,                     /* satisfied */
+     no_signal,                /* signal */
+     no_get_fd,                /* get_fd */
+diff --git a/server/sock.c b/server/sock.c
+index 32d622aaebc6..2bb027a563c2 100644
+--- a/server/sock.c
++++ b/server/sock.c
+@@ -471,6 +471,7 @@ static const struct object_ops sock_ops =
+     add_queue,                    /* add_queue */
+     remove_queue,                 /* remove_queue */
+     default_fd_signaled,          /* signaled */
++    NULL,                         /* get_esync_fd */
+     no_satisfied,                 /* satisfied */
+     no_signal,                    /* signal */
+     sock_get_fd,                  /* get_fd */
+@@ -3599,6 +3600,7 @@ static const struct object_ops ifchange_ops =
+     no_add_queue,            /* add_queue */
+     NULL,                    /* remove_queue */
+     NULL,                    /* signaled */
++    NULL,                    /* get_esync_fd */
+     no_satisfied,            /* satisfied */
+     no_signal,               /* signal */
+     ifchange_get_fd,         /* get_fd */
+@@ -3820,6 +3822,7 @@ static const struct object_ops socket_device_ops =
+     no_add_queue,               /* add_queue */
+     NULL,                       /* remove_queue */
+     NULL,                       /* signaled */
++    NULL,                       /* get_esync_fd */
+     no_satisfied,               /* satisfied */
+     no_signal,                  /* signal */
+     no_get_fd,                  /* get_fd */
+diff --git a/server/symlink.c b/server/symlink.c
+index 74b60162c015..2dd9c6a798df 100644
+--- a/server/symlink.c
++++ b/server/symlink.c
+@@ -71,6 +71,7 @@ static const struct object_ops symlink_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+diff --git a/server/thread.c b/server/thread.c
+index b3ce5d9ac952..75bec00d416c 100644
+--- a/server/thread.c
++++ b/server/thread.c
+@@ -50,6 +50,7 @@
+ #include "request.h"
+ #include "user.h"
+ #include "security.h"
++#include "esync.h"
+ 
+ 
+ /* thread queues */
+@@ -96,6 +97,7 @@ static const struct object_ops thread_apc_ops =
+     add_queue,                  /* add_queue */
+     remove_queue,               /* remove_queue */
+     thread_apc_signaled,        /* signaled */
++    NULL,                       /* get_esync_fd */
+     no_satisfied,               /* satisfied */
+     no_signal,                  /* signal */
+     no_get_fd,                  /* get_fd */
+@@ -138,6 +140,7 @@ static const struct object_ops context_ops =
+     add_queue,                  /* add_queue */
+     remove_queue,               /* remove_queue */
+     context_signaled,           /* signaled */
++    NULL,                       /* get_esync_fd */
+     no_satisfied,               /* satisfied */
+     no_signal,                  /* signal */
+     no_get_fd,                  /* get_fd */
+@@ -174,6 +177,7 @@ struct type_descr thread_type =
+ 
+ static void dump_thread( struct object *obj, int verbose );
+ static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
++static int thread_get_esync_fd( struct object *obj, enum esync_type *type );
+ static unsigned int thread_map_access( struct object *obj, unsigned int access );
+ static void thread_poll_event( struct fd *fd, int event );
+ static struct list *thread_get_kernel_obj_list( struct object *obj );
+@@ -187,6 +191,7 @@ static const struct object_ops thread_ops =
+     add_queue,                  /* add_queue */
+     remove_queue,               /* remove_queue */
+     thread_signaled,            /* signaled */
++    thread_get_esync_fd,        /* get_esync_fd */
+     no_satisfied,               /* satisfied */
+     no_signal,                  /* signal */
+     no_get_fd,                  /* get_fd */
+@@ -226,6 +231,8 @@ static inline void init_thread_structure( struct thread *thread )
+     thread->context         = NULL;
+     thread->teb             = 0;
+     thread->entry_point     = 0;
++    thread->esync_fd        = -1;
++    thread->esync_apc_fd    = -1;
+     thread->system_regs     = 0;
+     thread->queue           = NULL;
+     thread->wait            = NULL;
+@@ -246,6 +253,7 @@ static inline void init_thread_structure( struct thread *thread )
+     thread->token           = NULL;
+     thread->desc            = NULL;
+     thread->desc_len        = 0;
++    thread->exit_poll       = NULL;
+ 
+     thread->creation_time = current_time;
+     thread->exit_time     = 0;
+@@ -373,6 +381,12 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
+         }
+     }
+ 
++    if (do_esync())
++    {
++        thread->esync_fd = esync_create_fd( 0, 0 );
++        thread->esync_apc_fd = esync_create_fd( 0, 0 );
++    }
++
+     set_fd_events( thread->request_fd, POLLIN );  /* start listening to events */
+     add_process_thread( thread->process, thread );
+     return thread;
+@@ -450,8 +464,12 @@ static void destroy_thread( struct object *obj )
+     list_remove( &thread->entry );
+     cleanup_thread( thread );
+     release_object( thread->process );
++    if (thread->exit_poll) remove_timeout_user( thread->exit_poll );
+     if (thread->id) free_ptid( thread->id );
+     if (thread->token) release_object( thread->token );
++
++    if (do_esync())
++        close( thread->esync_fd );
+ }
+ 
+ /* dump a thread on stdout for debugging purposes */
+@@ -467,7 +485,14 @@ static void dump_thread( struct object *obj, int verbose )
+ static int thread_signaled( struct object *obj, struct wait_queue_entry *entry )
+ {
+     struct thread *mythread = (struct thread *)obj;
+-    return (mythread->state == TERMINATED);
++    return mythread->state == TERMINATED && !mythread->exit_poll;
++}
++
++static int thread_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct thread *thread = (struct thread *)obj;
++    *type = ESYNC_MANUAL_SERVER;
++    return thread->esync_fd;
+ }
+ 
+ static unsigned int thread_map_access( struct object *obj, unsigned int access )
+@@ -624,7 +649,10 @@ static void set_thread_info( struct thread *thread,
+         if ((req->priority >= min && req->priority <= max) ||
+             req->priority == THREAD_PRIORITY_IDLE ||
+             req->priority == THREAD_PRIORITY_TIME_CRITICAL)
++        {
+             thread->priority = req->priority;
++            set_scheduler_priority( thread );
++        }
+         else
+             set_error( STATUS_INVALID_PARAMETER );
+     }
+@@ -1065,6 +1093,9 @@ void wake_up( struct object *obj, int max )
+     struct list *ptr;
+     int ret;
+ 
++    if (do_esync())
++        esync_wake_up( obj );
++
+     LIST_FOR_EACH( ptr, &obj->wait_queue )
+     {
+         struct wait_queue_entry *entry = LIST_ENTRY( ptr, struct wait_queue_entry, entry );
+@@ -1149,8 +1180,13 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
+     grab_object( apc );
+     list_add_tail( queue, &apc->entry );
+     if (!list_prev( queue, &apc->entry ))  /* first one */
++    {
+         wake_thread( thread );
+ 
++        if (do_esync() && queue == &thread->user_apc)
++            esync_wake_fd( thread->esync_apc_fd );
++    }
++
+     return 1;
+ }
+ 
+@@ -1196,6 +1232,10 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system
+         apc = LIST_ENTRY( ptr, struct thread_apc, entry );
+         list_remove( ptr );
+     }
++
++    if (do_esync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
++        esync_clear( thread->esync_apc_fd );
++
+     return apc;
+ }
+ 
+@@ -1272,6 +1312,26 @@ int thread_get_inflight_fd( struct thread *thread, int client )
+     return -1;
+ }
+ 
++static void check_terminated( void *arg )
++{
++    struct thread *thread = arg;
++    assert( thread->obj.ops == &thread_ops );
++    assert( thread->state == TERMINATED );
++
++    /* don't wake up until the thread is really dead, to avoid race conditions */
++    if (thread->unix_tid != -1 && !kill( thread->unix_tid, 0 ))
++    {
++        thread->exit_poll = add_timeout_user( -TICKS_PER_SEC / 1000, check_terminated, thread );
++        return;
++    }
++
++    /* grab reference since object can be destroyed while trying to wake up */
++    grab_object( &thread->obj );
++    thread->exit_poll = NULL;
++    wake_up( &thread->obj, 0 );
++    release_object( &thread->obj );
++}
++
+ /* kill a thread on the spot */
+ void kill_thread( struct thread *thread, int violent_death )
+ {
+@@ -1291,8 +1351,14 @@ void kill_thread( struct thread *thread, int violent_death )
+     }
+     kill_console_processes( thread, 0 );
+     abandon_mutexes( thread );
+-    wake_up( &thread->obj, 0 );
+-    if (violent_death) send_thread_signal( thread, SIGQUIT );
++    if (do_esync())
++        esync_abandon_mutexes( thread );
++    if (violent_death)
++    {
++        send_thread_signal( thread, SIGQUIT );
++        check_terminated( thread );
++    }
++    else wake_up( &thread->obj, 0 );
+     cleanup_thread( thread );
+     remove_process_thread( thread->process, thread );
+     release_object( thread );
+diff --git a/server/thread.h b/server/thread.h
+index 754e617b4842..52bcabb1cddf 100644
+--- a/server/thread.h
++++ b/server/thread.h
+@@ -56,6 +56,8 @@ struct thread
+     struct process        *process;
+     thread_id_t            id;            /* thread id */
+     struct list            mutex_list;    /* list of currently owned mutexes */
++    int                    esync_fd;      /* esync file descriptor (signalled on exit) */
++    int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
+     unsigned int           system_regs;   /* which system regs have been set */
+     struct msg_queue      *queue;         /* message queue */
+     struct thread_wait    *wait;          /* current wait condition if sleeping */
+@@ -93,6 +95,7 @@ struct thread
+     data_size_t            desc_len;      /* thread description length in bytes */
+     WCHAR                 *desc;          /* thread description string */
+     struct completion_wait *completion_wait; /* completion port wait object the thread is associated with */
++    struct timeout_user   *exit_poll;     /* poll if the thread/process has exited already */
+ };
+ 
+ extern struct thread *current;
+@@ -145,4 +148,9 @@ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 |
+ 
+ static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
+ 
++/* scheduler functions */
++
++extern void init_scheduler( void );
++extern void set_scheduler_priority( struct thread *thread );
++
+ #endif  /* __WINE_SERVER_THREAD_H */
+diff --git a/server/timer.c b/server/timer.c
+index b0b6ec815351..b4ab61132113 100644
+--- a/server/timer.c
++++ b/server/timer.c
+@@ -35,6 +35,7 @@
+ #include "file.h"
+ #include "handle.h"
+ #include "request.h"
++#include "esync.h"
+ 
+ static const WCHAR timer_name[] = {'T','i','m','e','r'};
+ 
+@@ -61,10 +62,12 @@ struct timer
+     struct thread       *thread;    /* thread that set the APC function */
+     client_ptr_t         callback;  /* callback APC function */
+     client_ptr_t         arg;       /* callback argument */
++    int                  esync_fd;  /* esync file descriptor */
+ };
+ 
+ static void timer_dump( struct object *obj, int verbose );
+ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
++static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
+ static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
+ static void timer_destroy( struct object *obj );
+ 
+@@ -76,6 +79,7 @@ static const struct object_ops timer_ops =
+     add_queue,                 /* add_queue */
+     remove_queue,              /* remove_queue */
+     timer_signaled,            /* signaled */
++    timer_get_esync_fd,        /* get_esync_fd */
+     timer_satisfied,           /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+@@ -110,6 +114,10 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
+             timer->period   = 0;
+             timer->timeout  = NULL;
+             timer->thread   = NULL;
++            timer->esync_fd = -1;
++
++            if (do_esync())
++                timer->esync_fd = esync_create_fd( 0, 0 );
+         }
+     }
+     return timer;
+@@ -181,6 +189,9 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
+     {
+         period = 0;  /* period doesn't make any sense for a manual timer */
+         timer->signaled = 0;
++
++        if (do_esync())
++            esync_clear( timer->esync_fd );
+     }
+     timer->when     = (expire <= 0) ? expire - monotonic_time : max( expire, current_time );
+     timer->period   = period;
+@@ -208,6 +219,13 @@ static int timer_signaled( struct object *obj, struct wait_queue_entry *entry )
+     return timer->signaled;
+ }
+ 
++static int timer_get_esync_fd( struct object *obj, enum esync_type *type )
++{
++    struct timer *timer = (struct timer *)obj;
++    *type = timer->manual ? ESYNC_MANUAL_SERVER : ESYNC_AUTO_SERVER;
++    return timer->esync_fd;
++}
++
+ static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
+ {
+     struct timer *timer = (struct timer *)obj;
+@@ -222,6 +240,7 @@ static void timer_destroy( struct object *obj )
+ 
+     if (timer->timeout) remove_timeout_user( timer->timeout );
+     if (timer->thread) release_object( timer->thread );
++    if (do_esync()) close( timer->esync_fd );
+ }
+ 
+ /* create a timer */
+diff --git a/server/token.c b/server/token.c
+index 7e20c670a166..b638ed192cb8 100644
+--- a/server/token.c
++++ b/server/token.c
+@@ -145,6 +145,7 @@ static const struct object_ops token_ops =
+     no_add_queue,              /* add_queue */
+     NULL,                      /* remove_queue */
+     NULL,                      /* signaled */
++    NULL,                      /* get_esync_fd */
+     NULL,                      /* satisfied */
+     no_signal,                 /* signal */
+     no_get_fd,                 /* get_fd */
+diff --git a/server/window.c b/server/window.c
+index 9d6ce4ba169a..be2c68b95fc3 100644
+--- a/server/window.c
++++ b/server/window.c
+@@ -107,6 +107,7 @@ static const struct object_ops window_ops =
+     no_add_queue,             /* add_queue */
+     NULL,                     /* remove_queue */
+     NULL,                     /* signaled */
++    NULL,                     /* get_esync_fd */
+     NULL,                     /* satisfied */
+     no_signal,                /* signal */
+     no_get_fd,                /* get_fd */
+diff --git a/server/winstation.c b/server/winstation.c
+index b3746090ccf8..126b70d625aa 100644
+--- a/server/winstation.c
++++ b/server/winstation.c
+@@ -76,6 +76,7 @@ static const struct object_ops winstation_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
+@@ -116,6 +117,7 @@ static const struct object_ops desktop_ops =
+     no_add_queue,                 /* add_queue */
+     NULL,                         /* remove_queue */
+     NULL,                         /* signaled */
++    NULL,                         /* get_esync_fd */
+     NULL,                         /* satisfied */
+     no_signal,                    /* signal */
+     no_get_fd,                    /* get_fd */
diff --git a/tur/hangover-wine/0006-android-shm.patch b/tur/hangover-wine/0006-android-shm.patch
new file mode 100644
index 000000000..788a45426
--- /dev/null
+++ b/tur/hangover-wine/0006-android-shm.patch
@@ -0,0 +1,159 @@
+From f055b615d87c987bdb156fd6d29b4eff00cd8d85 Mon Sep 17 00:00:00 2001
+From: PabloLabs36 <pablolabs36@gmail.com>
+Date: Tue, 31 Dec 2024 12:44:31 -0300
+Subject: [PATCH] server,ntdll: Implement 'shm_open' and 'shm_unlink' for
+ Android
+
+---
+ dlls/ntdll/unix/esync.c | 63 +++++++++++++++++++++++++++++++++++++++++
+ server/esync.c          | 63 +++++++++++++++++++++++++++++++++++++++++
+ 2 files changed, 126 insertions(+)
+
+diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
+index 86809b610c70..bcd9cf6b628e 100644
+--- a/dlls/ntdll/unix/esync.c
++++ b/dlls/ntdll/unix/esync.c
+@@ -107,6 +107,69 @@ static long pagesize;
+ 
+ static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
+ 
++#ifdef __ANDROID__
++#include <alloca.h>
++#include <errno.h>
++static int shm_unlink(const char *name) {
++    size_t namelen;
++    char *fname;
++
++    /* Construct the filename.  */
++    while (name[0] == '/') ++name;
++
++    if (name[0] == '\0') {
++        /* The name "/" is not supported.  */
++        errno = EINVAL;
++        return -1;
++    }
++
++    namelen = strlen(name);
++    fname = (char *) alloca(sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1 + namelen + 1);
++    memcpy(fname, "/data/data/com.gebox.emu/files/usr/tmp/", sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1);
++    memcpy(fname + sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1, name, namelen + 1);
++
++    return unlink(fname);
++}
++
++static int shm_open(const char *name, int oflag, mode_t mode) {
++    size_t namelen;
++    char *fname;
++    int fd;
++
++    /* Construct the filename.  */
++    while (name[0] == '/') ++name;
++
++    if (name[0] == '\0') {
++        /* The name "/" is not supported.  */
++        errno = EINVAL;
++        return -1;
++    }
++
++    namelen = strlen(name);
++    fname = (char *) alloca(sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1 + namelen + 1);
++    memcpy(fname, "/data/data/com.gebox.emu/files/usr/tmp/", sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1);
++    memcpy(fname + sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1, name, namelen + 1);
++
++    fd = open(fname, oflag, mode);
++    if (fd != -1) {
++        /* We got a descriptor.  Now set the FD_CLOEXEC bit.  */
++        int flags = fcntl(fd, F_GETFD, 0);
++        flags |= FD_CLOEXEC;
++        flags = fcntl(fd, F_SETFD, flags);
++
++        if (flags == -1) {
++            /* Something went wrong.  We cannot return the descriptor.  */
++            int save_errno = errno;
++            close(fd);
++            fd = -1;
++            errno = save_errno;
++        }
++    }
++
++    return fd;
++}
++#endif
++
+ static void *get_shm( unsigned int idx )
+ {
+     int entry  = (idx * 8) / pagesize;
+diff --git a/server/esync.c b/server/esync.c
+index e193f61b3a76..734dd84fb58a 100644
+--- a/server/esync.c
++++ b/server/esync.c
+@@ -64,6 +64,69 @@ static void **shm_addrs;
+ static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+ static long pagesize;
+ 
++#ifdef __ANDROID__
++#include <alloca.h>
++#include <errno.h>
++static int shm_unlink(const char *name) {
++    size_t namelen;
++    char *fname;
++
++    /* Construct the filename.  */
++    while (name[0] == '/') ++name;
++
++    if (name[0] == '\0') {
++        /* The name "/" is not supported.  */
++        errno = EINVAL;
++        return -1;
++    }
++
++    namelen = strlen(name);
++    fname = (char *) alloca(sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1 + namelen + 1);
++    memcpy(fname, "/data/data/com.gebox.emu/files/usr/tmp/", sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1);
++    memcpy(fname + sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1, name, namelen + 1);
++
++    return unlink(fname);
++}
++
++static int shm_open(const char *name, int oflag, mode_t mode) {
++    size_t namelen;
++    char *fname;
++    int fd;
++
++    /* Construct the filename.  */
++    while (name[0] == '/') ++name;
++
++    if (name[0] == '\0') {
++        /* The name "/" is not supported.  */
++        errno = EINVAL;
++        return -1;
++    }
++
++    namelen = strlen(name);
++    fname = (char *) alloca(sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1 + namelen + 1);
++    memcpy(fname, "/data/data/com.gebox.emu/files/usr/tmp/", sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1);
++    memcpy(fname + sizeof("/data/data/com.gebox.emu/files/usr/tmp/") - 1, name, namelen + 1);
++
++    fd = open(fname, oflag, mode);
++    if (fd != -1) {
++        /* We got a descriptor.  Now set the FD_CLOEXEC bit.  */
++        int flags = fcntl(fd, F_GETFD, 0);
++        flags |= FD_CLOEXEC;
++        flags = fcntl(fd, F_SETFD, flags);
++
++        if (flags == -1) {
++            /* Something went wrong.  We cannot return the descriptor.  */
++            int save_errno = errno;
++            close(fd);
++            fd = -1;
++            errno = save_errno;
++        }
++    }
++
++    return fd;
++}
++#endif
++
+ static void shm_cleanup(void)
+ {
+     close( shm_fd );
